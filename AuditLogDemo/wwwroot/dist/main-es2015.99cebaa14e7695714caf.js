(window.webpackJsonp = window.webpackJsonp || []).push([[1], { 0: function (e, t, n) { e.exports = n("zUnb") }, crnd: function (e, t) { function n(e) { return Promise.resolve().then((function () { var t = new Error("Cannot find module '" + e + "'"); throw t.code = "MODULE_NOT_FOUND", t })) } n.keys = function () { return [] }, n.resolve = n, e.exports = n, n.id = "crnd" }, zUnb: function (e, t, n) { "use strict"; function r(e) { return "function" == typeof e } n.r(t); let s = !1; const i = { Promise: void 0, set useDeprecatedSynchronousErrorHandling(e) { if (e) { const e = new Error; console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + e.stack) } else s && console.log("RxJS: Back to a better error behavior. Thank you. <3"); s = e }, get useDeprecatedSynchronousErrorHandling() { return s } }; function o(e) { setTimeout(() => { throw e }, 0) } const a = { closed: !0, next(e) { }, error(e) { if (i.useDeprecatedSynchronousErrorHandling) throw e; o(e) }, complete() { } }, l = (() => Array.isArray || (e => e && "number" == typeof e.length))(); function u(e) { return null !== e && "object" == typeof e } const c = (() => { function e(e) { return Error.call(this), this.message = e ? `${e.length} errors occurred during unsubscription:\n${e.map((e, t) => `${t + 1}) ${e.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = e, this } return e.prototype = Object.create(Error.prototype), e })(); let h = (() => { class e { constructor(e) { this.closed = !1, this._parentOrParents = null, this._subscriptions = null, e && (this._unsubscribe = e) } unsubscribe() { let t; if (this.closed) return; let { _parentOrParents: n, _unsubscribe: s, _subscriptions: i } = this; if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, n instanceof e) n.remove(this); else if (null !== n) for (let e = 0; e < n.length; ++e)n[e].remove(this); if (r(s)) try { s.call(this) } catch (o) { t = o instanceof c ? d(o.errors) : [o] } if (l(i)) { let e = -1, n = i.length; for (; ++e < n;) { const n = i[e]; if (u(n)) try { n.unsubscribe() } catch (o) { t = t || [], o instanceof c ? t = t.concat(d(o.errors)) : t.push(o) } } } if (t) throw new c(t) } add(t) { let n = t; if (!t) return e.EMPTY; switch (typeof t) { case "function": n = new e(t); case "object": if (n === this || n.closed || "function" != typeof n.unsubscribe) return n; if (this.closed) return n.unsubscribe(), n; if (!(n instanceof e)) { const t = n; n = new e, n._subscriptions = [t] } break; default: throw new Error("unrecognized teardown " + t + " added to Subscription.") }let { _parentOrParents: r } = n; if (null === r) n._parentOrParents = this; else if (r instanceof e) { if (r === this) return n; n._parentOrParents = [r, this] } else { if (-1 !== r.indexOf(this)) return n; r.push(this) } const s = this._subscriptions; return null === s ? this._subscriptions = [n] : s.push(n), n } remove(e) { const t = this._subscriptions; if (t) { const n = t.indexOf(e); -1 !== n && t.splice(n, 1) } } } return e.EMPTY = function (e) { return e.closed = !0, e }(new e), e })(); function d(e) { return e.reduce((e, t) => e.concat(t instanceof c ? t.errors : t), []) } const p = (() => "function" == typeof Symbol ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random())(); class f extends h { constructor(e, t, n) { switch (super(), this.syncErrorValue = null, this.syncErrorThrown = !1, this.syncErrorThrowable = !1, this.isStopped = !1, arguments.length) { case 0: this.destination = a; break; case 1: if (!e) { this.destination = a; break } if ("object" == typeof e) { e instanceof f ? (this.syncErrorThrowable = e.syncErrorThrowable, this.destination = e, e.add(this)) : (this.syncErrorThrowable = !0, this.destination = new g(this, e)); break } default: this.syncErrorThrowable = !0, this.destination = new g(this, e, t, n) } } [p]() { return this } static create(e, t, n) { const r = new f(e, t, n); return r.syncErrorThrowable = !1, r } next(e) { this.isStopped || this._next(e) } error(e) { this.isStopped || (this.isStopped = !0, this._error(e)) } complete() { this.isStopped || (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe()) } _next(e) { this.destination.next(e) } _error(e) { this.destination.error(e), this.unsubscribe() } _complete() { this.destination.complete(), this.unsubscribe() } _unsubscribeAndRecycle() { const { _parentOrParents: e } = this; return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parentOrParents = e, this } } class g extends f { constructor(e, t, n, s) { let i; super(), this._parentSubscriber = e; let o = this; r(t) ? i = t : t && (i = t.next, n = t.error, s = t.complete, t !== a && (o = Object.create(t), r(o.unsubscribe) && this.add(o.unsubscribe.bind(o)), o.unsubscribe = this.unsubscribe.bind(this))), this._context = o, this._next = i, this._error = n, this._complete = s } next(e) { if (!this.isStopped && this._next) { const { _parentSubscriber: t } = this; i.useDeprecatedSynchronousErrorHandling && t.syncErrorThrowable ? this.__tryOrSetError(t, this._next, e) && this.unsubscribe() : this.__tryOrUnsub(this._next, e) } } error(e) { if (!this.isStopped) { const { _parentSubscriber: t } = this, { useDeprecatedSynchronousErrorHandling: n } = i; if (this._error) n && t.syncErrorThrowable ? (this.__tryOrSetError(t, this._error, e), this.unsubscribe()) : (this.__tryOrUnsub(this._error, e), this.unsubscribe()); else if (t.syncErrorThrowable) n ? (t.syncErrorValue = e, t.syncErrorThrown = !0) : o(e), this.unsubscribe(); else { if (this.unsubscribe(), n) throw e; o(e) } } } complete() { if (!this.isStopped) { const { _parentSubscriber: e } = this; if (this._complete) { const t = () => this._complete.call(this._context); i.useDeprecatedSynchronousErrorHandling && e.syncErrorThrowable ? (this.__tryOrSetError(e, t), this.unsubscribe()) : (this.__tryOrUnsub(t), this.unsubscribe()) } else this.unsubscribe() } } __tryOrUnsub(e, t) { try { e.call(this._context, t) } catch (n) { if (this.unsubscribe(), i.useDeprecatedSynchronousErrorHandling) throw n; o(n) } } __tryOrSetError(e, t, n) { if (!i.useDeprecatedSynchronousErrorHandling) throw new Error("bad call"); try { t.call(this._context, n) } catch (r) { return i.useDeprecatedSynchronousErrorHandling ? (e.syncErrorValue = r, e.syncErrorThrown = !0, !0) : (o(r), !0) } return !1 } _unsubscribe() { const { _parentSubscriber: e } = this; this._context = null, this._parentSubscriber = null, e.unsubscribe() } } const m = (() => "function" == typeof Symbol && Symbol.observable || "@@observable")(); function y() { } function v(...e) { return w(e) } function w(e) { return e ? 1 === e.length ? e[0] : function (t) { return e.reduce((e, t) => t(e), t) } : y } let _ = (() => { class e { constructor(e) { this._isScalar = !1, e && (this._subscribe = e) } lift(t) { const n = new e; return n.source = this, n.operator = t, n } subscribe(e, t, n) { const { operator: r } = this, s = function (e, t, n) { if (e) { if (e instanceof f) return e; if (e[p]) return e[p]() } return e || t || n ? new f(e, t, n) : new f(a) }(e, t, n); if (s.add(r ? r.call(s, this.source) : this.source || i.useDeprecatedSynchronousErrorHandling && !s.syncErrorThrowable ? this._subscribe(s) : this._trySubscribe(s)), i.useDeprecatedSynchronousErrorHandling && s.syncErrorThrowable && (s.syncErrorThrowable = !1, s.syncErrorThrown)) throw s.syncErrorValue; return s } _trySubscribe(e) { try { return this._subscribe(e) } catch (t) { i.useDeprecatedSynchronousErrorHandling && (e.syncErrorThrown = !0, e.syncErrorValue = t), function (e) { for (; e;) { const { closed: t, destination: n, isStopped: r } = e; if (t || r) return !1; e = n && n instanceof f ? n : null } return !0 }(e) ? e.error(t) : console.warn(t) } } forEach(e, t) { return new (t = b(t))((t, n) => { let r; r = this.subscribe(t => { try { e(t) } catch (s) { n(s), r && r.unsubscribe() } }, n, t) }) } _subscribe(e) { const { source: t } = this; return t && t.subscribe(e) } [m]() { return this } pipe(...e) { return 0 === e.length ? this : w(e)(this) } toPromise(e) { return new (e = b(e))((e, t) => { let n; this.subscribe(e => n = e, e => t(e), () => e(n)) }) } } return e.create = t => new e(t), e })(); function b(e) { if (e || (e = i.Promise || Promise), !e) throw new Error("no Promise impl found"); return e } const C = (() => { function e() { return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this } return e.prototype = Object.create(Error.prototype), e })(); class x extends h { constructor(e, t) { super(), this.subject = e, this.subscriber = t, this.closed = !1 } unsubscribe() { if (this.closed) return; this.closed = !0; const e = this.subject, t = e.observers; if (this.subject = null, !t || 0 === t.length || e.isStopped || e.closed) return; const n = t.indexOf(this.subscriber); -1 !== n && t.splice(n, 1) } } class S extends f { constructor(e) { super(e), this.destination = e } } let E = (() => { class e extends _ { constructor() { super(), this.observers = [], this.closed = !1, this.isStopped = !1, this.hasError = !1, this.thrownError = null } [p]() { return new S(this) } lift(e) { const t = new T(this, this); return t.operator = e, t } next(e) { if (this.closed) throw new C; if (!this.isStopped) { const { observers: t } = this, n = t.length, r = t.slice(); for (let s = 0; s < n; s++)r[s].next(e) } } error(e) { if (this.closed) throw new C; this.hasError = !0, this.thrownError = e, this.isStopped = !0; const { observers: t } = this, n = t.length, r = t.slice(); for (let s = 0; s < n; s++)r[s].error(e); this.observers.length = 0 } complete() { if (this.closed) throw new C; this.isStopped = !0; const { observers: e } = this, t = e.length, n = e.slice(); for (let r = 0; r < t; r++)n[r].complete(); this.observers.length = 0 } unsubscribe() { this.isStopped = !0, this.closed = !0, this.observers = null } _trySubscribe(e) { if (this.closed) throw new C; return super._trySubscribe(e) } _subscribe(e) { if (this.closed) throw new C; return this.hasError ? (e.error(this.thrownError), h.EMPTY) : this.isStopped ? (e.complete(), h.EMPTY) : (this.observers.push(e), new x(this, e)) } asObservable() { const e = new _; return e.source = this, e } } return e.create = (e, t) => new T(e, t), e })(); class T extends E { constructor(e, t) { super(), this.destination = e, this.source = t } next(e) { const { destination: t } = this; t && t.next && t.next(e) } error(e) { const { destination: t } = this; t && t.error && this.destination.error(e) } complete() { const { destination: e } = this; e && e.complete && this.destination.complete() } _subscribe(e) { const { source: t } = this; return t ? this.source.subscribe(e) : h.EMPTY } } function k(e) { return e && "function" == typeof e.schedule } class R extends f { constructor(e, t, n) { super(), this.parent = e, this.outerValue = t, this.outerIndex = n, this.index = 0 } _next(e) { this.parent.notifyNext(this.outerValue, e, this.outerIndex, this.index++, this) } _error(e) { this.parent.notifyError(e, this), this.unsubscribe() } _complete() { this.parent.notifyComplete(this), this.unsubscribe() } } const A = e => t => { for (let n = 0, r = e.length; n < r && !t.closed; n++)t.next(e[n]); t.complete() }; function I() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" } const N = I(), P = e => e && "number" == typeof e.length && "function" != typeof e; function O(e) { return !!e && "function" != typeof e.subscribe && "function" == typeof e.then } const D = e => { if (e && "function" == typeof e[m]) return r = e, e => { const t = r[m](); if ("function" != typeof t.subscribe) throw new TypeError("Provided object does not correctly implement Symbol.observable"); return t.subscribe(e) }; if (P(e)) return A(e); if (O(e)) return n = e, e => (n.then(t => { e.closed || (e.next(t), e.complete()) }, t => e.error(t)).then(null, o), e); if (e && "function" == typeof e[N]) return t = e, e => { const n = t[N](); for (; ;) { const t = n.next(); if (t.done) { e.complete(); break } if (e.next(t.value), e.closed) break } return "function" == typeof n.return && e.add(() => { n.return && n.return() }), e }; { const t = u(e) ? "an invalid object" : `'${e}'`; throw new TypeError(`You provided ${t} where a stream was expected.` + " You can provide an Observable, Promise, Array, or Iterable.") } var t, n, r }; function U(e, t, n, r, s = new R(e, n, r)) { if (!s.closed) return t instanceof _ ? t.subscribe(s) : D(t)(s) } class M extends f { notifyNext(e, t, n, r, s) { this.destination.next(t) } notifyError(e, t) { this.destination.error(e) } notifyComplete(e) { this.destination.complete() } } function L(e, t) { return function (n) { if ("function" != typeof e) throw new TypeError("argument is not a function. Are you looking for `mapTo()`?"); return n.lift(new j(e, t)) } } class j { constructor(e, t) { this.project = e, this.thisArg = t } call(e, t) { return t.subscribe(new V(e, this.project, this.thisArg)) } } class V extends f { constructor(e, t, n) { super(e), this.project = t, this.count = 0, this.thisArg = n || this } _next(e) { let t; try { t = this.project.call(this.thisArg, e, this.count++) } catch (n) { return void this.destination.error(n) } this.destination.next(t) } } function H(e, t) { return new _(n => { const r = new h; let s = 0; return r.add(t.schedule((function () { s !== e.length ? (n.next(e[s++]), n.closed || r.add(this.schedule())) : n.complete() }))), r }) } function F(e, t) { return t ? function (e, t) { if (null != e) { if (function (e) { return e && "function" == typeof e[m] }(e)) return function (e, t) { return new _(n => { const r = new h; return r.add(t.schedule(() => { const s = e[m](); r.add(s.subscribe({ next(e) { r.add(t.schedule(() => n.next(e))) }, error(e) { r.add(t.schedule(() => n.error(e))) }, complete() { r.add(t.schedule(() => n.complete())) } })) })), r }) }(e, t); if (O(e)) return function (e, t) { return new _(n => { const r = new h; return r.add(t.schedule(() => e.then(e => { r.add(t.schedule(() => { n.next(e), r.add(t.schedule(() => n.complete())) })) }, e => { r.add(t.schedule(() => n.error(e))) }))), r }) }(e, t); if (P(e)) return H(e, t); if (function (e) { return e && "function" == typeof e[N] }(e) || "string" == typeof e) return function (e, t) { if (!e) throw new Error("Iterable cannot be null"); return new _(n => { const r = new h; let s; return r.add(() => { s && "function" == typeof s.return && s.return() }), r.add(t.schedule(() => { s = e[N](), r.add(t.schedule((function () { if (n.closed) return; let e, t; try { const n = s.next(); e = n.value, t = n.done } catch (r) { return void n.error(r) } t ? n.complete() : (n.next(e), this.schedule()) }))) })), r }) }(e, t) } throw new TypeError((null !== e && typeof e || e) + " is not observable") }(e, t) : e instanceof _ ? e : new _(D(e)) } function $(e, t, n = Number.POSITIVE_INFINITY) { return "function" == typeof t ? r => r.pipe($((n, r) => F(e(n, r)).pipe(L((e, s) => t(n, e, r, s))), n)) : ("number" == typeof t && (n = t), t => t.lift(new z(e, n))) } class z { constructor(e, t = Number.POSITIVE_INFINITY) { this.project = e, this.concurrent = t } call(e, t) { return t.subscribe(new B(e, this.project, this.concurrent)) } } class B extends M { constructor(e, t, n = Number.POSITIVE_INFINITY) { super(e), this.project = t, this.concurrent = n, this.hasCompleted = !1, this.buffer = [], this.active = 0, this.index = 0 } _next(e) { this.active < this.concurrent ? this._tryNext(e) : this.buffer.push(e) } _tryNext(e) { let t; const n = this.index++; try { t = this.project(e, n) } catch (r) { return void this.destination.error(r) } this.active++, this._innerSub(t, e, n) } _innerSub(e, t, n) { const r = new R(this, t, n), s = this.destination; s.add(r); const i = U(this, e, void 0, void 0, r); i !== r && s.add(i) } _complete() { this.hasCompleted = !0, 0 === this.active && 0 === this.buffer.length && this.destination.complete(), this.unsubscribe() } notifyNext(e, t, n, r, s) { this.destination.next(t) } notifyComplete(e) { const t = this.buffer; this.remove(e), this.active--, t.length > 0 ? this._next(t.shift()) : 0 === this.active && this.hasCompleted && this.destination.complete() } } function q(e) { return e } function W(e = Number.POSITIVE_INFINITY) { return $(q, e) } function Z(e, t) { return t ? H(e, t) : new _(A(e)) } function Q() { return function (e) { return e.lift(new G(e)) } } class G { constructor(e) { this.connectable = e } call(e, t) { const { connectable: n } = this; n._refCount++; const r = new K(e, n), s = t.subscribe(r); return r.closed || (r.connection = n.connect()), s } } class K extends f { constructor(e, t) { super(e), this.connectable = t } _unsubscribe() { const { connectable: e } = this; if (!e) return void (this.connection = null); this.connectable = null; const t = e._refCount; if (t <= 0) return void (this.connection = null); if (e._refCount = t - 1, t > 1) return void (this.connection = null); const { connection: n } = this, r = e._connection; this.connection = null, !r || n && r !== n || r.unsubscribe() } } class J extends _ { constructor(e, t) { super(), this.source = e, this.subjectFactory = t, this._refCount = 0, this._isComplete = !1 } _subscribe(e) { return this.getSubject().subscribe(e) } getSubject() { const e = this._subject; return e && !e.isStopped || (this._subject = this.subjectFactory()), this._subject } connect() { let e = this._connection; return e || (this._isComplete = !1, e = this._connection = new h, e.add(this.source.subscribe(new X(this.getSubject(), this))), e.closed && (this._connection = null, e = h.EMPTY)), e } refCount() { return Q()(this) } } const Y = (() => { const e = J.prototype; return { operator: { value: null }, _refCount: { value: 0, writable: !0 }, _subject: { value: null, writable: !0 }, _connection: { value: null, writable: !0 }, _subscribe: { value: e._subscribe }, _isComplete: { value: e._isComplete, writable: !0 }, getSubject: { value: e.getSubject }, connect: { value: e.connect }, refCount: { value: e.refCount } } })(); class X extends S { constructor(e, t) { super(e), this.connectable = t } _error(e) { this._unsubscribe(), super._error(e) } _complete() { this.connectable._isComplete = !0, this._unsubscribe(), super._complete() } _unsubscribe() { const e = this.connectable; if (e) { this.connectable = null; const t = e._connection; e._refCount = 0, e._subject = null, e._connection = null, t && t.unsubscribe() } } } function ee() { return new E } function te(e, t, n) { const r = function (e) { return function (...t) { if (e) { const n = e(...t); for (const e in n) this[e] = n[e] } } }(t); function s(...e) { if (this instanceof s) return r.apply(this, e), this; const t = new s(...e); return n.annotation = t, n; function n(e, n, r) { const s = e.hasOwnProperty("__parameters__") ? e.__parameters__ : Object.defineProperty(e, "__parameters__", { value: [] }).__parameters__; for (; s.length <= r;)s.push(null); return (s[r] = s[r] || []).push(t), e } } return n && (s.prototype = Object.create(n.prototype)), s.prototype.ngMetadataName = e, s.annotationCls = s, s } const ne = te("Inject", e => ({ token: e })), re = te("Optional"), se = te("Self"), ie = te("SkipSelf"); var oe = function (e) { return e[e.Default = 0] = "Default", e[e.Host = 1] = "Host", e[e.Self = 2] = "Self", e[e.SkipSelf = 4] = "SkipSelf", e[e.Optional = 8] = "Optional", e }({}); function ae(e) { for (let t in e) if (e[t] === ae) return t; throw Error("Could not find renamed property on target object.") } function le(e) { return { token: e.token, providedIn: e.providedIn || null, factory: e.factory, value: void 0 } } function ue(e) { const t = e[ce]; return t && t.token === e ? t : null } const ce = ae({ ngInjectableDef: ae }); function he(e) { if ("string" == typeof e) return e; if (e instanceof Array) return "[" + e.map(he).join(", ") + "]"; if (null == e) return "" + e; if (e.overriddenName) return `${e.overriddenName}`; if (e.name) return `${e.name}`; const t = e.toString(); if (null == t) return "" + t; const n = t.indexOf("\n"); return -1 === n ? t : t.substring(0, n) } const de = ae({ __forward_ref__: ae }); function pe(e) { return e.__forward_ref__ = pe, e.toString = function () { return he(this()) }, e } function fe(e) { const t = e; return "function" == typeof t && t.hasOwnProperty(de) && t.__forward_ref__ === pe ? t() : e } const ge = "undefined" != typeof globalThis && globalThis, me = "undefined" != typeof window && window, ye = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self, ve = "undefined" != typeof global && global, we = ge || ve || me || ye; class _e { constructor(e, t) { this._desc = e, this.ngMetadataName = "InjectionToken", this.ngInjectableDef = void 0, "number" == typeof t ? this.__NG_ELEMENT_ID__ = t : void 0 !== t && (this.ngInjectableDef = le({ token: this, providedIn: t.providedIn || "root", factory: t.factory })) } toString() { return `InjectionToken ${this._desc}` } } const be = new _e("INJECTOR", -1), Ce = new Object, xe = /\n/gm, Se = ae({ provide: String, useValue: ae }); let Ee = void 0; function Te(e) { const t = Ee; return Ee = e, t } function ke(e, t = oe.Default) { return function (e, t = oe.Default) { if (void 0 === Ee) throw new Error("inject() must be called from an injection context"); return null === Ee ? function (e, t, n) { const r = ue(e); if (r && "root" == r.providedIn) return void 0 === r.value ? r.value = r.factory() : r.value; if (n & oe.Optional) return null; throw new Error(`Injector: NOT_FOUND [${he(e)}]`) }(e, 0, t) : Ee.get(e, t & oe.Optional ? null : void 0, t) }(e, t) } class Re { get(e, t = Ce) { if (t === Ce) { const t = new Error(`NullInjectorError: No provider for ${he(e)}!`); throw t.name = "NullInjectorError", t } return t } } function Ae(e, t, n, r = null) { e = e && "\n" === e.charAt(0) && "\u0275" == e.charAt(1) ? e.substr(2) : e; let s = he(t); if (t instanceof Array) s = t.map(he).join(" -> "); else if ("object" == typeof t) { let e = []; for (let n in t) if (t.hasOwnProperty(n)) { let r = t[n]; e.push(n + ":" + ("string" == typeof r ? JSON.stringify(r) : he(r))) } s = `{${e.join(", ")}}` } return `${n}${r ? "(" + r + ")" : ""}[${s}]: ${e.replace(xe, "\n  ")}` } class Ie { } class Ne { } function Pe(e, t, n) { t >= e.length ? e.push(n) : e.splice(t, 0, n) } function Oe(e, t) { return t >= e.length - 1 ? e.pop() : e.splice(t, 1)[0] } const De = function () { var e = { Emulated: 0, Native: 1, None: 2, ShadowDom: 3 }; return e[e.Emulated] = "Emulated", e[e.Native] = "Native", e[e.None] = "None", e[e.ShadowDom] = "ShadowDom", e }(), Ue = (() => ("undefined" != typeof requestAnimationFrame && requestAnimationFrame || setTimeout).bind(we))(); function Me(e) { return e.ngDebugContext } function Le(e) { return e.ngOriginalError } function je(e, ...t) { e.error(...t) } class Ve { constructor() { this._console = console } handleError(e) { const t = this._findOriginalError(e), n = this._findContext(e), r = function (e) { return e.ngErrorLogger || je }(e); r(this._console, "ERROR", e), t && r(this._console, "ORIGINAL ERROR", t), n && r(this._console, "ERROR CONTEXT", n) } _findContext(e) { return e ? Me(e) ? Me(e) : this._findContext(Le(e)) : null } _findOriginalError(e) { let t = Le(e); for (; t && Le(t);)t = Le(t); return t } } let He = !0, Fe = !1; function $e() { return Fe = !0, He } class ze { constructor(e) { if (this.defaultDoc = e, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"), this.inertBodyElement = this.inertDocument.body, null == this.inertBodyElement) { const e = this.inertDocument.createElement("html"); this.inertDocument.appendChild(e), this.inertBodyElement = this.inertDocument.createElement("body"), e.appendChild(this.inertBodyElement) } this.inertBodyElement.innerHTML = '<svg><g onload="this.parentNode.remove()"></g></svg>', !this.inertBodyElement.querySelector || this.inertBodyElement.querySelector("svg") ? (this.inertBodyElement.innerHTML = '<svg><p><style><img src="</style><img src=x onerror=alert(1)//">', this.getInertBodyElement = this.inertBodyElement.querySelector && this.inertBodyElement.querySelector("svg img") && function () { try { return !!window.DOMParser } catch (e) { return !1 } }() ? this.getInertBodyElement_DOMParser : this.getInertBodyElement_InertDocument) : this.getInertBodyElement = this.getInertBodyElement_XHR } getInertBodyElement_XHR(e) { e = "<body><remove></remove>" + e + "</body>"; try { e = encodeURI(e) } catch (r) { return null } const t = new XMLHttpRequest; t.responseType = "document", t.open("GET", "data:text/html;charset=utf-8," + e, !1), t.send(void 0); const n = t.response.body; return n.removeChild(n.firstChild), n } getInertBodyElement_DOMParser(e) { e = "<body><remove></remove>" + e + "</body>"; try { const t = (new window.DOMParser).parseFromString(e, "text/html").body; return t.removeChild(t.firstChild), t } catch (t) { return null } } getInertBodyElement_InertDocument(e) { const t = this.inertDocument.createElement("template"); return "content" in t ? (t.innerHTML = e, t) : (this.inertBodyElement.innerHTML = e, this.defaultDoc.documentMode && this.stripCustomNsAttrs(this.inertBodyElement), this.inertBodyElement) } stripCustomNsAttrs(e) { const t = e.attributes; for (let r = t.length - 1; 0 < r; r--) { const n = t.item(r).name; "xmlns:ns1" !== n && 0 !== n.indexOf("ns1:") || e.removeAttribute(n) } let n = e.firstChild; for (; n;)n.nodeType === Node.ELEMENT_NODE && this.stripCustomNsAttrs(n), n = n.nextSibling } } const Be = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi, qe = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i; function We(e) { return (e = String(e)).match(Be) || e.match(qe) ? e : ($e() && console.warn(`WARNING: sanitizing unsafe URL value ${e} (see http://g.co/ng/security#xss)`), "unsafe:" + e) } function Ze(e) { const t = {}; for (const n of e.split(",")) t[n] = !0; return t } function Qe(...e) { const t = {}; for (const n of e) for (const e in n) n.hasOwnProperty(e) && (t[e] = !0); return t } const Ge = Ze("area,br,col,hr,img,wbr"), Ke = Ze("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), Je = Ze("rp,rt"), Ye = Qe(Je, Ke), Xe = Qe(Ge, Qe(Ke, Ze("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), Qe(Je, Ze("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), Ye), et = Ze("background,cite,href,itemtype,longdesc,poster,src,xlink:href"), tt = Ze("srcset"), nt = Qe(et, tt, Ze("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"), Ze("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")), rt = Ze("script,style,template"); class st { constructor() { this.sanitizedSomething = !1, this.buf = [] } sanitizeChildren(e) { let t = e.firstChild, n = !0; for (; t;)if (t.nodeType === Node.ELEMENT_NODE ? n = this.startElement(t) : t.nodeType === Node.TEXT_NODE ? this.chars(t.nodeValue) : this.sanitizedSomething = !0, n && t.firstChild) t = t.firstChild; else for (; t;) { t.nodeType === Node.ELEMENT_NODE && this.endElement(t); let e = this.checkClobberedElement(t, t.nextSibling); if (e) { t = e; break } t = this.checkClobberedElement(t, t.parentNode) } return this.buf.join("") } startElement(e) { const t = e.nodeName.toLowerCase(); if (!Xe.hasOwnProperty(t)) return this.sanitizedSomething = !0, !rt.hasOwnProperty(t); this.buf.push("<"), this.buf.push(t); const n = e.attributes; for (let s = 0; s < n.length; s++) { const e = n.item(s), t = e.name, i = t.toLowerCase(); if (!nt.hasOwnProperty(i)) { this.sanitizedSomething = !0; continue } let o = e.value; et[i] && (o = We(o)), tt[i] && (r = o, o = (r = String(r)).split(",").map(e => We(e.trim())).join(", ")), this.buf.push(" ", t, '="', at(o), '"') } var r; return this.buf.push(">"), !0 } endElement(e) { const t = e.nodeName.toLowerCase(); Xe.hasOwnProperty(t) && !Ge.hasOwnProperty(t) && (this.buf.push("</"), this.buf.push(t), this.buf.push(">")) } chars(e) { this.buf.push(at(e)) } checkClobberedElement(e, t) { if (t && (e.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error(`Failed to sanitize html because the element is clobbered: ${e.outerHTML}`); return t } } const it = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, ot = /([^\#-~ |!])/g; function at(e) { return e.replace(/&/g, "&amp;").replace(it, (function (e) { return "&#" + (1024 * (e.charCodeAt(0) - 55296) + (e.charCodeAt(1) - 56320) + 65536) + ";" })).replace(ot, (function (e) { return "&#" + e.charCodeAt(0) + ";" })).replace(/</g, "&lt;").replace(/>/g, "&gt;") } let lt; function ut(e) { return "content" in e && function (e) { return e.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === e.nodeName }(e) ? e.content : null } const ct = function () { var e = { NONE: 0, HTML: 1, STYLE: 2, SCRIPT: 3, URL: 4, RESOURCE_URL: 5 }; return e[e.NONE] = "NONE", e[e.HTML] = "HTML", e[e.STYLE] = "STYLE", e[e.SCRIPT] = "SCRIPT", e[e.URL] = "URL", e[e.RESOURCE_URL] = "RESOURCE_URL", e }(); class ht { } const dt = new RegExp("^([-,.\"'%_!# a-zA-Z0-9]+|(?:(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|Z|3d)?|(?:rgb|hsl)a?|(?:repeating-)?(?:linear|radial)-gradient|(?:calc|attr))\\([-0-9.%, #a-zA-Z]+\\))$", "g"), pt = /^url\(([^)]+)\)$/, ft = /([A-Z])/g; function gt(e) { try { return null != e ? e.toString().slice(0, 30) : e } catch (t) { return "[ERROR] Exception while trying to serialize the value" } } let mt = (() => { class e { } return e.__NG_ELEMENT_ID__ = () => yt(), e })(); const yt = (...e) => { }, vt = new _e("The presence of this token marks an injector as being the root injector."), wt = function (e, t, n) { return new Et(e, t, n) }; let _t = (() => { class e { static create(e, t) { return Array.isArray(e) ? wt(e, t, "") : wt(e.providers, e.parent, e.name || "") } } return e.THROW_IF_NOT_FOUND = Ce, e.NULL = new Re, e.ngInjectableDef = le({ token: e, providedIn: "any", factory: () => ke(be) }), e.__NG_ELEMENT_ID__ = -1, e })(); const bt = function (e) { return e }, Ct = [], xt = bt, St = function () { return Array.prototype.slice.call(arguments) }; class Et { constructor(e, t = _t.NULL, n = null) { this.parent = t, this.source = n; const r = this._records = new Map; r.set(_t, { token: _t, fn: bt, deps: Ct, value: this, useNew: !1 }), r.set(be, { token: be, fn: bt, deps: Ct, value: this, useNew: !1 }), function e(t, n) { if (n) if ((n = fe(n)) instanceof Array) for (let r = 0; r < n.length; r++)e(t, n[r]); else { if ("function" == typeof n) throw kt("Function/Class not supported", n); if (!n || "object" != typeof n || !n.provide) throw kt("Unexpected provider", n); { let e = fe(n.provide); const r = function (e) { const t = function (e) { let t = Ct; const n = e.deps; if (n && n.length) { t = []; for (let e = 0; e < n.length; e++) { let r = 6, s = fe(n[e]); if (s instanceof Array) for (let e = 0, t = s; e < t.length; e++) { const n = t[e]; n instanceof re || n == re ? r |= 1 : n instanceof ie || n == ie ? r &= -3 : n instanceof se || n == se ? r &= -5 : s = n instanceof ne ? n.token : fe(n) } t.push({ token: s, options: r }) } } else if (e.useExisting) t = [{ token: fe(e.useExisting), options: 6 }]; else if (!(n || Se in e)) throw kt("'deps' required", e); return t }(e); let n = bt, r = Ct, s = !1, i = fe(e.provide); if (Se in e) r = e.useValue; else if (e.useFactory) n = e.useFactory; else if (e.useExisting); else if (e.useClass) s = !0, n = fe(e.useClass); else { if ("function" != typeof i) throw kt("StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable", e); s = !0, n = i } return { deps: t, fn: n, useNew: s, value: r } }(n); if (!0 === n.multi) { let r = t.get(e); if (r) { if (r.fn !== St) throw Tt(e) } else t.set(e, r = { token: n.provide, deps: [], useNew: !1, fn: St, value: Ct }); e = n, r.deps.push({ token: e, options: 6 }) } const s = t.get(e); if (s && s.fn == St) throw Tt(e); t.set(e, r) } } }(r, e) } get(e, t, n = oe.Default) { const r = this._records.get(e); try { return function e(t, n, r, s, i, o) { try { return function (t, n, r, s, i, o) { let a; if (!n || o & oe.SkipSelf) o & oe.Self || (a = s.get(t, i, oe.Default)); else { if (a = n.value, a == xt) throw Error("\u0275Circular dependency"); if (a === Ct) { n.value = xt; let t = void 0, i = n.useNew, o = n.fn, l = n.deps, u = Ct; if (l.length) { u = []; for (let t = 0; t < l.length; t++) { const n = l[t], i = n.options, o = 2 & i ? r.get(n.token) : void 0; u.push(e(n.token, o, r, o || 4 & i ? s : _t.NULL, 1 & i ? null : _t.THROW_IF_NOT_FOUND, oe.Default)) } } n.value = a = i ? new o(...u) : o.apply(t, u) } } return a }(t, n, r, s, i, o) } catch (a) { throw a instanceof Error || (a = new Error(a)), (a.ngTempTokenPath = a.ngTempTokenPath || []).unshift(t), n && n.value == xt && (n.value = Ct), a } }(e, r, this._records, this.parent, t, n) } catch (s) { return function (e, t, n, r) { const s = e.ngTempTokenPath; throw t.__source && s.unshift(t.__source), e.message = Ae("\n" + e.message, s, "StaticInjectorError", r), e.ngTokenPath = s, e.ngTempTokenPath = null, e }(s, e, 0, this.source) } } toString() { const e = []; return this._records.forEach((t, n) => e.push(he(n))), `StaticInjector[${e.join(", ")}]` } } function Tt(e) { return kt("Cannot mix multi providers and regular providers", e) } function kt(e, t) { return new Error(Ae(e, t, "StaticInjectorError")) } const Rt = new _e("AnalyzeForEntryComponents"); let At = null; function It() { if (!At) { const e = we.Symbol; if (e && e.iterator) At = e.iterator; else { const e = Object.getOwnPropertyNames(Map.prototype); for (let t = 0; t < e.length; ++t) { const n = e[t]; "entries" !== n && "size" !== n && Map.prototype[n] === Map.prototype.entries && (At = n) } } } return At } function Nt(e, t) { return e === t || "number" == typeof e && "number" == typeof t && isNaN(e) && isNaN(t) } function Pt(e, t) { const n = Dt(e), r = Dt(t); if (n && r) return function (e, t, n) { const r = e[It()](), s = t[It()](); for (; ;) { const e = r.next(), t = s.next(); if (e.done && t.done) return !0; if (e.done || t.done) return !1; if (!n(e.value, t.value)) return !1 } }(e, t, Pt); { const s = e && ("object" == typeof e || "function" == typeof e), i = t && ("object" == typeof t || "function" == typeof t); return !(n || !s || r || !i) || Nt(e, t) } } class Ot { constructor(e) { this.wrapped = e } static wrap(e) { return new Ot(e) } static unwrap(e) { return Ot.isWrapped(e) ? e.wrapped : e } static isWrapped(e) { return e instanceof Ot } } function Dt(e) { return !!Ut(e) && (Array.isArray(e) || !(e instanceof Map) && It() in e) } function Ut(e) { return null !== e && ("function" == typeof e || "object" == typeof e) } function Mt(e) { return !!e && "function" == typeof e.then } function Lt(e) { return !!e && "function" == typeof e.subscribe } class jt { constructor(e, t, n) { this.previousValue = e, this.currentValue = t, this.firstChange = n } isFirstChange() { return this.firstChange } } class Vt { } function Ht(e) { const t = Error(`No component factory found for ${he(e)}. Did you add it to @NgModule.entryComponents?`); return t[Ft] = e, t } const Ft = "ngComponent"; class $t { resolveComponentFactory(e) { throw Ht(e) } } let zt = (() => { class e { } return e.NULL = new $t, e })(); class Bt { constructor(e, t, n) { this._parent = t, this._ngModule = n, this._factories = new Map; for (let r = 0; r < e.length; r++) { const t = e[r]; this._factories.set(t.componentType, t) } } resolveComponentFactory(e) { let t = this._factories.get(e); if (!t && this._parent && (t = this._parent.resolveComponentFactory(e)), !t) throw Ht(e); return new qt(t, this._ngModule) } } class qt extends Vt { constructor(e, t) { super(), this.factory = e, this.ngModule = t, this.selector = e.selector, this.componentType = e.componentType, this.ngContentSelectors = e.ngContentSelectors, this.inputs = e.inputs, this.outputs = e.outputs } create(e, t, n, r) { return this.factory.create(e, t, n, r || this.ngModule) } } function Wt(...e) { } let Zt = (() => { class e { constructor(e) { this.nativeElement = e } } return e.__NG_ELEMENT_ID__ = () => Qt(e), e })(); const Qt = Wt; class Gt { } class Kt { } const Jt = function () { var e = { Important: 1, DashCase: 2 }; return e[e.Important] = "Important", e[e.DashCase] = "DashCase", e }(); let Yt = (() => { class e { } return e.__NG_ELEMENT_ID__ = () => Xt(), e })(); const Xt = Wt; class en { constructor(e) { this.full = e, this.major = e.split(".")[0], this.minor = e.split(".")[1], this.patch = e.split(".").slice(2).join(".") } } const tn = new en("8.2.12"); class nn { constructor() { } supports(e) { return Dt(e) } create(e) { return new sn(e) } } const rn = (e, t) => t; class sn { constructor(e) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = e || rn } forEachItem(e) { let t; for (t = this._itHead; null !== t; t = t._next)e(t) } forEachOperation(e) { let t = this._itHead, n = this._removalsHead, r = 0, s = null; for (; t || n;) { const i = !n || t && t.currentIndex < un(n, r, s) ? t : n, o = un(i, r, s), a = i.currentIndex; if (i === n) r--, n = n._nextRemoved; else if (t = t._next, null == i.previousIndex) r++; else { s || (s = []); const e = o - r, t = a - r; if (e != t) { for (let n = 0; n < e; n++) { const r = n < s.length ? s[n] : s[n] = 0, i = r + n; t <= i && i < e && (s[n] = r + 1) } s[i.previousIndex] = t - e } } o !== a && e(i, o, a) } } forEachPreviousItem(e) { let t; for (t = this._previousItHead; null !== t; t = t._nextPrevious)e(t) } forEachAddedItem(e) { let t; for (t = this._additionsHead; null !== t; t = t._nextAdded)e(t) } forEachMovedItem(e) { let t; for (t = this._movesHead; null !== t; t = t._nextMoved)e(t) } forEachRemovedItem(e) { let t; for (t = this._removalsHead; null !== t; t = t._nextRemoved)e(t) } forEachIdentityChange(e) { let t; for (t = this._identityChangesHead; null !== t; t = t._nextIdentityChange)e(t) } diff(e) { if (null == e && (e = []), !Dt(e)) throw new Error(`Error trying to diff '${he(e)}'. Only arrays and iterables are allowed`); return this.check(e) ? this : null } onDestroy() { } check(e) { this._reset(); let t, n, r, s = this._itHead, i = !1; if (Array.isArray(e)) { this.length = e.length; for (let t = 0; t < this.length; t++)n = e[t], r = this._trackByFn(t, n), null !== s && Nt(s.trackById, r) ? (i && (s = this._verifyReinsertion(s, n, r, t)), Nt(s.item, n) || this._addIdentityChange(s, n)) : (s = this._mismatch(s, n, r, t), i = !0), s = s._next } else t = 0, function (e, t) { if (Array.isArray(e)) for (let n = 0; n < e.length; n++)t(e[n]); else { const n = e[It()](); let r; for (; !(r = n.next()).done;)t(r.value) } }(e, e => { r = this._trackByFn(t, e), null !== s && Nt(s.trackById, r) ? (i && (s = this._verifyReinsertion(s, e, r, t)), Nt(s.item, e) || this._addIdentityChange(s, e)) : (s = this._mismatch(s, e, r, t), i = !0), s = s._next, t++ }), this.length = t; return this._truncate(s), this.collection = e, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let e, t; for (e = this._previousItHead = this._itHead; null !== e; e = e._next)e._nextPrevious = e._next; for (e = this._additionsHead; null !== e; e = e._nextAdded)e.previousIndex = e.currentIndex; for (this._additionsHead = this._additionsTail = null, e = this._movesHead; null !== e; e = t)e.previousIndex = e.currentIndex, t = e._nextMoved; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(e, t, n, r) { let s; return null === e ? s = this._itTail : (s = e._prev, this._remove(e)), null !== (e = null === this._linkedRecords ? null : this._linkedRecords.get(n, r)) ? (Nt(e.item, t) || this._addIdentityChange(e, t), this._moveAfter(e, s, r)) : null !== (e = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(n, null)) ? (Nt(e.item, t) || this._addIdentityChange(e, t), this._reinsertAfter(e, s, r)) : e = this._addAfter(new on(t, n), s, r), e } _verifyReinsertion(e, t, n, r) { let s = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(n, null); return null !== s ? e = this._reinsertAfter(s, e._prev, r) : e.currentIndex != r && (e.currentIndex = r, this._addToMoves(e, r)), e } _truncate(e) { for (; null !== e;) { const t = e._next; this._addToRemovals(this._unlink(e)), e = t } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(e, t, n) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(e); const r = e._prevRemoved, s = e._nextRemoved; return null === r ? this._removalsHead = s : r._nextRemoved = s, null === s ? this._removalsTail = r : s._prevRemoved = r, this._insertAfter(e, t, n), this._addToMoves(e, n), e } _moveAfter(e, t, n) { return this._unlink(e), this._insertAfter(e, t, n), this._addToMoves(e, n), e } _addAfter(e, t, n) { return this._insertAfter(e, t, n), this._additionsTail = null === this._additionsTail ? this._additionsHead = e : this._additionsTail._nextAdded = e, e } _insertAfter(e, t, n) { const r = null === t ? this._itHead : t._next; return e._next = r, e._prev = t, null === r ? this._itTail = e : r._prev = e, null === t ? this._itHead = e : t._next = e, null === this._linkedRecords && (this._linkedRecords = new ln), this._linkedRecords.put(e), e.currentIndex = n, e } _remove(e) { return this._addToRemovals(this._unlink(e)) } _unlink(e) { null !== this._linkedRecords && this._linkedRecords.remove(e); const t = e._prev, n = e._next; return null === t ? this._itHead = n : t._next = n, null === n ? this._itTail = t : n._prev = t, e } _addToMoves(e, t) { return e.previousIndex === t ? e : (this._movesTail = null === this._movesTail ? this._movesHead = e : this._movesTail._nextMoved = e, e) } _addToRemovals(e) { return null === this._unlinkedRecords && (this._unlinkedRecords = new ln), this._unlinkedRecords.put(e), e.currentIndex = null, e._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = e, e._prevRemoved = null) : (e._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = e), e } _addIdentityChange(e, t) { return e.item = t, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = e : this._identityChangesTail._nextIdentityChange = e, e } } class on { constructor(e, t) { this.item = e, this.trackById = t, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class an { constructor() { this._head = null, this._tail = null } add(e) { null === this._head ? (this._head = this._tail = e, e._nextDup = null, e._prevDup = null) : (this._tail._nextDup = e, e._prevDup = this._tail, e._nextDup = null, this._tail = e) } get(e, t) { let n; for (n = this._head; null !== n; n = n._nextDup)if ((null === t || t <= n.currentIndex) && Nt(n.trackById, e)) return n; return null } remove(e) { const t = e._prevDup, n = e._nextDup; return null === t ? this._head = n : t._nextDup = n, null === n ? this._tail = t : n._prevDup = t, null === this._head } } class ln { constructor() { this.map = new Map } put(e) { const t = e.trackById; let n = this.map.get(t); n || (n = new an, this.map.set(t, n)), n.add(e) } get(e, t) { const n = this.map.get(e); return n ? n.get(e, t) : null } remove(e) { const t = e.trackById; return this.map.get(t).remove(e) && this.map.delete(t), e } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function un(e, t, n) { const r = e.previousIndex; if (null === r) return r; let s = 0; return n && r < n.length && (s = n[r]), r + t + s } class cn { constructor() { } supports(e) { return e instanceof Map || Ut(e) } create() { return new hn } } class hn { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(e) { let t; for (t = this._mapHead; null !== t; t = t._next)e(t) } forEachPreviousItem(e) { let t; for (t = this._previousMapHead; null !== t; t = t._nextPrevious)e(t) } forEachChangedItem(e) { let t; for (t = this._changesHead; null !== t; t = t._nextChanged)e(t) } forEachAddedItem(e) { let t; for (t = this._additionsHead; null !== t; t = t._nextAdded)e(t) } forEachRemovedItem(e) { let t; for (t = this._removalsHead; null !== t; t = t._nextRemoved)e(t) } diff(e) { if (e) { if (!(e instanceof Map || Ut(e))) throw new Error(`Error trying to diff '${he(e)}'. Only maps and objects are allowed`) } else e = new Map; return this.check(e) ? this : null } onDestroy() { } check(e) { this._reset(); let t = this._mapHead; if (this._appendAfter = null, this._forEach(e, (e, n) => { if (t && t.key === n) this._maybeAddToChanges(t, e), this._appendAfter = t, t = t._next; else { const r = this._getOrCreateRecordForKey(n, e); t = this._insertBeforeOrAppend(t, r) } }), t) { t._prev && (t._prev._next = null), this._removalsHead = t; for (let e = t; null !== e; e = e._nextRemoved)e === this._mapHead && (this._mapHead = null), this._records.delete(e.key), e._nextRemoved = e._next, e.previousValue = e.currentValue, e.currentValue = null, e._prev = null, e._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(e, t) { if (e) { const n = e._prev; return t._next = e, t._prev = n, e._prev = t, n && (n._next = t), e === this._mapHead && (this._mapHead = t), this._appendAfter = e, e } return this._appendAfter ? (this._appendAfter._next = t, t._prev = this._appendAfter) : this._mapHead = t, this._appendAfter = t, null } _getOrCreateRecordForKey(e, t) { if (this._records.has(e)) { const n = this._records.get(e); this._maybeAddToChanges(n, t); const r = n._prev, s = n._next; return r && (r._next = s), s && (s._prev = r), n._next = null, n._prev = null, n } const n = new dn(e); return this._records.set(e, n), n.currentValue = t, this._addToAdditions(n), n } _reset() { if (this.isDirty) { let e; for (this._previousMapHead = this._mapHead, e = this._previousMapHead; null !== e; e = e._next)e._nextPrevious = e._next; for (e = this._changesHead; null !== e; e = e._nextChanged)e.previousValue = e.currentValue; for (e = this._additionsHead; null != e; e = e._nextAdded)e.previousValue = e.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(e, t) { Nt(t, e.currentValue) || (e.previousValue = e.currentValue, e.currentValue = t, this._addToChanges(e)) } _addToAdditions(e) { null === this._additionsHead ? this._additionsHead = this._additionsTail = e : (this._additionsTail._nextAdded = e, this._additionsTail = e) } _addToChanges(e) { null === this._changesHead ? this._changesHead = this._changesTail = e : (this._changesTail._nextChanged = e, this._changesTail = e) } _forEach(e, t) { e instanceof Map ? e.forEach(t) : Object.keys(e).forEach(n => t(e[n], n)) } } class dn { constructor(e) { this.key = e, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } let pn = (() => { class e { constructor(e) { this.factories = e } static create(t, n) { if (null != n) { const e = n.factories.slice(); t = t.concat(e) } return new e(t) } static extend(t) { return { provide: e, useFactory: n => { if (!n) throw new Error("Cannot extend IterableDiffers without a parent injector"); return e.create(t, n) }, deps: [[e, new ie, new re]] } } find(e) { const t = this.factories.find(t => t.supports(e)); if (null != t) return t; throw new Error(`Cannot find a differ supporting object '${e}' of type '${n = e, n.name || typeof n}'`); var n } } return e.ngInjectableDef = le({ token: e, providedIn: "root", factory: () => new e([new nn]) }), e })(), fn = (() => { class e { constructor(e) { this.factories = e } static create(t, n) { if (n) { const e = n.factories.slice(); t = t.concat(e) } return new e(t) } static extend(t) { return { provide: e, useFactory: n => { if (!n) throw new Error("Cannot extend KeyValueDiffers without a parent injector"); return e.create(t, n) }, deps: [[e, new ie, new re]] } } find(e) { const t = this.factories.find(t => t.supports(e)); if (t) return t; throw new Error(`Cannot find a differ supporting object '${e}'`) } } return e.ngInjectableDef = le({ token: e, providedIn: "root", factory: () => new e([new cn]) }), e })(); const gn = [new cn], mn = new pn([new nn]), yn = new fn(gn); let vn = (() => { class e { } return e.__NG_ELEMENT_ID__ = () => wn(e, Zt), e })(); const wn = Wt; let _n = (() => { class e { } return e.__NG_ELEMENT_ID__ = () => bn(e, Zt), e })(); const bn = Wt; function Cn(e, t, n, r) { let s = `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: '${t}'. Current value: '${n}'.`; return r && (s += " It seems like the view has been created after its parent and its children have been dirty checked. Has it been created in a change detection hook ?"), function (e, t) { const n = new Error(e); return xn(n, t), n }(s, e) } function xn(e, t) { e.ngDebugContext = t, e.ngErrorLogger = t.logError.bind(t) } function Sn(e) { return new Error(`ViewDestroyedError: Attempt to use a destroyed view: ${e}`) } function En(e, t, n) { const r = e.state, s = 1792 & r; return s === t ? (e.state = -1793 & r | n, e.initIndex = -1, !0) : s === n } function Tn(e, t, n) { return (1792 & e.state) === t && e.initIndex <= n && (e.initIndex = n + 1, !0) } function kn(e, t) { return e.nodes[t] } function Rn(e, t) { return e.nodes[t] } function An(e, t) { return e.nodes[t] } function In(e, t) { return e.nodes[t] } function Nn(e, t) { return e.nodes[t] } const Pn = { setCurrentNode: void 0, createRootView: void 0, createEmbeddedView: void 0, createComponentView: void 0, createNgModuleRef: void 0, overrideProvider: void 0, overrideComponentView: void 0, clearOverrides: void 0, checkAndUpdateView: void 0, checkNoChangesView: void 0, destroyView: void 0, resolveDep: void 0, createDebugContext: void 0, handleEvent: void 0, updateDirectives: void 0, updateRenderer: void 0, dirtyParentQueries: void 0 }, On = () => { }, Dn = new Map; function Un(e) { let t = Dn.get(e); return t || (t = he(e) + "_" + Dn.size, Dn.set(e, t)), t } function Mn(e) { return { id: "$$undefined", styles: e.styles, encapsulation: e.encapsulation, data: e.data } } let Ln = 0; function jn(e, t, n, r) { return !(!(2 & e.state) && Nt(e.oldValues[t.bindingIndex + n], r)) } function Vn(e, t, n, r) { return !!jn(e, t, n, r) && (e.oldValues[t.bindingIndex + n] = r, !0) } function Hn(e, t, n, r) { const s = e.oldValues[t.bindingIndex + n]; if (1 & e.state || !Pt(s, r)) { const i = t.bindings[n].name; throw Cn(Pn.createDebugContext(e, t.nodeIndex), `${i}: ${s}`, `${i}: ${r}`, 0 != (1 & e.state)) } } function Fn(e) { let t = e; for (; t;)2 & t.def.flags && (t.state |= 8), t = t.viewContainerParent || t.parent } function $n(e, t) { let n = e; for (; n && n !== t;)n.state |= 64, n = n.viewContainerParent || n.parent } function zn(e, t, n, r) { try { return Fn(33554432 & e.def.nodes[t].flags ? Rn(e, t).componentView : e), Pn.handleEvent(e, t, n, r) } catch (s) { e.root.errorHandler.handleError(s) } } function Bn(e) { return e.parent ? Rn(e.parent, e.parentNodeDef.nodeIndex) : null } function qn(e) { return e.parent ? e.parentNodeDef.parent : null } function Wn(e, t) { switch (201347067 & t.flags) { case 1: return Rn(e, t.nodeIndex).renderElement; case 2: return kn(e, t.nodeIndex).renderText } } function Zn(e) { return !!e.parent && !!(32768 & e.parentNodeDef.flags) } function Qn(e) { return !(!e.parent || 32768 & e.parentNodeDef.flags) } function Gn(e) { return 1 << e % 32 } function Kn(e) { const t = {}; let n = 0; const r = {}; return e && e.forEach(([e, s]) => { "number" == typeof e ? (t[e] = s, n |= Gn(e)) : r[e] = s }), { matchedQueries: t, references: r, matchedQueryIds: n } } function Jn(e, t) { return e.map(e => { let n, r; return Array.isArray(e) ? [r, n] = e : (r = 0, n = e), n && ("function" == typeof n || "object" == typeof n) && t && Object.defineProperty(n, "__source", { value: t, configurable: !0 }), { flags: r, token: n, tokenKey: Un(n) } }) } function Yn(e, t, n) { let r = n.renderParent; return r ? 0 == (1 & r.flags) || 0 == (33554432 & r.flags) || r.element.componentRendererType && r.element.componentRendererType.encapsulation === De.Native ? Rn(e, n.renderParent.nodeIndex).renderElement : void 0 : t } const Xn = new WeakMap; function er(e) { let t = Xn.get(e); return t || (t = e(() => On), t.factory = e, Xn.set(e, t)), t } function tr(e, t, n, r, s) { 3 === t && (n = e.renderer.parentNode(Wn(e, e.def.lastRenderRootNode))), nr(e, t, 0, e.def.nodes.length - 1, n, r, s) } function nr(e, t, n, r, s, i, o) { for (let a = n; a <= r; a++) { const n = e.def.nodes[a]; 11 & n.flags && sr(e, n, t, s, i, o), a += n.childCount } } function rr(e, t, n, r, s, i) { let o = e; for (; o && !Zn(o);)o = o.parent; const a = o.parent, l = qn(o), u = l.nodeIndex + l.childCount; for (let c = l.nodeIndex + 1; c <= u; c++) { const e = a.def.nodes[c]; e.ngContentIndex === t && sr(a, e, n, r, s, i), c += e.childCount } if (!a.parent) { const o = e.root.projectableNodes[t]; if (o) for (let t = 0; t < o.length; t++)ir(e, o[t], n, r, s, i) } } function sr(e, t, n, r, s, i) { if (8 & t.flags) rr(e, t.ngContent.index, n, r, s, i); else { const o = Wn(e, t); if (3 === n && 33554432 & t.flags && 48 & t.bindingFlags ? (16 & t.bindingFlags && ir(e, o, n, r, s, i), 32 & t.bindingFlags && ir(Rn(e, t.nodeIndex).componentView, o, n, r, s, i)) : ir(e, o, n, r, s, i), 16777216 & t.flags) { const o = Rn(e, t.nodeIndex).viewContainer._embeddedViews; for (let e = 0; e < o.length; e++)tr(o[e], n, r, s, i) } 1 & t.flags && !t.element.name && nr(e, n, t.nodeIndex + 1, t.nodeIndex + t.childCount, r, s, i) } } function ir(e, t, n, r, s, i) { const o = e.renderer; switch (n) { case 1: o.appendChild(r, t); break; case 2: o.insertBefore(r, t, s); break; case 3: o.removeChild(r, t); break; case 0: i.push(t) } } const or = /^:([^:]+):(.+)$/; function ar(e) { if (":" === e[0]) { const t = e.match(or); return [t[1], t[2]] } return ["", e] } function lr(e) { let t = 0; for (let n = 0; n < e.length; n++)t |= e[n].flags; return t } const ur = new Object, cr = Un(_t), hr = Un(be), dr = Un(Ie); function pr(e, t, n, r) { return n = fe(n), { index: -1, deps: Jn(r, he(t)), flags: e, token: t, value: n } } function fr(e, t, n = _t.THROW_IF_NOT_FOUND) { const r = Te(e); try { if (8 & t.flags) return t.token; if (2 & t.flags && (n = null), 1 & t.flags) return e._parent.get(t.token, n); const o = t.tokenKey; switch (o) { case cr: case hr: case dr: return e }const a = e._def.providersByKey[o]; let l; if (a) { let t = e._providers[a.index]; return void 0 === t && (t = e._providers[a.index] = gr(e, a)), t === ur ? void 0 : t } if ((l = ue(t.token)) && (s = e, null != (i = l).providedIn && (function (e, t) { return e._def.modules.indexOf(t) > -1 }(s, i.providedIn) || "root" === i.providedIn && s._def.isRoot))) { const n = e._providers.length; return e._def.providers[n] = e._def.providersByKey[t.tokenKey] = { flags: 5120, value: l.factory, deps: [], index: n, token: t.token }, e._providers[n] = ur, e._providers[n] = gr(e, e._def.providersByKey[t.tokenKey]) } return 4 & t.flags ? n : e._parent.get(t.token, n) } finally { Te(r) } var s, i } function gr(e, t) { let n; switch (201347067 & t.flags) { case 512: n = function (e, t, n) { const r = n.length; switch (r) { case 0: return new t; case 1: return new t(fr(e, n[0])); case 2: return new t(fr(e, n[0]), fr(e, n[1])); case 3: return new t(fr(e, n[0]), fr(e, n[1]), fr(e, n[2])); default: const s = new Array(r); for (let t = 0; t < r; t++)s[t] = fr(e, n[t]); return new t(...s) } }(e, t.value, t.deps); break; case 1024: n = function (e, t, n) { const r = n.length; switch (r) { case 0: return t(); case 1: return t(fr(e, n[0])); case 2: return t(fr(e, n[0]), fr(e, n[1])); case 3: return t(fr(e, n[0]), fr(e, n[1]), fr(e, n[2])); default: const s = Array(r); for (let t = 0; t < r; t++)s[t] = fr(e, n[t]); return t(...s) } }(e, t.value, t.deps); break; case 2048: n = fr(e, t.deps[0]); break; case 256: n = t.value }return n === ur || null === n || "object" != typeof n || 131072 & t.flags || "function" != typeof n.ngOnDestroy || (t.flags |= 131072), void 0 === n ? ur : n } function mr(e, t) { const n = e.viewContainer._embeddedViews; if ((null == t || t >= n.length) && (t = n.length - 1), t < 0) return null; const r = n[t]; return r.viewContainerParent = null, Oe(n, t), Pn.dirtyParentQueries(r), vr(r), r } function yr(e, t, n) { const r = t ? Wn(t, t.def.lastRenderRootNode) : e.renderElement, s = n.renderer.parentNode(r), i = n.renderer.nextSibling(r); tr(n, 2, s, i, void 0) } function vr(e) { tr(e, 3, null, null, void 0) } const wr = new Object; function _r(e, t, n, r, s, i) { return new br(e, t, n, r, s, i) } class br extends Vt { constructor(e, t, n, r, s, i) { super(), this.selector = e, this.componentType = t, this._inputs = r, this._outputs = s, this.ngContentSelectors = i, this.viewDefFactory = n } get inputs() { const e = [], t = this._inputs; for (let n in t) e.push({ propName: n, templateName: t[n] }); return e } get outputs() { const e = []; for (let t in this._outputs) e.push({ propName: t, templateName: this._outputs[t] }); return e } create(e, t, n, r) { if (!r) throw new Error("ngModule should be provided"); const s = er(this.viewDefFactory), i = s.nodes[0].element.componentProvider.nodeIndex, o = Pn.createRootView(e, t || [], n, s, r, wr), a = An(o, i).instance; return n && o.renderer.setAttribute(Rn(o, 0).renderElement, "ng-version", tn.full), new Cr(o, new Tr(o), a) } } class Cr extends class { }{ constructor(e, t, n) { super(), this._view = e, this._viewRef = t, this._component = n, this._elDef = this._view.def.nodes[0], this.hostView = t, this.changeDetectorRef = t, this.instance = n } get location() { return new Zt(Rn(this._view, this._elDef.nodeIndex).renderElement) } get injector() { return new Ir(this._view, this._elDef) } get componentType() { return this._component.constructor } destroy() { this._viewRef.destroy() } onDestroy(e) { this._viewRef.onDestroy(e) } } function xr(e, t, n) { return new Sr(e, t, n) } class Sr { constructor(e, t, n) { this._view = e, this._elDef = t, this._data = n, this._embeddedViews = [] } get element() { return new Zt(this._data.renderElement) } get injector() { return new Ir(this._view, this._elDef) } get parentInjector() { let e = this._view, t = this._elDef.parent; for (; !t && e;)t = qn(e), e = e.parent; return e ? new Ir(e, t) : new Ir(this._view, null) } clear() { for (let e = this._embeddedViews.length - 1; e >= 0; e--) { const t = mr(this._data, e); Pn.destroyView(t) } } get(e) { const t = this._embeddedViews[e]; if (t) { const e = new Tr(t); return e.attachToViewContainerRef(this), e } return null } get length() { return this._embeddedViews.length } createEmbeddedView(e, t, n) { const r = e.createEmbeddedView(t || {}); return this.insert(r, n), r } createComponent(e, t, n, r, s) { const i = n || this.parentInjector; s || e instanceof qt || (s = i.get(Ie)); const o = e.create(i, r, void 0, s); return this.insert(o.hostView, t), o } insert(e, t) { if (e.destroyed) throw new Error("Cannot insert a destroyed View in a ViewContainer!"); const n = e; return function (e, t, n, r) { let s = t.viewContainer._embeddedViews; null == n && (n = s.length), r.viewContainerParent = e, Pe(s, n, r), function (e, t) { const n = Bn(t); if (!n || n === e || 16 & t.state) return; t.state |= 16; let r = n.template._projectedViews; r || (r = n.template._projectedViews = []), r.push(t), function (e, t) { if (4 & t.flags) return; e.nodeFlags |= 4, t.flags |= 4; let n = t.parent; for (; n;)n.childFlags |= 4, n = n.parent }(t.parent.def, t.parentNodeDef) }(t, r), Pn.dirtyParentQueries(r), yr(t, n > 0 ? s[n - 1] : null, r) }(this._view, this._data, t, n._view), n.attachToViewContainerRef(this), e } move(e, t) { if (e.destroyed) throw new Error("Cannot move a destroyed View in a ViewContainer!"); const n = this._embeddedViews.indexOf(e._view); return function (e, t, n) { const r = e.viewContainer._embeddedViews, s = r[t]; Oe(r, t), null == n && (n = r.length), Pe(r, n, s), Pn.dirtyParentQueries(s), vr(s), yr(e, n > 0 ? r[n - 1] : null, s) }(this._data, n, t), e } indexOf(e) { return this._embeddedViews.indexOf(e._view) } remove(e) { const t = mr(this._data, e); t && Pn.destroyView(t) } detach(e) { const t = mr(this._data, e); return t ? new Tr(t) : null } } function Er(e) { return new Tr(e) } class Tr { constructor(e) { this._view = e, this._viewContainerRef = null, this._appRef = null } get rootNodes() { return function (e) { const t = []; return tr(e, 0, void 0, void 0, t), t }(this._view) } get context() { return this._view.context } get destroyed() { return 0 != (128 & this._view.state) } markForCheck() { Fn(this._view) } detach() { this._view.state &= -5 } detectChanges() { const e = this._view.root.rendererFactory; e.begin && e.begin(); try { Pn.checkAndUpdateView(this._view) } finally { e.end && e.end() } } checkNoChanges() { Pn.checkNoChangesView(this._view) } reattach() { this._view.state |= 4 } onDestroy(e) { this._view.disposables || (this._view.disposables = []), this._view.disposables.push(e) } destroy() { this._appRef ? this._appRef.detachView(this) : this._viewContainerRef && this._viewContainerRef.detach(this._viewContainerRef.indexOf(this)), Pn.destroyView(this._view) } detachFromAppRef() { this._appRef = null, vr(this._view), Pn.dirtyParentQueries(this._view) } attachToAppRef(e) { if (this._viewContainerRef) throw new Error("This view is already attached to a ViewContainer!"); this._appRef = e } attachToViewContainerRef(e) { if (this._appRef) throw new Error("This view is already attached directly to the ApplicationRef!"); this._viewContainerRef = e } } function kr(e, t) { return new Rr(e, t) } class Rr extends vn { constructor(e, t) { super(), this._parentView = e, this._def = t } createEmbeddedView(e) { return new Tr(Pn.createEmbeddedView(this._parentView, this._def, this._def.element.template, e)) } get elementRef() { return new Zt(Rn(this._parentView, this._def.nodeIndex).renderElement) } } function Ar(e, t) { return new Ir(e, t) } class Ir { constructor(e, t) { this.view = e, this.elDef = t } get(e, t = _t.THROW_IF_NOT_FOUND) { return Pn.resolveDep(this.view, this.elDef, !!this.elDef && 0 != (33554432 & this.elDef.flags), { flags: 0, token: e, tokenKey: Un(e) }, t) } } function Nr(e, t) { const n = e.def.nodes[t]; if (1 & n.flags) { const t = Rn(e, n.nodeIndex); return n.element.template ? t.template : t.renderElement } if (2 & n.flags) return kn(e, n.nodeIndex).renderText; if (20240 & n.flags) return An(e, n.nodeIndex).instance; throw new Error(`Illegal state: read nodeValue for node index ${t}`) } function Pr(e) { return new Or(e.renderer) } class Or { constructor(e) { this.delegate = e } selectRootElement(e) { return this.delegate.selectRootElement(e) } createElement(e, t) { const [n, r] = ar(t), s = this.delegate.createElement(r, n); return e && this.delegate.appendChild(e, s), s } createViewRoot(e) { return e } createTemplateAnchor(e) { const t = this.delegate.createComment(""); return e && this.delegate.appendChild(e, t), t } createText(e, t) { const n = this.delegate.createText(t); return e && this.delegate.appendChild(e, n), n } projectNodes(e, t) { for (let n = 0; n < t.length; n++)this.delegate.appendChild(e, t[n]) } attachViewAfter(e, t) { const n = this.delegate.parentNode(e), r = this.delegate.nextSibling(e); for (let s = 0; s < t.length; s++)this.delegate.insertBefore(n, t[s], r) } detachView(e) { for (let t = 0; t < e.length; t++) { const n = e[t], r = this.delegate.parentNode(n); this.delegate.removeChild(r, n) } } destroyView(e, t) { for (let n = 0; n < t.length; n++)this.delegate.destroyNode(t[n]) } listen(e, t, n) { return this.delegate.listen(e, t, n) } listenGlobal(e, t, n) { return this.delegate.listen(e, t, n) } setElementProperty(e, t, n) { this.delegate.setProperty(e, t, n) } setElementAttribute(e, t, n) { const [r, s] = ar(t); null != n ? this.delegate.setAttribute(e, s, n, r) : this.delegate.removeAttribute(e, s, r) } setBindingDebugInfo(e, t, n) { } setElementClass(e, t, n) { n ? this.delegate.addClass(e, t) : this.delegate.removeClass(e, t) } setElementStyle(e, t, n) { null != n ? this.delegate.setStyle(e, t, n) : this.delegate.removeStyle(e, t) } invokeElementMethod(e, t, n) { e[t].apply(e, n) } setText(e, t) { this.delegate.setValue(e, t) } animate() { throw new Error("Renderer.animate is no longer supported!") } } function Dr(e, t, n, r) { return new Ur(e, t, n, r) } class Ur { constructor(e, t, n, r) { this._moduleType = e, this._parent = t, this._bootstrapComponents = n, this._def = r, this._destroyListeners = [], this._destroyed = !1, this.injector = this, function (e) { const t = e._def, n = e._providers = new Array(t.providers.length); for (let r = 0; r < t.providers.length; r++) { const s = t.providers[r]; 4096 & s.flags || void 0 === n[r] && (n[r] = gr(e, s)) } }(this) } get(e, t = _t.THROW_IF_NOT_FOUND, n = oe.Default) { let r = 0; return n & oe.SkipSelf ? r |= 1 : n & oe.Self && (r |= 4), fr(this, { token: e, tokenKey: Un(e), flags: r }, t) } get instance() { return this.get(this._moduleType) } get componentFactoryResolver() { return this.get(zt) } destroy() { if (this._destroyed) throw new Error(`The ng module ${he(this.instance.constructor)} has already been destroyed.`); this._destroyed = !0, function (e, t) { const n = e._def, r = new Set; for (let s = 0; s < n.providers.length; s++)if (131072 & n.providers[s].flags) { const t = e._providers[s]; if (t && t !== ur) { const e = t.ngOnDestroy; "function" != typeof e || r.has(t) || (e.apply(t), r.add(t)) } } }(this), this._destroyListeners.forEach(e => e()) } onDestroy(e) { this._destroyListeners.push(e) } } const Mr = Un(Gt), Lr = Un(Yt), jr = Un(Zt), Vr = Un(_n), Hr = Un(vn), Fr = Un(mt), $r = Un(_t), zr = Un(be); function Br(e, t, n, r, s, i, o, a) { const l = []; if (o) for (let c in o) { const [e, t] = o[c]; l[e] = { flags: 8, name: c, nonMinifiedName: t, ns: null, securityContext: null, suffix: null } } const u = []; if (a) for (let c in a) u.push({ type: 1, propName: c, target: null, eventName: a[c] }); return qr(e, t |= 16384, n, r, s, s, i, l, u) } function qr(e, t, n, r, s, i, o, a, l) { const { matchedQueries: u, references: c, matchedQueryIds: h } = Kn(n); l || (l = []), a || (a = []), i = fe(i); const d = Jn(o, he(s)); return { nodeIndex: -1, parent: null, renderParent: null, bindingIndex: -1, outputIndex: -1, checkIndex: e, flags: t, childFlags: 0, directChildFlags: 0, childMatchedQueries: 0, matchedQueries: u, matchedQueryIds: h, references: c, ngContentIndex: -1, childCount: r, bindings: a, bindingFlags: lr(a), outputs: l, element: null, provider: { token: s, value: i, deps: d }, text: null, query: null, ngContent: null } } function Wr(e, t) { return Kr(e, t) } function Zr(e, t) { let n = e; for (; n.parent && !Zn(n);)n = n.parent; return Jr(n.parent, qn(n), !0, t.provider.value, t.provider.deps) } function Qr(e, t) { const n = Jr(e, t.parent, (32768 & t.flags) > 0, t.provider.value, t.provider.deps); if (t.outputs.length) for (let r = 0; r < t.outputs.length; r++) { const s = t.outputs[r], i = n[s.propName]; if (!Lt(i)) throw new Error(`@Output ${s.propName} not initialized in '${n.constructor.name}'.`); { const n = i.subscribe(Gr(e, t.parent.nodeIndex, s.eventName)); e.disposables[t.outputIndex + r] = n.unsubscribe.bind(n) } } return n } function Gr(e, t, n) { return r => zn(e, t, n, r) } function Kr(e, t) { const n = (8192 & t.flags) > 0, r = t.provider; switch (201347067 & t.flags) { case 512: return Jr(e, t.parent, n, r.value, r.deps); case 1024: return function (e, t, n, r, s) { const i = s.length; switch (i) { case 0: return r(); case 1: return r(Xr(e, t, n, s[0])); case 2: return r(Xr(e, t, n, s[0]), Xr(e, t, n, s[1])); case 3: return r(Xr(e, t, n, s[0]), Xr(e, t, n, s[1]), Xr(e, t, n, s[2])); default: const o = Array(i); for (let r = 0; r < i; r++)o[r] = Xr(e, t, n, s[r]); return r(...o) } }(e, t.parent, n, r.value, r.deps); case 2048: return Xr(e, t.parent, n, r.deps[0]); case 256: return r.value } } function Jr(e, t, n, r, s) { const i = s.length; switch (i) { case 0: return new r; case 1: return new r(Xr(e, t, n, s[0])); case 2: return new r(Xr(e, t, n, s[0]), Xr(e, t, n, s[1])); case 3: return new r(Xr(e, t, n, s[0]), Xr(e, t, n, s[1]), Xr(e, t, n, s[2])); default: const o = new Array(i); for (let r = 0; r < i; r++)o[r] = Xr(e, t, n, s[r]); return new r(...o) } } const Yr = {}; function Xr(e, t, n, r, s = _t.THROW_IF_NOT_FOUND) { if (8 & r.flags) return r.token; const i = e; 2 & r.flags && (s = null); const o = r.tokenKey; o === Fr && (n = !(!t || !t.element.componentView)), t && 1 & r.flags && (n = !1, t = t.parent); let a = e; for (; a;) { if (t) switch (o) { case Mr: return Pr(es(a, t, n)); case Lr: return es(a, t, n).renderer; case jr: return new Zt(Rn(a, t.nodeIndex).renderElement); case Vr: return Rn(a, t.nodeIndex).viewContainer; case Hr: if (t.element.template) return Rn(a, t.nodeIndex).template; break; case Fr: return Er(es(a, t, n)); case $r: case zr: return Ar(a, t); default: const e = (n ? t.element.allProviders : t.element.publicProviders)[o]; if (e) { let t = An(a, e.nodeIndex); return t || (t = { instance: Kr(a, e) }, a.nodes[e.nodeIndex] = t), t.instance } }n = Zn(a), t = qn(a), a = a.parent, 4 & r.flags && (a = null) } const l = i.root.injector.get(r.token, Yr); return l !== Yr || s === Yr ? l : i.root.ngModule.injector.get(r.token, s) } function es(e, t, n) { let r; if (n) r = Rn(e, t.nodeIndex).componentView; else for (r = e; r.parent && !Zn(r);)r = r.parent; return r } function ts(e, t, n, r, s, i) { if (32768 & n.flags) { const t = Rn(e, n.parent.nodeIndex).componentView; 2 & t.def.flags && (t.state |= 8) } if (t.instance[n.bindings[r].name] = s, 524288 & n.flags) { i = i || {}; const t = Ot.unwrap(e.oldValues[n.bindingIndex + r]); i[n.bindings[r].nonMinifiedName] = new jt(t, s, 0 != (2 & e.state)) } return e.oldValues[n.bindingIndex + r] = s, i } function ns(e, t) { if (!(e.def.nodeFlags & t)) return; const n = e.def.nodes; let r = 0; for (let s = 0; s < n.length; s++) { const i = n[s]; let o = i.parent; for (!o && i.flags & t && ss(e, s, i.flags & t, r++), 0 == (i.childFlags & t) && (s += i.childCount); o && 1 & o.flags && s === o.nodeIndex + o.childCount;)o.directChildFlags & t && (r = rs(e, o, t, r)), o = o.parent } } function rs(e, t, n, r) { for (let s = t.nodeIndex + 1; s <= t.nodeIndex + t.childCount; s++) { const t = e.def.nodes[s]; t.flags & n && ss(e, s, t.flags & n, r++), s += t.childCount } return r } function ss(e, t, n, r) { const s = An(e, t); if (!s) return; const i = s.instance; i && (Pn.setCurrentNode(e, t), 1048576 & n && Tn(e, 512, r) && i.ngAfterContentInit(), 2097152 & n && i.ngAfterContentChecked(), 4194304 & n && Tn(e, 768, r) && i.ngAfterViewInit(), 8388608 & n && i.ngAfterViewChecked(), 131072 & n && i.ngOnDestroy()) } const is = new _e("SCHEDULER_TOKEN", { providedIn: "root", factory: () => Ue }), os = {}, as = function () { var e = { LocaleId: 0, DayPeriodsFormat: 1, DayPeriodsStandalone: 2, DaysFormat: 3, DaysStandalone: 4, MonthsFormat: 5, MonthsStandalone: 6, Eras: 7, FirstDayOfWeek: 8, WeekendRange: 9, DateFormat: 10, TimeFormat: 11, DateTimeFormat: 12, NumberSymbols: 13, NumberFormats: 14, CurrencySymbol: 15, CurrencyName: 16, Currencies: 17, PluralCase: 18, ExtraData: 19 }; return e[e.LocaleId] = "LocaleId", e[e.DayPeriodsFormat] = "DayPeriodsFormat", e[e.DayPeriodsStandalone] = "DayPeriodsStandalone", e[e.DaysFormat] = "DaysFormat", e[e.DaysStandalone] = "DaysStandalone", e[e.MonthsFormat] = "MonthsFormat", e[e.MonthsStandalone] = "MonthsStandalone", e[e.Eras] = "Eras", e[e.FirstDayOfWeek] = "FirstDayOfWeek", e[e.WeekendRange] = "WeekendRange", e[e.DateFormat] = "DateFormat", e[e.TimeFormat] = "TimeFormat", e[e.DateTimeFormat] = "DateTimeFormat", e[e.NumberSymbols] = "NumberSymbols", e[e.NumberFormats] = "NumberFormats", e[e.CurrencySymbol] = "CurrencySymbol", e[e.CurrencyName] = "CurrencyName", e[e.Currencies] = "Currencies", e[e.PluralCase] = "PluralCase", e[e.ExtraData] = "ExtraData", e }(), ls = void 0; var us = ["en", [["a", "p"], ["AM", "PM"], ls], [["AM", "PM"], ls, ls], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], ls, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], ls, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", ls, "{1} 'at' {0}", ls], [".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":"], ["#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0"], "$", "US Dollar", {}, function (e) { let t = Math.floor(Math.abs(e)), n = e.toString().replace(/^[^.]*\.?/, "").length; return 1 === t && 0 === n ? 1 : 5 }]; class cs extends E { constructor(e = !1) { super(), this.__isAsync = e } emit(e) { super.next(e) } subscribe(e, t, n) { let r, s = e => null, i = () => null; e && "object" == typeof e ? (r = this.__isAsync ? t => { setTimeout(() => e.next(t)) } : t => { e.next(t) }, e.error && (s = this.__isAsync ? t => { setTimeout(() => e.error(t)) } : t => { e.error(t) }), e.complete && (i = this.__isAsync ? () => { setTimeout(() => e.complete()) } : () => { e.complete() })) : (r = this.__isAsync ? t => { setTimeout(() => e(t)) } : t => { e(t) }, t && (s = this.__isAsync ? e => { setTimeout(() => t(e)) } : e => { t(e) }), n && (i = this.__isAsync ? () => { setTimeout(() => n()) } : () => { n() })); const o = super.subscribe(r, s, i); return e instanceof h && e.add(o), o } } function hs() { return this._results[It()]() } class ds { constructor() { this.dirty = !0, this._results = [], this.changes = new cs, this.length = 0; const e = It(), t = ds.prototype; t[e] || (t[e] = hs) } map(e) { return this._results.map(e) } filter(e) { return this._results.filter(e) } find(e) { return this._results.find(e) } reduce(e, t) { return this._results.reduce(e, t) } forEach(e) { this._results.forEach(e) } some(e) { return this._results.some(e) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(e) { this._results = function e(t, n) { void 0 === n && (n = t); for (let r = 0; r < t.length; r++) { let s = t[r]; Array.isArray(s) ? (n === t && (n = t.slice(0, r)), e(s, n)) : n !== t && n.push(s) } return n }(e), this.dirty = !1, this.length = this._results.length, this.last = this._results[this.length - 1], this.first = this._results[0] } notifyOnChanges() { this.changes.emit(this) } setDirty() { this.dirty = !0 } destroy() { this.changes.complete(), this.changes.unsubscribe() } } const ps = new _e("Application Initializer"); class fs { constructor(e) { this.appInits = e, this.initialized = !1, this.done = !1, this.donePromise = new Promise((e, t) => { this.resolve = e, this.reject = t }) } runInitializers() { if (this.initialized) return; const e = [], t = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let n = 0; n < this.appInits.length; n++) { const t = this.appInits[n](); Mt(t) && e.push(t) } Promise.all(e).then(() => { t() }).catch(e => { this.reject(e) }), 0 === e.length && t(), this.initialized = !0 } } const gs = new _e("AppId"), ms = new _e("Platform Initializer"), ys = new _e("Platform ID"), vs = new _e("appBootstrapListener"); class ws { log(e) { console.log(e) } warn(e) { console.warn(e) } } const _s = new _e("LocaleId"); function bs() { throw new Error("Runtime compiler is not loaded") } const Cs = bs, xs = bs, Ss = bs, Es = bs; class Ts { constructor() { this.compileModuleSync = Cs, this.compileModuleAsync = xs, this.compileModuleAndAllComponentsSync = Ss, this.compileModuleAndAllComponentsAsync = Es } clearCache() { } clearCacheFor(e) { } getModuleId(e) { } } class ks { } let Rs, As; function Is() { const e = we.wtf; return !(!e || (Rs = e.trace, !Rs) || (As = Rs.events, 0)) } const Ns = Is(); function Ps(e, t) { return null } const Os = Ns ? function (e, t = null) { return As.createScope(e, t) } : (e, t) => Ps, Ds = Ns ? function (e, t) { return Rs.leaveScope(e, t), t } : (e, t) => t, Us = (() => Promise.resolve(0))(); function Ms(e) { "undefined" == typeof Zone ? Us.then(() => { e && e.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", e) } class Ls { constructor({ enableLongStackTrace: e = !1 }) { if (this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new cs(!1), this.onMicrotaskEmpty = new cs(!1), this.onStable = new cs(!1), this.onError = new cs(!1), "undefined" == typeof Zone) throw new Error("In this configuration Angular requires Zone.js"); var t; Zone.assertZonePatched(), this._nesting = 0, this._outer = this._inner = Zone.current, Zone.wtfZoneSpec && (this._inner = this._inner.fork(Zone.wtfZoneSpec)), Zone.TaskTrackingZoneSpec && (this._inner = this._inner.fork(new Zone.TaskTrackingZoneSpec)), e && Zone.longStackTraceZoneSpec && (this._inner = this._inner.fork(Zone.longStackTraceZoneSpec)), (t = this)._inner = t._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (e, n, r, s, i, o) => { try { return Fs(t), e.invokeTask(r, s, i, o) } finally { $s(t) } }, onInvoke: (e, n, r, s, i, o, a) => { try { return Fs(t), e.invoke(r, s, i, o, a) } finally { $s(t) } }, onHasTask: (e, n, r, s) => { e.hasTask(r, s), n === r && ("microTask" == s.change ? (t.hasPendingMicrotasks = s.microTask, Hs(t)) : "macroTask" == s.change && (t.hasPendingMacrotasks = s.macroTask)) }, onHandleError: (e, n, r, s) => (e.handleError(r, s), t.runOutsideAngular(() => t.onError.emit(s)), !1) }) } static isInAngularZone() { return !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!Ls.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!") } static assertNotInAngularZone() { if (Ls.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!") } run(e, t, n) { return this._inner.run(e, t, n) } runTask(e, t, n, r) { const s = this._inner, i = s.scheduleEventTask("NgZoneEvent: " + r, e, Vs, js, js); try { return s.runTask(i, t, n) } finally { s.cancelTask(i) } } runGuarded(e, t, n) { return this._inner.runGuarded(e, t, n) } runOutsideAngular(e) { return this._outer.run(e) } } function js() { } const Vs = {}; function Hs(e) { if (0 == e._nesting && !e.hasPendingMicrotasks && !e.isStable) try { e._nesting++, e.onMicrotaskEmpty.emit(null) } finally { if (e._nesting--, !e.hasPendingMicrotasks) try { e.runOutsideAngular(() => e.onStable.emit(null)) } finally { e.isStable = !0 } } } function Fs(e) { e._nesting++, e.isStable && (e.isStable = !1, e.onUnstable.emit(null)) } function $s(e) { e._nesting--, Hs(e) } class zs { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new cs, this.onMicrotaskEmpty = new cs, this.onStable = new cs, this.onError = new cs } run(e) { return e() } runGuarded(e) { return e() } runOutsideAngular(e) { return e() } runTask(e) { return e() } } class Bs { constructor(e) { this._ngZone = e, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, this._watchAngularEvents(), e.run(() => { this.taskTrackingZone = "undefined" == typeof Zone ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { Ls.assertNotInAngularZone(), Ms(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) Ms(() => { for (; 0 !== this._callbacks.length;) { let e = this._callbacks.pop(); clearTimeout(e.timeoutId), e.doneCb(this._didWork) } this._didWork = !1 }); else { let e = this.getPendingTasks(); this._callbacks = this._callbacks.filter(t => !t.updateCb || !t.updateCb(e) || (clearTimeout(t.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(e => ({ source: e.source, creationLocation: e.creationLocation, data: e.data })) : [] } addCallback(e, t, n) { let r = -1; t && t > 0 && (r = setTimeout(() => { this._callbacks = this._callbacks.filter(e => e.timeoutId !== r), e(this._didWork, this.getPendingTasks()) }, t)), this._callbacks.push({ doneCb: e, timeoutId: r, updateCb: n }) } whenStable(e, t, n) { if (n && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/dist/task-tracking.js" loaded?'); this.addCallback(e, t, n), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } findProviders(e, t, n) { return [] } } class qs { constructor() { this._applications = new Map, Qs.addToWindow(this) } registerApplication(e, t) { this._applications.set(e, t) } unregisterApplication(e) { this._applications.delete(e) } unregisterAllApplications() { this._applications.clear() } getTestability(e) { return this._applications.get(e) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(e, t = !0) { return Qs.findTestabilityInTree(this, e, t) } } class Ws { addToWindow(e) { } findTestabilityInTree(e, t, n) { return null } } let Zs, Qs = new Ws; const Gs = new _e("AllowMultipleToken"); class Ks { constructor(e, t) { this.name = e, this.token = t } } function Js(e, t, n = []) { const r = `Platform: ${t}`, s = new _e(r); return (t = []) => { let i = Ys(); if (!i || i.injector.get(Gs, !1)) if (e) e(n.concat(t).concat({ provide: s, useValue: !0 })); else { const e = n.concat(t).concat({ provide: s, useValue: !0 }); !function (e) { if (Zs && !Zs.destroyed && !Zs.injector.get(Gs, !1)) throw new Error("There can be only one platform. Destroy the previous one to create a new one."); Zs = e.get(Xs); const t = e.get(ms, null); t && t.forEach(e => e()) }(_t.create({ providers: e, name: r })) } return function (e) { const t = Ys(); if (!t) throw new Error("No platform exists!"); if (!t.injector.get(e, null)) throw new Error("A platform with a different configuration has been created. Please destroy it first."); return t }(s) } } function Ys() { return Zs && !Zs.destroyed ? Zs : null } class Xs { constructor(e) { this._injector = e, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(e, t) { const n = function (e) { let t; return t = "noop" === e ? new zs : ("zone.js" === e ? void 0 : e) || new Ls({ enableLongStackTrace: $e() }), t }(t ? t.ngZone : void 0), r = [{ provide: Ls, useValue: n }]; return n.run(() => { const t = _t.create({ providers: r, parent: this.injector, name: e.moduleType.name }), s = e.create(t), i = s.injector.get(Ve, null); if (!i) throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?"); return s.onDestroy(() => ni(this._modules, s)), n.runOutsideAngular(() => n.onError.subscribe({ next: e => { i.handleError(e) } })), function (e, t, n) { try { const r = n(); return Mt(r) ? r.catch(n => { throw t.runOutsideAngular(() => e.handleError(n)), n }) : r } catch (r) { throw t.runOutsideAngular(() => e.handleError(r)), r } }(i, n, () => { const e = s.injector.get(fs); return e.runInitializers(), e.donePromise.then(() => (this._moduleDoBootstrap(s), s)) }) }) } bootstrapModule(e, t = []) { const n = ei({}, t); return function (e, t, n) { return e.get(ks).createCompiler([t]).compileModuleAsync(n) }(this.injector, n, e).then(e => this.bootstrapModuleFactory(e, n)) } _moduleDoBootstrap(e) { const t = e.injector.get(ti); if (e._bootstrapComponents.length > 0) e._bootstrapComponents.forEach(e => t.bootstrap(e)); else { if (!e.instance.ngDoBootstrap) throw new Error(`The module ${he(e.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. ` + "Please define one of these."); e.instance.ngDoBootstrap(t) } this._modules.push(e) } onDestroy(e) { this._destroyListeners.push(e) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new Error("The platform has already been destroyed!"); this._modules.slice().forEach(e => e.destroy()), this._destroyListeners.forEach(e => e()), this._destroyed = !0 } get destroyed() { return this._destroyed } } function ei(e, t) { return Array.isArray(t) ? t.reduce(ei, e) : Object.assign({}, e, t) } let ti = (() => { class e { constructor(e, t, n, r, s, i) { this._zone = e, this._console = t, this._injector = n, this._exceptionHandler = r, this._componentFactoryResolver = s, this._initStatus = i, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._enforceNoNewChanges = !1, this._stable = !0, this.componentTypes = [], this.components = [], this._enforceNoNewChanges = $e(), this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const o = new _(e => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { e.next(this._stable), e.complete() }) }), a = new _(e => { let t; this._zone.runOutsideAngular(() => { t = this._zone.onStable.subscribe(() => { Ls.assertNotInAngularZone(), Ms(() => { this._stable || this._zone.hasPendingMacrotasks || this._zone.hasPendingMicrotasks || (this._stable = !0, e.next(!0)) }) }) }); const n = this._zone.onUnstable.subscribe(() => { Ls.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { e.next(!1) })) }); return () => { t.unsubscribe(), n.unsubscribe() } }); this.isStable = function (...e) { let t = Number.POSITIVE_INFINITY, n = null, r = e[e.length - 1]; return k(r) ? (n = e.pop(), e.length > 1 && "number" == typeof e[e.length - 1] && (t = e.pop())) : "number" == typeof r && (t = e.pop()), null === n && 1 === e.length && e[0] instanceof _ ? e[0] : W(t)(Z(e, n)) }(o, a.pipe(e => { return Q()((t = ee, function (e) { let n; n = "function" == typeof t ? t : function () { return t }; const r = Object.create(e, Y); return r.source = e, r.subjectFactory = n, r })(e)); var t })) } bootstrap(e, t) { if (!this._initStatus.done) throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module."); let n; n = e instanceof Vt ? e : this._componentFactoryResolver.resolveComponentFactory(e), this.componentTypes.push(n.componentType); const r = n instanceof qt ? null : this._injector.get(Ie), s = n.create(_t.NULL, [], t || n.selector, r); s.onDestroy(() => { this._unloadComponent(s) }); const i = s.injector.get(Bs, null); return i && s.injector.get(qs).registerApplication(s.location.nativeElement, i), this._loadComponent(s), $e() && this._console.log("Angular is running in the development mode. Call enableProdMode() to enable the production mode."), s } tick() { if (this._runningTick) throw new Error("ApplicationRef.tick is called recursively"); const t = e._tickScope(); try { this._runningTick = !0; for (let e of this._views) e.detectChanges(); if (this._enforceNoNewChanges) for (let e of this._views) e.checkNoChanges() } catch (n) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(n)) } finally { this._runningTick = !1, Ds(t) } } attachView(e) { const t = e; this._views.push(t), t.attachToAppRef(this) } detachView(e) { const t = e; ni(this._views, t), t.detachFromAppRef() } _loadComponent(e) { this.attachView(e.hostView), this.tick(), this.components.push(e), this._injector.get(vs, []).concat(this._bootstrapListeners).forEach(t => t(e)) } _unloadComponent(e) { this.detachView(e.hostView), ni(this.components, e) } ngOnDestroy() { this._views.slice().forEach(e => e.destroy()) } get viewCount() { return this._views.length } } return e._tickScope = Os("ApplicationRef#tick()"), e })(); function ni(e, t) { const n = e.indexOf(t); n > -1 && e.splice(n, 1) } class ri { } class si { } const ii = { factoryPathPrefix: "", factoryPathSuffix: ".ngfactory" }; class oi { constructor(e, t) { this._compiler = e, this._config = t || ii } load(e) { return this._compiler instanceof Ts ? this.loadFactory(e) : this.loadAndCompile(e) } loadAndCompile(e) { let [t, r] = e.split("#"); return void 0 === r && (r = "default"), n("crnd")(t).then(e => e[r]).then(e => ai(e, t, r)).then(e => this._compiler.compileModuleAsync(e)) } loadFactory(e) { let [t, r] = e.split("#"), s = "NgFactory"; return void 0 === r && (r = "default", s = ""), n("crnd")(this._config.factoryPathPrefix + t + this._config.factoryPathSuffix).then(e => e[r + s]).then(e => ai(e, t, r)) } } function ai(e, t, n) { if (!e) throw new Error(`Cannot find '${n}' in '${t}'`); return e } class li { constructor(e, t) { this.name = e, this.callback = t } } class ui { constructor(e, t, n) { this.listeners = [], this.parent = null, this._debugContext = n, this.nativeNode = e, t && t instanceof ci && t.addChild(this) } get injector() { return this._debugContext.injector } get componentInstance() { return this._debugContext.component } get context() { return this._debugContext.context } get references() { return this._debugContext.references } get providerTokens() { return this._debugContext.providerTokens } } class ci extends ui { constructor(e, t, n) { super(e, t, n), this.properties = {}, this.attributes = {}, this.classes = {}, this.styles = {}, this.childNodes = [], this.nativeElement = e } addChild(e) { e && (this.childNodes.push(e), e.parent = this) } removeChild(e) { const t = this.childNodes.indexOf(e); -1 !== t && (e.parent = null, this.childNodes.splice(t, 1)) } insertChildrenAfter(e, t) { const n = this.childNodes.indexOf(e); -1 !== n && (this.childNodes.splice(n + 1, 0, ...t), t.forEach(t => { t.parent && t.parent.removeChild(t), e.parent = this })) } insertBefore(e, t) { const n = this.childNodes.indexOf(e); -1 === n ? this.addChild(t) : (t.parent && t.parent.removeChild(t), t.parent = this, this.childNodes.splice(n, 0, t)) } query(e) { return this.queryAll(e)[0] || null } queryAll(e) { const t = []; return function e(t, n, r) { t.childNodes.forEach(t => { t instanceof ci && (n(t) && r.push(t), e(t, n, r)) }) }(this, e, t), t } queryAllNodes(e) { const t = []; return function e(t, n, r) { t instanceof ci && t.childNodes.forEach(t => { n(t) && r.push(t), t instanceof ci && e(t, n, r) }) }(this, e, t), t } get children() { return this.childNodes.filter(e => e instanceof ci) } triggerEventHandler(e, t) { this.listeners.forEach(n => { n.name == e && n.callback(t) }) } } const hi = new Map, di = function (e) { return hi.get(e) || null }; function pi(e) { hi.set(e.nativeNode, e) } const fi = Js(null, "core", [{ provide: ys, useValue: "unknown" }, { provide: Xs, deps: [_t] }, { provide: qs, deps: [] }, { provide: ws, deps: [] }]); function gi() { return mn } function mi() { return yn } function yi(e) { return e || "en-US" } function vi(e) { let t = []; return e.onStable.subscribe(() => { for (; t.length;)t.pop()() }), function (e) { t.push(e) } } class wi { constructor(e) { } } function _i(e, t, n, r, s, i) { e |= 1; const { matchedQueries: o, references: a, matchedQueryIds: l } = Kn(t); return { nodeIndex: -1, parent: null, renderParent: null, bindingIndex: -1, outputIndex: -1, flags: e, checkIndex: -1, childFlags: 0, directChildFlags: 0, childMatchedQueries: 0, matchedQueries: o, matchedQueryIds: l, references: a, ngContentIndex: n, childCount: r, bindings: [], bindingFlags: 0, outputs: [], element: { ns: null, name: null, attrs: null, template: i ? er(i) : null, componentProvider: null, componentView: null, componentRendererType: null, publicProviders: null, allProviders: null, handleEvent: s || On }, provider: null, text: null, query: null, ngContent: null } } function bi(e, t, n, r, s, i, o = [], a, l, u, c, h) { u || (u = On); const { matchedQueries: d, references: p, matchedQueryIds: f } = Kn(n); let g = null, m = null; i && ([g, m] = ar(i)), a = a || []; const y = new Array(a.length); for (let _ = 0; _ < a.length; _++) { const [e, t, n] = a[_], [r, s] = ar(t); let i = void 0, o = void 0; switch (15 & e) { case 4: o = n; break; case 1: case 8: i = n }y[_] = { flags: e, ns: r, name: s, nonMinifiedName: s, securityContext: i, suffix: o } } l = l || []; const v = new Array(l.length); for (let _ = 0; _ < l.length; _++) { const [e, t] = l[_]; v[_] = { type: 0, target: e, eventName: t, propName: null } } const w = (o = o || []).map(([e, t]) => { const [n, r] = ar(e); return [n, r, t] }); return h = function (e) { if (e && "$$undefined" === e.id) { const t = null != e.encapsulation && e.encapsulation !== De.None || e.styles.length || Object.keys(e.data).length; e.id = t ? `c${Ln++}` : "$$empty" } return e && "$$empty" === e.id && (e = null), e || null }(h), c && (t |= 33554432), { nodeIndex: -1, parent: null, renderParent: null, bindingIndex: -1, outputIndex: -1, checkIndex: e, flags: t |= 1, childFlags: 0, directChildFlags: 0, childMatchedQueries: 0, matchedQueries: d, matchedQueryIds: f, references: p, ngContentIndex: r, childCount: s, bindings: y, bindingFlags: lr(y), outputs: v, element: { ns: g, name: m, attrs: w, template: null, componentProvider: null, componentView: c || null, componentRendererType: h, publicProviders: null, allProviders: null, handleEvent: u || On }, provider: null, text: null, query: null, ngContent: null } } function Ci(e, t, n) { const r = n.element, s = e.root.selectorOrNode, i = e.renderer; let o; if (e.parent || !s) { o = r.name ? i.createElement(r.name, r.ns) : i.createComment(""); const s = Yn(e, t, n); s && i.appendChild(s, o) } else o = i.selectRootElement(s, !!r.componentRendererType && r.componentRendererType.encapsulation === De.ShadowDom); if (r.attrs) for (let a = 0; a < r.attrs.length; a++) { const [e, t, n] = r.attrs[a]; i.setAttribute(o, t, n, e) } return o } function xi(e, t, n, r) { for (let o = 0; o < n.outputs.length; o++) { const a = n.outputs[o], l = Si(e, n.nodeIndex, (i = a.eventName, (s = a.target) ? `${s}:${i}` : i)); let u = a.target, c = e; "component" === a.target && (u = null, c = t); const h = c.renderer.listen(u || r, a.eventName, l); e.disposables[n.outputIndex + o] = h } var s, i } function Si(e, t, n) { return r => zn(e, t, n, r) } function Ei(e, t, n, r) { if (!Vn(e, t, n, r)) return !1; const s = t.bindings[n], i = Rn(e, t.nodeIndex), o = i.renderElement, a = s.name; switch (15 & s.flags) { case 1: !function (e, t, n, r, s, i) { const o = t.securityContext; let a = o ? e.root.sanitizer.sanitize(o, i) : i; a = null != a ? a.toString() : null; const l = e.renderer; null != i ? l.setAttribute(n, s, a, r) : l.removeAttribute(n, s, r) }(e, s, o, s.ns, a, r); break; case 2: !function (e, t, n, r) { const s = e.renderer; r ? s.addClass(t, n) : s.removeClass(t, n) }(e, o, a, r); break; case 4: !function (e, t, n, r, s) { let i = e.root.sanitizer.sanitize(ct.STYLE, s); if (null != i) { i = i.toString(); const e = t.suffix; null != e && (i += e) } else i = null; const o = e.renderer; null != i ? o.setStyle(n, r, i) : o.removeStyle(n, r) }(e, s, o, a, r); break; case 8: !function (e, t, n, r, s) { const i = t.securityContext; let o = i ? e.root.sanitizer.sanitize(i, s) : s; e.renderer.setProperty(n, r, o) }(33554432 & t.flags && 32 & s.flags ? i.componentView : e, s, o, a, r) }return !0 } function Ti(e, t, n) { let r = []; for (let s in n) r.push({ propName: s, bindingType: n[s] }); return { nodeIndex: -1, parent: null, renderParent: null, bindingIndex: -1, outputIndex: -1, checkIndex: -1, flags: e, childFlags: 0, directChildFlags: 0, childMatchedQueries: 0, ngContentIndex: -1, matchedQueries: {}, matchedQueryIds: 0, references: {}, childCount: 0, bindings: [], bindingFlags: 0, outputs: [], element: null, provider: null, text: null, query: { id: t, filterId: Gn(t), bindings: r }, ngContent: null } } function ki(e) { const t = e.def.nodeMatchedQueries; for (; e.parent && Qn(e);) { let n = e.parentNodeDef; e = e.parent; const r = n.nodeIndex + n.childCount; for (let s = 0; s <= r; s++) { const r = e.def.nodes[s]; 67108864 & r.flags && 536870912 & r.flags && (r.query.filterId & t) === r.query.filterId && Nn(e, s).setDirty(), !(1 & r.flags && s + r.childCount < n.nodeIndex) && 67108864 & r.childFlags && 536870912 & r.childFlags || (s += r.childCount) } } if (134217728 & e.def.nodeFlags) for (let n = 0; n < e.def.nodes.length; n++) { const t = e.def.nodes[n]; 134217728 & t.flags && 536870912 & t.flags && Nn(e, n).setDirty(), n += t.childCount } } function Ri(e, t) { const n = Nn(e, t.nodeIndex); if (!n.dirty) return; let r, s = void 0; if (67108864 & t.flags) { const n = t.parent.parent; s = Ai(e, n.nodeIndex, n.nodeIndex + n.childCount, t.query, []), r = An(e, t.parent.nodeIndex).instance } else 134217728 & t.flags && (s = Ai(e, 0, e.def.nodes.length - 1, t.query, []), r = e.component); n.reset(s); const i = t.query.bindings; let o = !1; for (let a = 0; a < i.length; a++) { const e = i[a]; let t; switch (e.bindingType) { case 0: t = n.first; break; case 1: t = n, o = !0 }r[e.propName] = t } o && n.notifyOnChanges() } function Ai(e, t, n, r, s) { for (let i = t; i <= n; i++) { const t = e.def.nodes[i], n = t.matchedQueries[r.id]; if (null != n && s.push(Ii(e, t, n)), 1 & t.flags && t.element.template && (t.element.template.nodeMatchedQueries & r.filterId) === r.filterId) { const n = Rn(e, i); if ((t.childMatchedQueries & r.filterId) === r.filterId && (Ai(e, i + 1, i + t.childCount, r, s), i += t.childCount), 16777216 & t.flags) { const e = n.viewContainer._embeddedViews; for (let t = 0; t < e.length; t++) { const i = e[t], o = Bn(i); o && o === n && Ai(i, 0, i.def.nodes.length - 1, r, s) } } const o = n.template._projectedViews; if (o) for (let e = 0; e < o.length; e++) { const t = o[e]; Ai(t, 0, t.def.nodes.length - 1, r, s) } } (t.childMatchedQueries & r.filterId) !== r.filterId && (i += t.childCount) } return s } function Ii(e, t, n) { if (null != n) switch (n) { case 1: return Rn(e, t.nodeIndex).renderElement; case 0: return new Zt(Rn(e, t.nodeIndex).renderElement); case 2: return Rn(e, t.nodeIndex).template; case 3: return Rn(e, t.nodeIndex).viewContainer; case 4: return An(e, t.nodeIndex).instance } } function Ni(e, t, n) { const r = Yn(e, t, n); r && rr(e, n.ngContent.index, 1, r, null, void 0) } function Pi(e, t) { return Di(32, e, new Array(t)) } function Oi(e, t) { const n = Object.keys(t), r = n.length, s = new Array(r); for (let i = 0; i < r; i++) { const e = n[i]; s[t[e]] = e } return Di(64, e, s) } function Di(e, t, n) { const r = new Array(n.length); for (let s = 0; s < n.length; s++) { const e = n[s]; r[s] = { flags: 8, name: e, ns: null, nonMinifiedName: e, securityContext: null, suffix: null } } return { nodeIndex: -1, parent: null, renderParent: null, bindingIndex: -1, outputIndex: -1, checkIndex: t, flags: e, childFlags: 0, directChildFlags: 0, childMatchedQueries: 0, matchedQueries: {}, matchedQueryIds: 0, references: {}, ngContentIndex: -1, childCount: 0, bindings: r, bindingFlags: lr(r), outputs: [], element: null, provider: null, text: null, query: null, ngContent: null } } function Ui(e, t, n) { const r = new Array(n.length - 1); for (let s = 1; s < n.length; s++)r[s - 1] = { flags: 8, name: null, ns: null, nonMinifiedName: null, securityContext: null, suffix: n[s] }; return { nodeIndex: -1, parent: null, renderParent: null, bindingIndex: -1, outputIndex: -1, checkIndex: e, flags: 2, childFlags: 0, directChildFlags: 0, childMatchedQueries: 0, matchedQueries: {}, matchedQueryIds: 0, references: {}, ngContentIndex: t, childCount: 0, bindings: r, bindingFlags: 8, outputs: [], element: null, provider: null, text: { prefix: n[0] }, query: null, ngContent: null } } function Mi(e, t, n) { let r; const s = e.renderer; r = s.createText(n.text.prefix); const i = Yn(e, t, n); return i && s.appendChild(i, r), { renderText: r } } function Li(e, t) { return (null != e ? e.toString() : "") + t.suffix } function ji(e, t, n, r) { let s = 0, i = 0, o = 0, a = 0, l = 0, u = null, c = null, h = !1, d = !1, p = null; for (let f = 0; f < t.length; f++) { const e = t[f]; if (e.nodeIndex = f, e.parent = u, e.bindingIndex = s, e.outputIndex = i, e.renderParent = c, o |= e.flags, l |= e.matchedQueryIds, e.element) { const t = e.element; t.publicProviders = u ? u.element.publicProviders : Object.create(null), t.allProviders = t.publicProviders, h = !1, d = !1, e.element.template && (l |= e.element.template.nodeMatchedQueries) } if (Hi(u, e, t.length), s += e.bindings.length, i += e.outputs.length, !c && 3 & e.flags && (p = e), 20224 & e.flags) { h || (h = !0, u.element.publicProviders = Object.create(u.element.publicProviders), u.element.allProviders = u.element.publicProviders); const t = 0 != (32768 & e.flags); 0 == (8192 & e.flags) || t ? u.element.publicProviders[Un(e.provider.token)] = e : (d || (d = !0, u.element.allProviders = Object.create(u.element.publicProviders)), u.element.allProviders[Un(e.provider.token)] = e), t && (u.element.componentProvider = e) } if (u ? (u.childFlags |= e.flags, u.directChildFlags |= e.flags, u.childMatchedQueries |= e.matchedQueryIds, e.element && e.element.template && (u.childMatchedQueries |= e.element.template.nodeMatchedQueries)) : a |= e.flags, e.childCount > 0) u = e, Vi(e) || (c = e); else for (; u && f === u.nodeIndex + u.childCount;) { const e = u.parent; e && (e.childFlags |= u.childFlags, e.childMatchedQueries |= u.childMatchedQueries), u = e, c = u && Vi(u) ? u.renderParent : u } } return { factory: null, nodeFlags: o, rootNodeFlags: a, nodeMatchedQueries: l, flags: e, nodes: t, updateDirectives: n || On, updateRenderer: r || On, handleEvent: (e, n, r, s) => t[n].element.handleEvent(e, r, s), bindingCount: s, outputCount: i, lastRenderRootNode: p } } function Vi(e) { return 0 != (1 & e.flags) && null === e.element.name } function Hi(e, t, n) { const r = t.element && t.element.template; if (r) { if (!r.lastRenderRootNode) throw new Error("Illegal State: Embedded templates without nodes are not allowed!"); if (r.lastRenderRootNode && 16777216 & r.lastRenderRootNode.flags) throw new Error(`Illegal State: Last root node of a template can't have embedded views, at index ${t.nodeIndex}!`) } if (20224 & t.flags && 0 == (1 & (e ? e.flags : 0))) throw new Error(`Illegal State: StaticProvider/Directive nodes need to be children of elements or anchors, at index ${t.nodeIndex}!`); if (t.query) { if (67108864 & t.flags && (!e || 0 == (16384 & e.flags))) throw new Error(`Illegal State: Content Query nodes need to be children of directives, at index ${t.nodeIndex}!`); if (134217728 & t.flags && e) throw new Error(`Illegal State: View Query nodes have to be top level nodes, at index ${t.nodeIndex}!`) } if (t.childCount) { const r = e ? e.nodeIndex + e.childCount : n - 1; if (t.nodeIndex <= r && t.nodeIndex + t.childCount > r) throw new Error(`Illegal State: childCount of node leads outside of parent, at index ${t.nodeIndex}!`) } } function Fi(e, t, n, r) { const s = Bi(e.root, e.renderer, e, t, n); return qi(s, e.component, r), Wi(s), s } function $i(e, t, n) { const r = Bi(e, e.renderer, null, null, t); return qi(r, n, n), Wi(r), r } function zi(e, t, n, r) { const s = t.element.componentRendererType; let i; return i = s ? e.root.rendererFactory.createRenderer(r, s) : e.root.renderer, Bi(e.root, i, e, t.element.componentProvider, n) } function Bi(e, t, n, r, s) { const i = new Array(s.nodes.length), o = s.outputCount ? new Array(s.outputCount) : null; return { def: s, parent: n, viewContainerParent: null, parentNodeDef: r, context: null, component: null, nodes: i, state: 13, root: e, renderer: t, oldValues: new Array(s.bindingCount), disposables: o, initIndex: -1 } } function qi(e, t, n) { e.component = t, e.context = n } function Wi(e) { let t; Zn(e) && (t = Rn(e.parent, e.parentNodeDef.parent.nodeIndex).renderElement); const n = e.def, r = e.nodes; for (let s = 0; s < n.nodes.length; s++) { const i = n.nodes[s]; let o; switch (Pn.setCurrentNode(e, s), 201347067 & i.flags) { case 1: const n = Ci(e, t, i); let a = void 0; if (33554432 & i.flags) { const t = er(i.element.componentView); a = Pn.createComponentView(e, i, t, n) } xi(e, a, i, n), o = { renderElement: n, componentView: a, viewContainer: null, template: i.element.template ? kr(e, i) : void 0 }, 16777216 & i.flags && (o.viewContainer = xr(e, i, o)); break; case 2: o = Mi(e, t, i); break; case 512: case 1024: case 2048: case 256: o = r[s], o || 4096 & i.flags || (o = { instance: Wr(e, i) }); break; case 16: o = { instance: Zr(e, i) }; break; case 16384: o = r[s], o || (o = { instance: Qr(e, i) }), 32768 & i.flags && qi(Rn(e, i.parent.nodeIndex).componentView, o.instance, o.instance); break; case 32: case 64: case 128: o = { value: void 0 }; break; case 67108864: case 134217728: o = new ds; break; case 8: Ni(e, t, i), o = void 0 }r[s] = o } to(e, eo.CreateViewNodes), io(e, 201326592, 268435456, 0) } function Zi(e) { Ki(e), Pn.updateDirectives(e, 1), no(e, eo.CheckNoChanges), Pn.updateRenderer(e, 1), to(e, eo.CheckNoChanges), e.state &= -97 } function Qi(e) { 1 & e.state ? (e.state &= -2, e.state |= 2) : e.state &= -3, En(e, 0, 256), Ki(e), Pn.updateDirectives(e, 0), no(e, eo.CheckAndUpdate), io(e, 67108864, 536870912, 0); let t = En(e, 256, 512); ns(e, 2097152 | (t ? 1048576 : 0)), Pn.updateRenderer(e, 0), to(e, eo.CheckAndUpdate), io(e, 134217728, 536870912, 0), t = En(e, 512, 768), ns(e, 8388608 | (t ? 4194304 : 0)), 2 & e.def.flags && (e.state &= -9), e.state &= -97, En(e, 768, 1024) } function Gi(e, t, n, r, s, i, o, a, l, u, c, h, d) { return 0 === n ? function (e, t, n, r, s, i, o, a, l, u, c, h) { switch (201347067 & t.flags) { case 1: return function (e, t, n, r, s, i, o, a, l, u, c, h) { const d = t.bindings.length; let p = !1; return d > 0 && Ei(e, t, 0, n) && (p = !0), d > 1 && Ei(e, t, 1, r) && (p = !0), d > 2 && Ei(e, t, 2, s) && (p = !0), d > 3 && Ei(e, t, 3, i) && (p = !0), d > 4 && Ei(e, t, 4, o) && (p = !0), d > 5 && Ei(e, t, 5, a) && (p = !0), d > 6 && Ei(e, t, 6, l) && (p = !0), d > 7 && Ei(e, t, 7, u) && (p = !0), d > 8 && Ei(e, t, 8, c) && (p = !0), d > 9 && Ei(e, t, 9, h) && (p = !0), p }(e, t, n, r, s, i, o, a, l, u, c, h); case 2: return function (e, t, n, r, s, i, o, a, l, u, c, h) { let d = !1; const p = t.bindings, f = p.length; if (f > 0 && Vn(e, t, 0, n) && (d = !0), f > 1 && Vn(e, t, 1, r) && (d = !0), f > 2 && Vn(e, t, 2, s) && (d = !0), f > 3 && Vn(e, t, 3, i) && (d = !0), f > 4 && Vn(e, t, 4, o) && (d = !0), f > 5 && Vn(e, t, 5, a) && (d = !0), f > 6 && Vn(e, t, 6, l) && (d = !0), f > 7 && Vn(e, t, 7, u) && (d = !0), f > 8 && Vn(e, t, 8, c) && (d = !0), f > 9 && Vn(e, t, 9, h) && (d = !0), d) { let d = t.text.prefix; f > 0 && (d += Li(n, p[0])), f > 1 && (d += Li(r, p[1])), f > 2 && (d += Li(s, p[2])), f > 3 && (d += Li(i, p[3])), f > 4 && (d += Li(o, p[4])), f > 5 && (d += Li(a, p[5])), f > 6 && (d += Li(l, p[6])), f > 7 && (d += Li(u, p[7])), f > 8 && (d += Li(c, p[8])), f > 9 && (d += Li(h, p[9])); const g = kn(e, t.nodeIndex).renderText; e.renderer.setValue(g, d) } return d }(e, t, n, r, s, i, o, a, l, u, c, h); case 16384: return function (e, t, n, r, s, i, o, a, l, u, c, h) { const d = An(e, t.nodeIndex), p = d.instance; let f = !1, g = void 0; const m = t.bindings.length; return m > 0 && jn(e, t, 0, n) && (f = !0, g = ts(e, d, t, 0, n, g)), m > 1 && jn(e, t, 1, r) && (f = !0, g = ts(e, d, t, 1, r, g)), m > 2 && jn(e, t, 2, s) && (f = !0, g = ts(e, d, t, 2, s, g)), m > 3 && jn(e, t, 3, i) && (f = !0, g = ts(e, d, t, 3, i, g)), m > 4 && jn(e, t, 4, o) && (f = !0, g = ts(e, d, t, 4, o, g)), m > 5 && jn(e, t, 5, a) && (f = !0, g = ts(e, d, t, 5, a, g)), m > 6 && jn(e, t, 6, l) && (f = !0, g = ts(e, d, t, 6, l, g)), m > 7 && jn(e, t, 7, u) && (f = !0, g = ts(e, d, t, 7, u, g)), m > 8 && jn(e, t, 8, c) && (f = !0, g = ts(e, d, t, 8, c, g)), m > 9 && jn(e, t, 9, h) && (f = !0, g = ts(e, d, t, 9, h, g)), g && p.ngOnChanges(g), 65536 & t.flags && Tn(e, 256, t.nodeIndex) && p.ngOnInit(), 262144 & t.flags && p.ngDoCheck(), f }(e, t, n, r, s, i, o, a, l, u, c, h); case 32: case 64: case 128: return function (e, t, n, r, s, i, o, a, l, u, c, h) { const d = t.bindings; let p = !1; const f = d.length; if (f > 0 && Vn(e, t, 0, n) && (p = !0), f > 1 && Vn(e, t, 1, r) && (p = !0), f > 2 && Vn(e, t, 2, s) && (p = !0), f > 3 && Vn(e, t, 3, i) && (p = !0), f > 4 && Vn(e, t, 4, o) && (p = !0), f > 5 && Vn(e, t, 5, a) && (p = !0), f > 6 && Vn(e, t, 6, l) && (p = !0), f > 7 && Vn(e, t, 7, u) && (p = !0), f > 8 && Vn(e, t, 8, c) && (p = !0), f > 9 && Vn(e, t, 9, h) && (p = !0), p) { const p = In(e, t.nodeIndex); let g; switch (201347067 & t.flags) { case 32: g = new Array(d.length), f > 0 && (g[0] = n), f > 1 && (g[1] = r), f > 2 && (g[2] = s), f > 3 && (g[3] = i), f > 4 && (g[4] = o), f > 5 && (g[5] = a), f > 6 && (g[6] = l), f > 7 && (g[7] = u), f > 8 && (g[8] = c), f > 9 && (g[9] = h); break; case 64: g = {}, f > 0 && (g[d[0].name] = n), f > 1 && (g[d[1].name] = r), f > 2 && (g[d[2].name] = s), f > 3 && (g[d[3].name] = i), f > 4 && (g[d[4].name] = o), f > 5 && (g[d[5].name] = a), f > 6 && (g[d[6].name] = l), f > 7 && (g[d[7].name] = u), f > 8 && (g[d[8].name] = c), f > 9 && (g[d[9].name] = h); break; case 128: const e = n; switch (f) { case 1: g = e.transform(n); break; case 2: g = e.transform(r); break; case 3: g = e.transform(r, s); break; case 4: g = e.transform(r, s, i); break; case 5: g = e.transform(r, s, i, o); break; case 6: g = e.transform(r, s, i, o, a); break; case 7: g = e.transform(r, s, i, o, a, l); break; case 8: g = e.transform(r, s, i, o, a, l, u); break; case 9: g = e.transform(r, s, i, o, a, l, u, c); break; case 10: g = e.transform(r, s, i, o, a, l, u, c, h) } }p.value = g } return p }(e, t, n, r, s, i, o, a, l, u, c, h); default: throw "unreachable" } }(e, t, r, s, i, o, a, l, u, c, h, d) : function (e, t, n) { switch (201347067 & t.flags) { case 1: return function (e, t, n) { let r = !1; for (let s = 0; s < n.length; s++)Ei(e, t, s, n[s]) && (r = !0); return r }(e, t, n); case 2: return function (e, t, n) { const r = t.bindings; let s = !1; for (let i = 0; i < n.length; i++)Vn(e, t, i, n[i]) && (s = !0); if (s) { let s = ""; for (let e = 0; e < n.length; e++)s += Li(n[e], r[e]); s = t.text.prefix + s; const i = kn(e, t.nodeIndex).renderText; e.renderer.setValue(i, s) } return s }(e, t, n); case 16384: return function (e, t, n) { const r = An(e, t.nodeIndex), s = r.instance; let i = !1, o = void 0; for (let a = 0; a < n.length; a++)jn(e, t, a, n[a]) && (i = !0, o = ts(e, r, t, a, n[a], o)); return o && s.ngOnChanges(o), 65536 & t.flags && Tn(e, 256, t.nodeIndex) && s.ngOnInit(), 262144 & t.flags && s.ngDoCheck(), i }(e, t, n); case 32: case 64: case 128: return function (e, t, n) { const r = t.bindings; let s = !1; for (let i = 0; i < n.length; i++)Vn(e, t, i, n[i]) && (s = !0); if (s) { const s = In(e, t.nodeIndex); let i; switch (201347067 & t.flags) { case 32: i = n; break; case 64: i = {}; for (let s = 0; s < n.length; s++)i[r[s].name] = n[s]; break; case 128: const e = n[0], t = n.slice(1); i = e.transform(...t) }s.value = i } return s }(e, t, n); default: throw "unreachable" } }(e, t, r) } function Ki(e) { const t = e.def; if (4 & t.nodeFlags) for (let n = 0; n < t.nodes.length; n++) { const r = t.nodes[n]; if (4 & r.flags) { const t = Rn(e, n).template._projectedViews; if (t) for (let n = 0; n < t.length; n++) { const r = t[n]; r.state |= 32, $n(r, e) } } else 0 == (4 & r.childFlags) && (n += r.childCount) } } function Ji(e, t, n, r, s, i, o, a, l, u, c, h, d) { return 0 === n ? function (e, t, n, r, s, i, o, a, l, u, c, h) { const d = t.bindings.length; d > 0 && Hn(e, t, 0, n), d > 1 && Hn(e, t, 1, r), d > 2 && Hn(e, t, 2, s), d > 3 && Hn(e, t, 3, i), d > 4 && Hn(e, t, 4, o), d > 5 && Hn(e, t, 5, a), d > 6 && Hn(e, t, 6, l), d > 7 && Hn(e, t, 7, u), d > 8 && Hn(e, t, 8, c), d > 9 && Hn(e, t, 9, h) }(e, t, r, s, i, o, a, l, u, c, h, d) : function (e, t, n) { for (let r = 0; r < n.length; r++)Hn(e, t, r, n[r]) }(e, t, r), !1 } function Yi(e, t) { if (Nn(e, t.nodeIndex).dirty) throw Cn(Pn.createDebugContext(e, t.nodeIndex), `Query ${t.query.id} not dirty`, `Query ${t.query.id} dirty`, 0 != (1 & e.state)) } function Xi(e) { if (!(128 & e.state)) { if (no(e, eo.Destroy), to(e, eo.Destroy), ns(e, 131072), e.disposables) for (let t = 0; t < e.disposables.length; t++)e.disposables[t](); !function (e) { if (!(16 & e.state)) return; const t = Bn(e); if (t) { const n = t.template._projectedViews; n && (Oe(n, n.indexOf(e)), Pn.dirtyParentQueries(e)) } }(e), e.renderer.destroyNode && function (e) { const t = e.def.nodes.length; for (let n = 0; n < t; n++) { const t = e.def.nodes[n]; 1 & t.flags ? e.renderer.destroyNode(Rn(e, n).renderElement) : 2 & t.flags ? e.renderer.destroyNode(kn(e, n).renderText) : (67108864 & t.flags || 134217728 & t.flags) && Nn(e, n).destroy() } }(e), Zn(e) && e.renderer.destroy(), e.state |= 128 } } const eo = function () { var e = { CreateViewNodes: 0, CheckNoChanges: 1, CheckNoChangesProjectedViews: 2, CheckAndUpdate: 3, CheckAndUpdateProjectedViews: 4, Destroy: 5 }; return e[e.CreateViewNodes] = "CreateViewNodes", e[e.CheckNoChanges] = "CheckNoChanges", e[e.CheckNoChangesProjectedViews] = "CheckNoChangesProjectedViews", e[e.CheckAndUpdate] = "CheckAndUpdate", e[e.CheckAndUpdateProjectedViews] = "CheckAndUpdateProjectedViews", e[e.Destroy] = "Destroy", e }(); function to(e, t) { const n = e.def; if (33554432 & n.nodeFlags) for (let r = 0; r < n.nodes.length; r++) { const s = n.nodes[r]; 33554432 & s.flags ? ro(Rn(e, r).componentView, t) : 0 == (33554432 & s.childFlags) && (r += s.childCount) } } function no(e, t) { const n = e.def; if (16777216 & n.nodeFlags) for (let r = 0; r < n.nodes.length; r++) { const s = n.nodes[r]; if (16777216 & s.flags) { const n = Rn(e, r).viewContainer._embeddedViews; for (let e = 0; e < n.length; e++)ro(n[e], t) } else 0 == (16777216 & s.childFlags) && (r += s.childCount) } } function ro(e, t) { const n = e.state; switch (t) { case eo.CheckNoChanges: 0 == (128 & n) && (12 == (12 & n) ? Zi(e) : 64 & n && so(e, eo.CheckNoChangesProjectedViews)); break; case eo.CheckNoChangesProjectedViews: 0 == (128 & n) && (32 & n ? Zi(e) : 64 & n && so(e, t)); break; case eo.CheckAndUpdate: 0 == (128 & n) && (12 == (12 & n) ? Qi(e) : 64 & n && so(e, eo.CheckAndUpdateProjectedViews)); break; case eo.CheckAndUpdateProjectedViews: 0 == (128 & n) && (32 & n ? Qi(e) : 64 & n && so(e, t)); break; case eo.Destroy: Xi(e); break; case eo.CreateViewNodes: Wi(e) } } function so(e, t) { no(e, t), to(e, t) } function io(e, t, n, r) { if (!(e.def.nodeFlags & t && e.def.nodeFlags & n)) return; const s = e.def.nodes.length; for (let i = 0; i < s; i++) { const s = e.def.nodes[i]; if (s.flags & t && s.flags & n) switch (Pn.setCurrentNode(e, s.nodeIndex), r) { case 0: Ri(e, s); break; case 1: Yi(e, s) }s.childFlags & t && s.childFlags & n || (i += s.childCount) } } let oo = !1; function ao(e, t, n, r, s, i) { const o = s.injector.get(Kt); return $i(uo(e, s, o, t, n), r, i) } function lo(e, t, n, r, s, i) { const o = s.injector.get(Kt), a = uo(e, s, new $o(o), t, n), l = _o(r); return Ho(To.create, $i, null, [a, l, i]) } function uo(e, t, n, r, s) { const i = t.injector.get(ht), o = t.injector.get(Ve), a = n.createRenderer(null, null); return { ngModule: t, injector: e, projectableNodes: r, selectorOrNode: s, sanitizer: i, rendererFactory: n, renderer: a, errorHandler: o } } function co(e, t, n, r) { const s = _o(n); return Ho(To.create, Fi, null, [e, t, s, r]) } function ho(e, t, n, r) { return n = mo.get(t.element.componentProvider.provider.token) || _o(n), Ho(To.create, zi, null, [e, t, n, r]) } function po(e, t, n, r) { return Dr(e, t, n, function (e) { const { hasOverrides: t, hasDeprecatedOverrides: n } = function (e) { let t = !1, n = !1; return 0 === fo.size ? { hasOverrides: t, hasDeprecatedOverrides: n } : (e.providers.forEach(e => { const r = fo.get(e.token); 3840 & e.flags && r && (t = !0, n = n || r.deprecatedBehavior) }), e.modules.forEach(e => { go.forEach((r, s) => { ue(s).providedIn === e && (t = !0, n = n || r.deprecatedBehavior) }) }), { hasOverrides: t, hasDeprecatedOverrides: n }) }(e); return t ? (function (e) { for (let t = 0; t < e.providers.length; t++) { const r = e.providers[t]; n && (r.flags |= 4096); const s = fo.get(r.token); s && (r.flags = -3841 & r.flags | s.flags, r.deps = Jn(s.deps), r.value = s.value) } if (go.size > 0) { let t = new Set(e.modules); go.forEach((r, s) => { if (t.has(ue(s).providedIn)) { let t = { token: s, flags: r.flags | (n ? 4096 : 0), deps: Jn(r.deps), value: r.value, index: e.providers.length }; e.providers.push(t), e.providersByKey[Un(s)] = t } }) } }(e = e.factory(() => On)), e) : e }(r)) } const fo = new Map, go = new Map, mo = new Map; function yo(e) { let t; fo.set(e.token, e), "function" == typeof e.token && (t = ue(e.token)) && "function" == typeof t.providedIn && go.set(e.token, e) } function vo(e, t) { const n = er(t.viewDefFactory), r = er(n.nodes[0].element.componentView); mo.set(e, r) } function wo() { fo.clear(), go.clear(), mo.clear() } function _o(e) { if (0 === fo.size) return e; const t = function (e) { const t = []; let n = null; for (let r = 0; r < e.nodes.length; r++) { const s = e.nodes[r]; 1 & s.flags && (n = s), n && 3840 & s.flags && fo.has(s.provider.token) && (t.push(n.nodeIndex), n = null) } return t }(e); if (0 === t.length) return e; e = e.factory(() => On); for (let r = 0; r < t.length; r++)n(e, t[r]); return e; function n(e, t) { for (let n = t + 1; n < e.nodes.length; n++) { const t = e.nodes[n]; if (1 & t.flags) return; if (3840 & t.flags) { const e = t.provider, n = fo.get(e.token); n && (t.flags = -3841 & t.flags | n.flags, e.deps = Jn(n.deps), e.value = n.value) } } } } function bo(e, t, n, r, s, i, o, a, l, u, c, h, d) { const p = e.def.nodes[t]; return Gi(e, p, n, r, s, i, o, a, l, u, c, h, d), 224 & p.flags ? In(e, t).value : void 0 } function Co(e, t, n, r, s, i, o, a, l, u, c, h, d) { const p = e.def.nodes[t]; return Ji(e, p, n, r, s, i, o, a, l, u, c, h, d), 224 & p.flags ? In(e, t).value : void 0 } function xo(e) { return Ho(To.detectChanges, Qi, null, [e]) } function So(e) { return Ho(To.checkNoChanges, Zi, null, [e]) } function Eo(e) { return Ho(To.destroy, Xi, null, [e]) } const To = function () { var e = { create: 0, detectChanges: 1, checkNoChanges: 2, destroy: 3, handleEvent: 4 }; return e[e.create] = "create", e[e.detectChanges] = "detectChanges", e[e.checkNoChanges] = "checkNoChanges", e[e.destroy] = "destroy", e[e.handleEvent] = "handleEvent", e }(); let ko, Ro, Ao; function Io(e, t) { Ro = e, Ao = t } function No(e, t, n, r) { return Io(e, t), Ho(To.handleEvent, e.def.handleEvent, null, [e, t, n, r]) } function Po(e, t) { if (128 & e.state) throw Sn(To[ko]); return Io(e, Mo(e, 0)), e.def.updateDirectives((function (e, n, r, ...s) { const i = e.def.nodes[n]; return 0 === t ? Do(e, i, r, s) : Uo(e, i, r, s), 16384 & i.flags && Io(e, Mo(e, n)), 224 & i.flags ? In(e, i.nodeIndex).value : void 0 }), e) } function Oo(e, t) { if (128 & e.state) throw Sn(To[ko]); return Io(e, Lo(e, 0)), e.def.updateRenderer((function (e, n, r, ...s) { const i = e.def.nodes[n]; return 0 === t ? Do(e, i, r, s) : Uo(e, i, r, s), 3 & i.flags && Io(e, Lo(e, n)), 224 & i.flags ? In(e, i.nodeIndex).value : void 0 }), e) } function Do(e, t, n, r) { if (Gi(e, t, n, ...r)) { const o = 1 === n ? r[0] : r; if (16384 & t.flags) { const n = {}; for (let e = 0; e < t.bindings.length; e++) { const r = t.bindings[e], a = o[e]; 8 & r.flags && (n[(s = r.nonMinifiedName, i = void 0, i = s.replace(/[$@]/g, "_"), `ng-reflect-${s = i.replace(ft, (...e) => "-" + e[1].toLowerCase())}`)] = gt(a)) } const r = t.parent, a = Rn(e, r.nodeIndex).renderElement; if (r.element.name) for (let t in n) { const r = n[t]; null != r ? e.renderer.setAttribute(a, t, r) : e.renderer.removeAttribute(a, t) } else e.renderer.setValue(a, `bindings=${JSON.stringify(n, null, 2)}`) } } var s, i } function Uo(e, t, n, r) { Ji(e, t, n, ...r) } function Mo(e, t) { for (let n = t; n < e.def.nodes.length; n++) { const t = e.def.nodes[n]; if (16384 & t.flags && t.bindings && t.bindings.length) return n } return null } function Lo(e, t) { for (let n = t; n < e.def.nodes.length; n++) { const t = e.def.nodes[n]; if (3 & t.flags && t.bindings && t.bindings.length) return n } return null } class jo { constructor(e, t) { this.view = e, this.nodeIndex = t, null == t && (this.nodeIndex = t = 0), this.nodeDef = e.def.nodes[t]; let n = this.nodeDef, r = e; for (; n && 0 == (1 & n.flags);)n = n.parent; if (!n) for (; !n && r;)n = qn(r), r = r.parent; this.elDef = n, this.elView = r } get elOrCompView() { return Rn(this.elView, this.elDef.nodeIndex).componentView || this.view } get injector() { return Ar(this.elView, this.elDef) } get component() { return this.elOrCompView.component } get context() { return this.elOrCompView.context } get providerTokens() { const e = []; if (this.elDef) for (let t = this.elDef.nodeIndex + 1; t <= this.elDef.nodeIndex + this.elDef.childCount; t++) { const n = this.elView.def.nodes[t]; 20224 & n.flags && e.push(n.provider.token), t += n.childCount } return e } get references() { const e = {}; if (this.elDef) { Vo(this.elView, this.elDef, e); for (let t = this.elDef.nodeIndex + 1; t <= this.elDef.nodeIndex + this.elDef.childCount; t++) { const n = this.elView.def.nodes[t]; 20224 & n.flags && Vo(this.elView, n, e), t += n.childCount } } return e } get componentRenderElement() { const e = function (e) { for (; e && !Zn(e);)e = e.parent; return e.parent ? Rn(e.parent, qn(e).nodeIndex) : null }(this.elOrCompView); return e ? e.renderElement : void 0 } get renderNode() { return 2 & this.nodeDef.flags ? Wn(this.view, this.nodeDef) : Wn(this.elView, this.elDef) } logError(e, ...t) { let n, r; 2 & this.nodeDef.flags ? (n = this.view.def, r = this.nodeDef.nodeIndex) : (n = this.elView.def, r = this.elDef.nodeIndex); const s = function (e, t) { let n = -1; for (let r = 0; r <= t; r++)3 & e.nodes[r].flags && n++; return n }(n, r); let i = -1; n.factory(() => (i++, i === s ? e.error.bind(e, ...t) : On)), i < s && (e.error("Illegal state: the ViewDefinitionFactory did not call the logger!"), e.error(...t)) } } function Vo(e, t, n) { for (let r in t.references) n[r] = Ii(e, t, t.references[r]) } function Ho(e, t, n, r) { const s = ko, i = Ro, o = Ao; try { ko = e; const a = t.apply(n, r); return Ro = i, Ao = o, ko = s, a } catch (a) { if (Me(a) || !Ro) throw a; throw function (e, t) { return e instanceof Error || (e = new Error(e.toString())), xn(e, t), e }(a, Fo()) } } function Fo() { return Ro ? new jo(Ro, Ao) : null } class $o { constructor(e) { this.delegate = e } createRenderer(e, t) { return new zo(this.delegate.createRenderer(e, t)) } begin() { this.delegate.begin && this.delegate.begin() } end() { this.delegate.end && this.delegate.end() } whenRenderingDone() { return this.delegate.whenRenderingDone ? this.delegate.whenRenderingDone() : Promise.resolve(null) } } class zo { constructor(e) { this.delegate = e, this.debugContextFactory = Fo, this.data = this.delegate.data } createDebugContext(e) { return this.debugContextFactory(e) } destroyNode(e) { const t = di(e); !function (e) { hi.delete(e.nativeNode) }(t), t instanceof ui && (t.listeners.length = 0), this.delegate.destroyNode && this.delegate.destroyNode(e) } destroy() { this.delegate.destroy() } createElement(e, t) { const n = this.delegate.createElement(e, t), r = this.createDebugContext(n); if (r) { const t = new ci(n, null, r); t.name = e, pi(t) } return n } createComment(e) { const t = this.delegate.createComment(e), n = this.createDebugContext(t); return n && pi(new ui(t, null, n)), t } createText(e) { const t = this.delegate.createText(e), n = this.createDebugContext(t); return n && pi(new ui(t, null, n)), t } appendChild(e, t) { const n = di(e), r = di(t); n && r && n instanceof ci && n.addChild(r), this.delegate.appendChild(e, t) } insertBefore(e, t, n) { const r = di(e), s = di(t), i = di(n); r && s && r instanceof ci && r.insertBefore(i, s), this.delegate.insertBefore(e, t, n) } removeChild(e, t) { const n = di(e), r = di(t); n && r && n instanceof ci && n.removeChild(r), this.delegate.removeChild(e, t) } selectRootElement(e, t) { const n = this.delegate.selectRootElement(e, t), r = Fo(); return r && pi(new ci(n, null, r)), n } setAttribute(e, t, n, r) { const s = di(e); s && s instanceof ci && (s.attributes[r ? r + ":" + t : t] = n), this.delegate.setAttribute(e, t, n, r) } removeAttribute(e, t, n) { const r = di(e); r && r instanceof ci && (r.attributes[n ? n + ":" + t : t] = null), this.delegate.removeAttribute(e, t, n) } addClass(e, t) { const n = di(e); n && n instanceof ci && (n.classes[t] = !0), this.delegate.addClass(e, t) } removeClass(e, t) { const n = di(e); n && n instanceof ci && (n.classes[t] = !1), this.delegate.removeClass(e, t) } setStyle(e, t, n, r) { const s = di(e); s && s instanceof ci && (s.styles[t] = n), this.delegate.setStyle(e, t, n, r) } removeStyle(e, t, n) { const r = di(e); r && r instanceof ci && (r.styles[t] = null), this.delegate.removeStyle(e, t, n) } setProperty(e, t, n) { const r = di(e); r && r instanceof ci && (r.properties[t] = n), this.delegate.setProperty(e, t, n) } listen(e, t, n) { if ("string" != typeof e) { const r = di(e); r && r.listeners.push(new li(t, n)) } return this.delegate.listen(e, t, n) } parentNode(e) { return this.delegate.parentNode(e) } nextSibling(e) { return this.delegate.nextSibling(e) } setValue(e, t) { return this.delegate.setValue(e, t) } } function Bo(e, t, n) { return new qo(e, t, n) } class qo extends Ne { constructor(e, t, n) { super(), this.moduleType = e, this._bootstrapComponents = t, this._ngModuleDefFactory = n } create(e) { !function () { if (oo) return; oo = !0; const e = $e() ? { setCurrentNode: Io, createRootView: lo, createEmbeddedView: co, createComponentView: ho, createNgModuleRef: po, overrideProvider: yo, overrideComponentView: vo, clearOverrides: wo, checkAndUpdateView: xo, checkNoChangesView: So, destroyView: Eo, createDebugContext: (e, t) => new jo(e, t), handleEvent: No, updateDirectives: Po, updateRenderer: Oo } : { setCurrentNode: () => { }, createRootView: ao, createEmbeddedView: Fi, createComponentView: zi, createNgModuleRef: Dr, overrideProvider: On, overrideComponentView: On, clearOverrides: On, checkAndUpdateView: Qi, checkNoChangesView: Zi, destroyView: Xi, createDebugContext: (e, t) => new jo(e, t), handleEvent: (e, t, n, r) => e.def.handleEvent(e, t, n, r), updateDirectives: (e, t) => e.def.updateDirectives(0 === t ? bo : Co, e), updateRenderer: (e, t) => e.def.updateRenderer(0 === t ? bo : Co, e) }; Pn.setCurrentNode = e.setCurrentNode, Pn.createRootView = e.createRootView, Pn.createEmbeddedView = e.createEmbeddedView, Pn.createComponentView = e.createComponentView, Pn.createNgModuleRef = e.createNgModuleRef, Pn.overrideProvider = e.overrideProvider, Pn.overrideComponentView = e.overrideComponentView, Pn.clearOverrides = e.clearOverrides, Pn.checkAndUpdateView = e.checkAndUpdateView, Pn.checkNoChangesView = e.checkNoChangesView, Pn.destroyView = e.destroyView, Pn.resolveDep = Xr, Pn.createDebugContext = e.createDebugContext, Pn.handleEvent = e.handleEvent, Pn.updateDirectives = e.updateDirectives, Pn.updateRenderer = e.updateRenderer, Pn.dirtyParentQueries = ki }(); const t = function (e) { const t = Array.from(e.providers), n = Array.from(e.modules), r = {}; for (const s in e.providersByKey) r[s] = e.providersByKey[s]; return { factory: e.factory, isRoot: e.isRoot, providers: t, modules: n, providersByKey: r } }(er(this._ngModuleDefFactory)); return Pn.createNgModuleRef(this.moduleType, e || _t.NULL, this._bootstrapComponents, t) } } class Wo { } class Zo { constructor() { this.title = "app" } } class Qo { } const Go = new _e("Location Initialized"); class Ko { } const Jo = new _e("appBaseHref"); class Yo { constructor(e, t) { this._subject = new cs, this._urlChangeListeners = [], this._platformStrategy = e; const n = this._platformStrategy.getBaseHref(); this._platformLocation = t, this._baseHref = Yo.stripTrailingSlash(Xo(n)), this._platformStrategy.onPopState(e => { this._subject.emit({ url: this.path(!0), pop: !0, state: e.state, type: e.type }) }) } path(e = !1) { return this.normalize(this._platformStrategy.path(e)) } getState() { return this._platformLocation.getState() } isCurrentPathEqualTo(e, t = "") { return this.path() == this.normalize(e + Yo.normalizeQueryParams(t)) } normalize(e) { return Yo.stripTrailingSlash(function (e, t) { return e && t.startsWith(e) ? t.substring(e.length) : t }(this._baseHref, Xo(e))) } prepareExternalUrl(e) { return e && "/" !== e[0] && (e = "/" + e), this._platformStrategy.prepareExternalUrl(e) } go(e, t = "", n = null) { this._platformStrategy.pushState(n, "", e, t), this._notifyUrlChangeListeners(this.prepareExternalUrl(e + Yo.normalizeQueryParams(t)), n) } replaceState(e, t = "", n = null) { this._platformStrategy.replaceState(n, "", e, t), this._notifyUrlChangeListeners(this.prepareExternalUrl(e + Yo.normalizeQueryParams(t)), n) } forward() { this._platformStrategy.forward() } back() { this._platformStrategy.back() } onUrlChange(e) { this._urlChangeListeners.push(e), this.subscribe(e => { this._notifyUrlChangeListeners(e.url, e.state) }) } _notifyUrlChangeListeners(e = "", t) { this._urlChangeListeners.forEach(n => n(e, t)) } subscribe(e, t, n) { return this._subject.subscribe({ next: e, error: t, complete: n }) } static normalizeQueryParams(e) { return e && "?" !== e[0] ? "?" + e : e } static joinWithSlash(e, t) { if (0 == e.length) return t; if (0 == t.length) return e; let n = 0; return e.endsWith("/") && n++, t.startsWith("/") && n++, 2 == n ? e + t.substring(1) : 1 == n ? e + t : e + "/" + t } static stripTrailingSlash(e) { const t = e.match(/#|\?|$/), n = t && t.index || e.length; return e.slice(0, n - ("/" === e[n - 1] ? 1 : 0)) + e.slice(n) } } function Xo(e) { return e.replace(/\/index.html$/, "") } class ea extends Ko { constructor(e, t) { super(), this._platformLocation = e, this._baseHref = "", null != t && (this._baseHref = t) } onPopState(e) { this._platformLocation.onPopState(e), this._platformLocation.onHashChange(e) } getBaseHref() { return this._baseHref } path(e = !1) { let t = this._platformLocation.hash; return null == t && (t = "#"), t.length > 0 ? t.substring(1) : t } prepareExternalUrl(e) { const t = Yo.joinWithSlash(this._baseHref, e); return t.length > 0 ? "#" + t : t } pushState(e, t, n, r) { let s = this.prepareExternalUrl(n + Yo.normalizeQueryParams(r)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.pushState(e, t, s) } replaceState(e, t, n, r) { let s = this.prepareExternalUrl(n + Yo.normalizeQueryParams(r)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.replaceState(e, t, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } } class ta extends Ko { constructor(e, t) { if (super(), this._platformLocation = e, null == t && (t = this._platformLocation.getBaseHrefFromDOM()), null == t) throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document."); this._baseHref = t } onPopState(e) { this._platformLocation.onPopState(e), this._platformLocation.onHashChange(e) } getBaseHref() { return this._baseHref } prepareExternalUrl(e) { return Yo.joinWithSlash(this._baseHref, e) } path(e = !1) { const t = this._platformLocation.pathname + Yo.normalizeQueryParams(this._platformLocation.search), n = this._platformLocation.hash; return n && e ? `${t}${n}` : t } pushState(e, t, n, r) { const s = this.prepareExternalUrl(n + Yo.normalizeQueryParams(r)); this._platformLocation.pushState(e, t, s) } replaceState(e, t, n, r) { const s = this.prepareExternalUrl(n + Yo.normalizeQueryParams(r)); this._platformLocation.replaceState(e, t, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } } const na = function () { var e = { Zero: 0, One: 1, Two: 2, Few: 3, Many: 4, Other: 5 }; return e[e.Zero] = "Zero", e[e.One] = "One", e[e.Two] = "Two", e[e.Few] = "Few", e[e.Many] = "Many", e[e.Other] = "Other", e }(), ra = new _e("UseV4Plurals"); class sa { } class ia extends sa { constructor(e, t) { super(), this.locale = e, this.deprecatedPluralFn = t } getPluralCategory(e, t) { switch (this.deprecatedPluralFn ? this.deprecatedPluralFn(t || this.locale, e) : function (e) { return function (e) { const t = e.toLowerCase().replace(/_/g, "-"); let n = os[t]; if (n) return n; const r = t.split("-")[0]; if (n = os[r], n) return n; if ("en" === r) return us; throw new Error(`Missing locale data for the locale "${e}".`) }(e)[as.PluralCase] }(t || this.locale)(e)) { case na.Zero: return "zero"; case na.One: return "one"; case na.Two: return "two"; case na.Few: return "few"; case na.Many: return "many"; default: return "other" } } } function oa(e, t) { t = encodeURIComponent(t); for (const n of e.split(";")) { const e = n.indexOf("="), [r, s] = -1 == e ? [n, ""] : [n.slice(0, e), n.slice(e + 1)]; if (r.trim() === t) return decodeURIComponent(s) } return null } class aa { } class la { constructor(e, t, n, r) { this._iterableDiffers = e, this._keyValueDiffers = t, this._ngEl = n, this._renderer = r, this._initialClasses = [] } getValue() { return null } setClass(e) { this._removeClasses(this._initialClasses), this._initialClasses = "string" == typeof e ? e.split(/\s+/) : [], this._applyClasses(this._initialClasses), this._applyClasses(this._rawClass) } setNgClass(e) { this._removeClasses(this._rawClass), this._applyClasses(this._initialClasses), this._iterableDiffer = null, this._keyValueDiffer = null, this._rawClass = "string" == typeof e ? e.split(/\s+/) : e, this._rawClass && (Dt(this._rawClass) ? this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create() : this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create()) } applyChanges() { if (this._iterableDiffer) { const e = this._iterableDiffer.diff(this._rawClass); e && this._applyIterableChanges(e) } else if (this._keyValueDiffer) { const e = this._keyValueDiffer.diff(this._rawClass); e && this._applyKeyValueChanges(e) } } _applyKeyValueChanges(e) { e.forEachAddedItem(e => this._toggleClass(e.key, e.currentValue)), e.forEachChangedItem(e => this._toggleClass(e.key, e.currentValue)), e.forEachRemovedItem(e => { e.previousValue && this._toggleClass(e.key, !1) }) } _applyIterableChanges(e) { e.forEachAddedItem(e => { if ("string" != typeof e.item) throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${he(e.item)}`); this._toggleClass(e.item, !0) }), e.forEachRemovedItem(e => this._toggleClass(e.item, !1)) } _applyClasses(e) { e && (Array.isArray(e) || e instanceof Set ? e.forEach(e => this._toggleClass(e, !0)) : Object.keys(e).forEach(t => this._toggleClass(t, !!e[t]))) } _removeClasses(e) { e && (Array.isArray(e) || e instanceof Set ? e.forEach(e => this._toggleClass(e, !1)) : Object.keys(e).forEach(e => this._toggleClass(e, !1))) } _toggleClass(e, t) { (e = e.trim()) && e.split(/\s+/g).forEach(e => { t ? this._renderer.addClass(this._ngEl.nativeElement, e) : this._renderer.removeClass(this._ngEl.nativeElement, e) }) } } let ua = (() => { class e { constructor(e) { this._delegate = e } getValue() { return this._delegate.getValue() } } return e.ngDirectiveDef = void 0, e })(); class ca extends ua { constructor(e) { super(e) } set klass(e) { this._delegate.setClass(e) } set ngClass(e) { this._delegate.setNgClass(e) } ngDoCheck() { this._delegate.applyChanges() } } class ha { constructor(e, t, n, r) { this.$implicit = e, this.ngForOf = t, this.index = n, this.count = r } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } class da { constructor(e, t, n) { this._viewContainer = e, this._template = t, this._differs = n, this._ngForOfDirty = !0, this._differ = null } set ngForOf(e) { this._ngForOf = e, this._ngForOfDirty = !0 } set ngForTrackBy(e) { $e() && null != e && "function" != typeof e && console && console.warn && console.warn(`trackBy must be a function, but received ${JSON.stringify(e)}. ` + "See https://angular.io/docs/ts/latest/api/common/index/NgFor-directive.html#!#change-propagation for more information."), this._trackByFn = e } get ngForTrackBy() { return this._trackByFn } set ngForTemplate(e) { e && (this._template = e) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const n = this._ngForOf; if (!this._differ && n) try { this._differ = this._differs.find(n).create(this.ngForTrackBy) } catch (t) { throw new Error(`Cannot find a differ supporting object '${n}' of type '${e = n, e.name || typeof e}'. NgFor only supports binding to Iterables such as Arrays.`) } } var e; if (this._differ) { const e = this._differ.diff(this._ngForOf); e && this._applyChanges(e) } } _applyChanges(e) { const t = []; e.forEachOperation((e, n, r) => { if (null == e.previousIndex) { const n = this._viewContainer.createEmbeddedView(this._template, new ha(null, this._ngForOf, -1, -1), null === r ? void 0 : r), s = new pa(e, n); t.push(s) } else if (null == r) this._viewContainer.remove(null === n ? void 0 : n); else if (null !== n) { const s = this._viewContainer.get(n); this._viewContainer.move(s, r); const i = new pa(e, s); t.push(i) } }); for (let n = 0; n < t.length; n++)this._perViewChange(t[n].view, t[n].record); for (let n = 0, r = this._viewContainer.length; n < r; n++) { const e = this._viewContainer.get(n); e.context.index = n, e.context.count = r, e.context.ngForOf = this._ngForOf } e.forEachIdentityChange(e => { this._viewContainer.get(e.currentIndex).context.$implicit = e.item }) } _perViewChange(e, t) { e.context.$implicit = t.item } static ngTemplateContextGuard(e, t) { return !0 } } class pa { constructor(e, t) { this.record = e, this.view = t } } class fa { constructor(e, t) { this._viewContainer = e, this._context = new ga, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = t } set ngIf(e) { this._context.$implicit = this._context.ngIf = e, this._updateView() } set ngIfThen(e) { ma("ngIfThen", e), this._thenTemplateRef = e, this._thenViewRef = null, this._updateView() } set ngIfElse(e) { ma("ngIfElse", e), this._elseTemplateRef = e, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } } class ga { constructor() { this.$implicit = null, this.ngIf = null } } function ma(e, t) { if (t && !t.createEmbeddedView) throw new Error(`${e} must be a TemplateRef, but received '${he(t)}'.`) } class ya { } const va = new _e("DocumentToken"); let wa = (() => { class e { } return e.ngInjectableDef = le({ token: e, providedIn: "root", factory: () => new _a(ke(va), window, ke(Ve)) }), e })(); class _a { constructor(e, t, n) { this.document = e, this.window = t, this.errorHandler = n, this.offset = () => [0, 0] } setOffset(e) { this.offset = Array.isArray(e) ? () => e : e } getScrollPosition() { return this.supportScrollRestoration() ? [this.window.scrollX, this.window.scrollY] : [0, 0] } scrollToPosition(e) { this.supportScrollRestoration() && this.window.scrollTo(e[0], e[1]) } scrollToAnchor(e) { if (this.supportScrollRestoration()) { e = this.window.CSS && this.window.CSS.escape ? this.window.CSS.escape(e) : e.replace(/(\"|\'\ |:|\.|\[|\]|,|=)/g, "\\$1"); try { const t = this.document.querySelector(`#${e}`); if (t) return void this.scrollToElement(t); const n = this.document.querySelector(`[name='${e}']`); if (n) return void this.scrollToElement(n) } catch (t) { this.errorHandler.handleError(t) } } } setHistoryScrollRestoration(e) { if (this.supportScrollRestoration()) { const t = this.window.history; t && t.scrollRestoration && (t.scrollRestoration = e) } } scrollToElement(e) { const t = e.getBoundingClientRect(), n = t.left + this.window.pageXOffset, r = t.top + this.window.pageYOffset, s = this.offset(); this.window.scrollTo(n - s[0], r - s[1]) } supportScrollRestoration() { try { return !!this.window && !!this.window.scrollTo } catch (e) { return !1 } } } function ba(...e) { let t = e[e.length - 1]; return k(t) ? (e.pop(), H(e, t)) : Z(e) } class Ca extends E { constructor(e) { super(), this._value = e } get value() { return this.getValue() } _subscribe(e) { const t = super._subscribe(e); return t && !t.closed && e.next(this._value), t } getValue() { if (this.hasError) throw this.thrownError; if (this.closed) throw new C; return this._value } next(e) { super.next(this._value = e) } } const xa = (() => { function e() { return Error.call(this), this.message = "no elements in sequence", this.name = "EmptyError", this } return e.prototype = Object.create(Error.prototype), e })(), Sa = {}; class Ea { constructor(e) { this.resultSelector = e } call(e, t) { return t.subscribe(new Ta(e, this.resultSelector)) } } class Ta extends M { constructor(e, t) { super(e), this.resultSelector = t, this.active = 0, this.values = [], this.observables = [] } _next(e) { this.values.push(Sa), this.observables.push(e) } _complete() { const e = this.observables, t = e.length; if (0 === t) this.destination.complete(); else { this.active = t, this.toRespond = t; for (let n = 0; n < t; n++) { const t = e[n]; this.add(U(this, t, t, n)) } } } notifyComplete(e) { 0 == (this.active -= 1) && this.destination.complete() } notifyNext(e, t, n, r, s) { const i = this.values, o = this.toRespond ? i[n] === Sa ? --this.toRespond : this.toRespond : 0; i[n] = t, 0 === o && (this.resultSelector ? this._tryResultSelector(i) : this.destination.next(i.slice())) } _tryResultSelector(e) { let t; try { t = this.resultSelector.apply(this, e) } catch (n) { return void this.destination.error(n) } this.destination.next(t) } } const ka = new _(e => e.complete()); function Ra(e) { return e ? function (e) { return new _(t => e.schedule(() => t.complete())) }(e) : ka } function Aa(e) { return new _(t => { let n; try { n = e() } catch (r) { return void t.error(r) } return (n ? F(n) : Ra()).subscribe(t) }) } function Ia() { return W(1) } function Na(e, t) { return function (n) { return n.lift(new Pa(e, t)) } } class Pa { constructor(e, t) { this.predicate = e, this.thisArg = t } call(e, t) { return t.subscribe(new Oa(e, this.predicate, this.thisArg)) } } class Oa extends f { constructor(e, t, n) { super(e), this.predicate = t, this.thisArg = n, this.count = 0 } _next(e) { let t; try { t = this.predicate.call(this.thisArg, e, this.count++) } catch (n) { return void this.destination.error(n) } t && this.destination.next(e) } } const Da = (() => { function e() { return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this } return e.prototype = Object.create(Error.prototype), e })(); function Ua(e) { return function (t) { return 0 === e ? Ra() : t.lift(new Ma(e)) } } class Ma { constructor(e) { if (this.total = e, this.total < 0) throw new Da } call(e, t) { return t.subscribe(new La(e, this.total)) } } class La extends f { constructor(e, t) { super(e), this.total = t, this.ring = new Array, this.count = 0 } _next(e) { const t = this.ring, n = this.total, r = this.count++; t.length < n ? t.push(e) : t[r % n] = e } _complete() { const e = this.destination; let t = this.count; if (t > 0) { const n = this.count >= this.total ? this.total : this.count, r = this.ring; for (let s = 0; s < n; s++) { const s = t++ % n; e.next(r[s]) } } e.complete() } } function ja(e = Fa) { return t => t.lift(new Va(e)) } class Va { constructor(e) { this.errorFactory = e } call(e, t) { return t.subscribe(new Ha(e, this.errorFactory)) } } class Ha extends f { constructor(e, t) { super(e), this.errorFactory = t, this.hasValue = !1 } _next(e) { this.hasValue = !0, this.destination.next(e) } _complete() { if (this.hasValue) return this.destination.complete(); { let t; try { t = this.errorFactory() } catch (e) { t = e } this.destination.error(t) } } } function Fa() { return new xa } function $a(e = null) { return t => t.lift(new za(e)) } class za { constructor(e) { this.defaultValue = e } call(e, t) { return t.subscribe(new Ba(e, this.defaultValue)) } } class Ba extends f { constructor(e, t) { super(e), this.defaultValue = t, this.isEmpty = !0 } _next(e) { this.isEmpty = !1, this.destination.next(e) } _complete() { this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete() } } function qa(e, t) { const n = arguments.length >= 2; return r => r.pipe(e ? Na((t, n) => e(t, n, r)) : q, Ua(1), n ? $a(t) : ja(() => new xa)) } function Wa(e) { return function (t) { const n = new Za(e), r = t.lift(n); return n.caught = r } } class Za { constructor(e) { this.selector = e } call(e, t) { return t.subscribe(new Qa(e, this.selector, this.caught)) } } class Qa extends M { constructor(e, t, n) { super(e), this.selector = t, this.caught = n } error(e) { if (!this.isStopped) { let n; try { n = this.selector(e, this.caught) } catch (t) { return void super.error(t) } this._unsubscribeAndRecycle(); const r = new R(this, void 0, void 0); this.add(r); const s = U(this, n, void 0, void 0, r); s !== r && this.add(s) } } } function Ga(e) { return t => 0 === e ? Ra() : t.lift(new Ka(e)) } class Ka { constructor(e) { if (this.total = e, this.total < 0) throw new Da } call(e, t) { return t.subscribe(new Ja(e, this.total)) } } class Ja extends f { constructor(e, t) { super(e), this.total = t, this.count = 0 } _next(e) { const t = this.total, n = ++this.count; n <= t && (this.destination.next(e), n === t && (this.destination.complete(), this.unsubscribe())) } } function Ya(e, t) { const n = arguments.length >= 2; return r => r.pipe(e ? Na((t, n) => e(t, n, r)) : q, Ga(1), n ? $a(t) : ja(() => new xa)) } class Xa { constructor(e, t, n) { this.predicate = e, this.thisArg = t, this.source = n } call(e, t) { return t.subscribe(new el(e, this.predicate, this.thisArg, this.source)) } } class el extends f { constructor(e, t, n, r) { super(e), this.predicate = t, this.thisArg = n, this.source = r, this.index = 0, this.thisArg = n || this } notifyComplete(e) { this.destination.next(e), this.destination.complete() } _next(e) { let t = !1; try { t = this.predicate.call(this.thisArg, e, this.index++, this.source) } catch (n) { return void this.destination.error(n) } t || this.notifyComplete(!1) } _complete() { this.notifyComplete(!0) } } function tl(e, t) { return "function" == typeof t ? n => n.pipe(tl((n, r) => F(e(n, r)).pipe(L((e, s) => t(n, e, r, s))))) : t => t.lift(new nl(e)) } class nl { constructor(e) { this.project = e } call(e, t) { return t.subscribe(new rl(e, this.project)) } } class rl extends M { constructor(e, t) { super(e), this.project = t, this.index = 0 } _next(e) { let t; const n = this.index++; try { t = this.project(e, n) } catch (r) { return void this.destination.error(r) } this._innerSub(t, e, n) } _innerSub(e, t, n) { const r = this.innerSubscription; r && r.unsubscribe(); const s = new R(this, t, n), i = this.destination; i.add(s), this.innerSubscription = U(this, e, void 0, void 0, s), this.innerSubscription !== s && i.add(this.innerSubscription) } _complete() { const { innerSubscription: e } = this; e && !e.closed || super._complete(), this.unsubscribe() } _unsubscribe() { this.innerSubscription = null } notifyComplete(e) { this.destination.remove(e), this.innerSubscription = null, this.isStopped && super._complete() } notifyNext(e, t, n, r, s) { this.destination.next(t) } } function sl(...e) { return Ia()(ba(...e)) } function il(e, t) { let n = !1; return arguments.length >= 2 && (n = !0), function (r) { return r.lift(new ol(e, t, n)) } } class ol { constructor(e, t, n = !1) { this.accumulator = e, this.seed = t, this.hasSeed = n } call(e, t) { return t.subscribe(new al(e, this.accumulator, this.seed, this.hasSeed)) } } class al extends f { constructor(e, t, n, r) { super(e), this.accumulator = t, this._seed = n, this.hasSeed = r, this.index = 0 } get seed() { return this._seed } set seed(e) { this.hasSeed = !0, this._seed = e } _next(e) { if (this.hasSeed) return this._tryNext(e); this.seed = e, this.destination.next(e) } _tryNext(e) { const t = this.index++; let n; try { n = this.accumulator(this.seed, e, t) } catch (r) { this.destination.error(r) } this.seed = n, this.destination.next(n) } } function ll(e, t) { return $(e, t, 1) } function ul(e, t, n) { return function (r) { return r.lift(new cl(e, t, n)) } } class cl { constructor(e, t, n) { this.nextOrObserver = e, this.error = t, this.complete = n } call(e, t) { return t.subscribe(new hl(e, this.nextOrObserver, this.error, this.complete)) } } class hl extends f { constructor(e, t, n, s) { super(e), this._tapNext = y, this._tapError = y, this._tapComplete = y, this._tapError = n || y, this._tapComplete = s || y, r(t) ? (this._context = this, this._tapNext = t) : t && (this._context = t, this._tapNext = t.next || y, this._tapError = t.error || y, this._tapComplete = t.complete || y) } _next(e) { try { this._tapNext.call(this._context, e) } catch (t) { return void this.destination.error(t) } this.destination.next(e) } _error(e) { try { this._tapError.call(this._context, e) } catch (e) { return void this.destination.error(e) } this.destination.error(e) } _complete() { try { this._tapComplete.call(this._context) } catch (e) { return void this.destination.error(e) } return this.destination.complete() } } class dl { constructor(e) { this.callback = e } call(e, t) { return t.subscribe(new pl(e, this.callback)) } } class pl extends f { constructor(e, t) { super(e), this.add(new h(t)) } } let fl = null; function gl() { return fl } const ml = { class: "className", innerHtml: "innerHTML", readonly: "readOnly", tabindex: "tabIndex" }, yl = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, vl = { A: "1", B: "2", C: "3", D: "4", E: "5", F: "6", G: "7", H: "8", I: "9", J: "*", K: "+", M: "-", N: ".", O: "/", "`": "0", "\x90": "NumLock" }, wl = (() => { if (we.Node) return we.Node.prototype.contains || function (e) { return !!(16 & this.compareDocumentPosition(e)) } })(); class _l extends class extends class { constructor() { this.resourceLoaderType = null } get attrToPropMap() { return this._attrToPropMap } set attrToPropMap(e) { this._attrToPropMap = e } }{ constructor() { super(), this._animationPrefix = null, this._transitionEnd = null; try { const e = this.createElement("div", document); if (null != this.getStyle(e, "animationName")) this._animationPrefix = ""; else { const t = ["Webkit", "Moz", "O", "ms"]; for (let n = 0; n < t.length; n++)if (null != this.getStyle(e, t[n] + "AnimationName")) { this._animationPrefix = "-" + t[n].toLowerCase() + "-"; break } } const t = { WebkitTransition: "webkitTransitionEnd", MozTransition: "transitionend", OTransition: "oTransitionEnd otransitionend", transition: "transitionend" }; Object.keys(t).forEach(n => { null != this.getStyle(e, n) && (this._transitionEnd = t[n]) }) } catch (e) { this._animationPrefix = null, this._transitionEnd = null } } getDistributedNodes(e) { return e.getDistributedNodes() } resolveAndSetHref(e, t, n) { e.href = null == n ? t : t + "/../" + n } supportsDOMEvents() { return !0 } supportsNativeShadowDOM() { return "function" == typeof document.body.createShadowRoot } getAnimationPrefix() { return this._animationPrefix ? this._animationPrefix : "" } getTransitionEnd() { return this._transitionEnd ? this._transitionEnd : "" } supportsAnimation() { return null != this._animationPrefix && null != this._transitionEnd } }{ parse(e) { throw new Error("parse not implemented") } static makeCurrent() { var e; e = new _l, fl || (fl = e) } hasProperty(e, t) { return t in e } setProperty(e, t, n) { e[t] = n } getProperty(e, t) { return e[t] } invoke(e, t, n) { e[t](...n) } logError(e) { window.console && (console.error ? console.error(e) : console.log(e)) } log(e) { window.console && window.console.log && window.console.log(e) } logGroup(e) { window.console && window.console.group && window.console.group(e) } logGroupEnd() { window.console && window.console.groupEnd && window.console.groupEnd() } get attrToPropMap() { return ml } contains(e, t) { return wl.call(e, t) } querySelector(e, t) { return e.querySelector(t) } querySelectorAll(e, t) { return e.querySelectorAll(t) } on(e, t, n) { e.addEventListener(t, n, !1) } onAndCancel(e, t, n) { return e.addEventListener(t, n, !1), () => { e.removeEventListener(t, n, !1) } } dispatchEvent(e, t) { e.dispatchEvent(t) } createMouseEvent(e) { const t = this.getDefaultDocument().createEvent("MouseEvent"); return t.initEvent(e, !0, !0), t } createEvent(e) { const t = this.getDefaultDocument().createEvent("Event"); return t.initEvent(e, !0, !0), t } preventDefault(e) { e.preventDefault(), e.returnValue = !1 } isPrevented(e) { return e.defaultPrevented || null != e.returnValue && !e.returnValue } getInnerHTML(e) { return e.innerHTML } getTemplateContent(e) { return "content" in e && this.isTemplateElement(e) ? e.content : null } getOuterHTML(e) { return e.outerHTML } nodeName(e) { return e.nodeName } nodeValue(e) { return e.nodeValue } type(e) { return e.type } content(e) { return this.hasProperty(e, "content") ? e.content : e } firstChild(e) { return e.firstChild } nextSibling(e) { return e.nextSibling } parentElement(e) { return e.parentNode } childNodes(e) { return e.childNodes } childNodesAsList(e) { const t = e.childNodes, n = new Array(t.length); for (let r = 0; r < t.length; r++)n[r] = t[r]; return n } clearNodes(e) { for (; e.firstChild;)e.removeChild(e.firstChild) } appendChild(e, t) { e.appendChild(t) } removeChild(e, t) { e.removeChild(t) } replaceChild(e, t, n) { e.replaceChild(t, n) } remove(e) { return e.parentNode && e.parentNode.removeChild(e), e } insertBefore(e, t, n) { e.insertBefore(n, t) } insertAllBefore(e, t, n) { n.forEach(n => e.insertBefore(n, t)) } insertAfter(e, t, n) { e.insertBefore(n, t.nextSibling) } setInnerHTML(e, t) { e.innerHTML = t } getText(e) { return e.textContent } setText(e, t) { e.textContent = t } getValue(e) { return e.value } setValue(e, t) { e.value = t } getChecked(e) { return e.checked } setChecked(e, t) { e.checked = t } createComment(e) { return this.getDefaultDocument().createComment(e) } createTemplate(e) { const t = this.getDefaultDocument().createElement("template"); return t.innerHTML = e, t } createElement(e, t) { return (t = t || this.getDefaultDocument()).createElement(e) } createElementNS(e, t, n) { return (n = n || this.getDefaultDocument()).createElementNS(e, t) } createTextNode(e, t) { return (t = t || this.getDefaultDocument()).createTextNode(e) } createScriptTag(e, t, n) { const r = (n = n || this.getDefaultDocument()).createElement("SCRIPT"); return r.setAttribute(e, t), r } createStyleElement(e, t) { const n = (t = t || this.getDefaultDocument()).createElement("style"); return this.appendChild(n, this.createTextNode(e, t)), n } createShadowRoot(e) { return e.createShadowRoot() } getShadowRoot(e) { return e.shadowRoot } getHost(e) { return e.host } clone(e) { return e.cloneNode(!0) } getElementsByClassName(e, t) { return e.getElementsByClassName(t) } getElementsByTagName(e, t) { return e.getElementsByTagName(t) } classList(e) { return Array.prototype.slice.call(e.classList, 0) } addClass(e, t) { e.classList.add(t) } removeClass(e, t) { e.classList.remove(t) } hasClass(e, t) { return e.classList.contains(t) } setStyle(e, t, n) { e.style[t] = n } removeStyle(e, t) { e.style[t] = "" } getStyle(e, t) { return e.style[t] } hasStyle(e, t, n) { const r = this.getStyle(e, t) || ""; return n ? r == n : r.length > 0 } tagName(e) { return e.tagName } attributeMap(e) { const t = new Map, n = e.attributes; for (let r = 0; r < n.length; r++) { const e = n.item(r); t.set(e.name, e.value) } return t } hasAttribute(e, t) { return e.hasAttribute(t) } hasAttributeNS(e, t, n) { return e.hasAttributeNS(t, n) } getAttribute(e, t) { return e.getAttribute(t) } getAttributeNS(e, t, n) { return e.getAttributeNS(t, n) } setAttribute(e, t, n) { e.setAttribute(t, n) } setAttributeNS(e, t, n, r) { e.setAttributeNS(t, n, r) } removeAttribute(e, t) { e.removeAttribute(t) } removeAttributeNS(e, t, n) { e.removeAttributeNS(t, n) } templateAwareRoot(e) { return this.isTemplateElement(e) ? this.content(e) : e } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } getBoundingClientRect(e) { try { return e.getBoundingClientRect() } catch (t) { return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 } } } getTitle(e) { return e.title } setTitle(e, t) { e.title = t || "" } elementMatches(e, t) { return !!this.isElementNode(e) && (e.matches && e.matches(t) || e.msMatchesSelector && e.msMatchesSelector(t) || e.webkitMatchesSelector && e.webkitMatchesSelector(t)) } isTemplateElement(e) { return this.isElementNode(e) && "TEMPLATE" === e.nodeName } isTextNode(e) { return e.nodeType === Node.TEXT_NODE } isCommentNode(e) { return e.nodeType === Node.COMMENT_NODE } isElementNode(e) { return e.nodeType === Node.ELEMENT_NODE } hasShadowRoot(e) { return null != e.shadowRoot && e instanceof HTMLElement } isShadowRoot(e) { return e instanceof DocumentFragment } importIntoDoc(e) { return document.importNode(this.templateAwareRoot(e), !0) } adoptNode(e) { return document.adoptNode(e) } getHref(e) { return e.getAttribute("href") } getEventKey(e) { let t = e.key; if (null == t) { if (t = e.keyIdentifier, null == t) return "Unidentified"; t.startsWith("U+") && (t = String.fromCharCode(parseInt(t.substring(2), 16)), 3 === e.location && vl.hasOwnProperty(t) && (t = vl[t])) } return yl[t] || t } getGlobalEventTarget(e, t) { return "window" === t ? window : "document" === t ? e : "body" === t ? e.body : null } getHistory() { return window.history } getLocation() { return window.location } getBaseHref(e) { const t = Cl || (Cl = document.querySelector("base"), Cl) ? Cl.getAttribute("href") : null; return null == t ? null : (n = t, bl || (bl = document.createElement("a")), bl.setAttribute("href", n), "/" === bl.pathname.charAt(0) ? bl.pathname : "/" + bl.pathname); var n } resetBaseElement() { Cl = null } getUserAgent() { return window.navigator.userAgent } setData(e, t, n) { this.setAttribute(e, "data-" + t, n) } getData(e, t) { return this.getAttribute(e, "data-" + t) } getComputedStyle(e) { return getComputedStyle(e) } supportsWebAnimation() { return "function" == typeof Element.prototype.animate } performanceNow() { return window.performance && window.performance.now ? window.performance.now() : (new Date).getTime() } supportsCookies() { return !0 } getCookie(e) { return oa(document.cookie, e) } setCookie(e, t) { document.cookie = encodeURIComponent(e) + "=" + encodeURIComponent(t) } } let bl, Cl = null; function xl() { return !!window.history.pushState } const Sl = new _e("TRANSITION_ID"); function El(e, t, n) { return () => { n.get(fs).donePromise.then(() => { const n = gl(); Array.prototype.slice.apply(n.querySelectorAll(t, "style[ng-transition]")).filter(t => n.getAttribute(t, "ng-transition") === e).forEach(e => n.remove(e)) }) } } const Tl = [{ provide: ps, useFactory: El, deps: [Sl, va, _t], multi: !0 }]; class kl { static init() { var e; e = new kl, Qs = e } addToWindow(e) { we.getAngularTestability = (t, n = !0) => { const r = e.findTestabilityInTree(t, n); if (null == r) throw new Error("Could not find testability for element."); return r }, we.getAllAngularTestabilities = () => e.getAllTestabilities(), we.getAllAngularRootElements = () => e.getAllRootElements(), we.frameworkStabilizers || (we.frameworkStabilizers = []), we.frameworkStabilizers.push(e => { const t = we.getAllAngularTestabilities(); let n = t.length, r = !1; const s = function (t) { r = r || t, n--, 0 == n && e(r) }; t.forEach((function (e) { e.whenStable(s) })) }) } findTestabilityInTree(e, t, n) { if (null == t) return null; const r = e.getTestability(t); return null != r ? r : n ? gl().isShadowRoot(t) ? this.findTestabilityInTree(e, gl().getHost(t), !0) : this.findTestabilityInTree(e, gl().parentElement(t), !0) : null } } function Rl(e, t) { "undefined" != typeof COMPILED && COMPILED || ((we.ng = we.ng || {})[e] = t) } const Al = (() => ({ ApplicationRef: ti, NgZone: Ls }))(); function Il(e) { return di(e) } const Nl = new _e("EventManagerPlugins"); class Pl { constructor(e, t) { this._zone = t, this._eventNameToPlugin = new Map, e.forEach(e => e.manager = this), this._plugins = e.slice().reverse() } addEventListener(e, t, n) { return this._findPluginFor(t).addEventListener(e, t, n) } addGlobalEventListener(e, t, n) { return this._findPluginFor(t).addGlobalEventListener(e, t, n) } getZone() { return this._zone } _findPluginFor(e) { const t = this._eventNameToPlugin.get(e); if (t) return t; const n = this._plugins; for (let r = 0; r < n.length; r++) { const t = n[r]; if (t.supports(e)) return this._eventNameToPlugin.set(e, t), t } throw new Error(`No event manager plugin found for event ${e}`) } } class Ol { constructor(e) { this._doc = e } addGlobalEventListener(e, t, n) { const r = gl().getGlobalEventTarget(this._doc, e); if (!r) throw new Error(`Unsupported event target ${r} for event ${t}`); return this.addEventListener(r, t, n) } } class Dl { constructor() { this._stylesSet = new Set } addStyles(e) { const t = new Set; e.forEach(e => { this._stylesSet.has(e) || (this._stylesSet.add(e), t.add(e)) }), this.onStylesAdded(t) } onStylesAdded(e) { } getAllStyles() { return Array.from(this._stylesSet) } } class Ul extends Dl { constructor(e) { super(), this._doc = e, this._hostNodes = new Set, this._styleNodes = new Set, this._hostNodes.add(e.head) } _addStylesToHost(e, t) { e.forEach(e => { const n = this._doc.createElement("style"); n.textContent = e, this._styleNodes.add(t.appendChild(n)) }) } addHost(e) { this._addStylesToHost(this._stylesSet, e), this._hostNodes.add(e) } removeHost(e) { this._hostNodes.delete(e) } onStylesAdded(e) { this._hostNodes.forEach(t => this._addStylesToHost(e, t)) } ngOnDestroy() { this._styleNodes.forEach(e => gl().remove(e)) } } const Ml = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" }, Ll = /%COMP%/g; function jl(e, t, n) { for (let r = 0; r < t.length; r++) { let s = t[r]; Array.isArray(s) ? jl(e, s, n) : (s = s.replace(Ll, e), n.push(s)) } return n } function Vl(e) { return t => { !1 === e(t) && (t.preventDefault(), t.returnValue = !1) } } class Hl { constructor(e, t, n) { this.eventManager = e, this.sharedStylesHost = t, this.appId = n, this.rendererByCompId = new Map, this.defaultRenderer = new Fl(e) } createRenderer(e, t) { if (!e || !t) return this.defaultRenderer; switch (t.encapsulation) { case De.Emulated: { let n = this.rendererByCompId.get(t.id); return n || (n = new Bl(this.eventManager, this.sharedStylesHost, t, this.appId), this.rendererByCompId.set(t.id, n)), n.applyToHost(e), n } case De.Native: case De.ShadowDom: return new ql(this.eventManager, this.sharedStylesHost, e, t); default: if (!this.rendererByCompId.has(t.id)) { const e = jl(t.id, t.styles, []); this.sharedStylesHost.addStyles(e), this.rendererByCompId.set(t.id, this.defaultRenderer) } return this.defaultRenderer } } begin() { } end() { } } class Fl { constructor(e) { this.eventManager = e, this.data = Object.create(null) } destroy() { } createElement(e, t) { return t ? document.createElementNS(Ml[t] || t, e) : document.createElement(e) } createComment(e) { return document.createComment(e) } createText(e) { return document.createTextNode(e) } appendChild(e, t) { e.appendChild(t) } insertBefore(e, t, n) { e && e.insertBefore(t, n) } removeChild(e, t) { e && e.removeChild(t) } selectRootElement(e, t) { let n = "string" == typeof e ? document.querySelector(e) : e; if (!n) throw new Error(`The selector "${e}" did not match any elements`); return t || (n.textContent = ""), n } parentNode(e) { return e.parentNode } nextSibling(e) { return e.nextSibling } setAttribute(e, t, n, r) { if (r) { t = r + ":" + t; const s = Ml[r]; s ? e.setAttributeNS(s, t, n) : e.setAttribute(t, n) } else e.setAttribute(t, n) } removeAttribute(e, t, n) { if (n) { const r = Ml[n]; r ? e.removeAttributeNS(r, t) : e.removeAttribute(`${n}:${t}`) } else e.removeAttribute(t) } addClass(e, t) { e.classList.add(t) } removeClass(e, t) { e.classList.remove(t) } setStyle(e, t, n, r) { r & Jt.DashCase ? e.style.setProperty(t, n, r & Jt.Important ? "important" : "") : e.style[t] = n } removeStyle(e, t, n) { n & Jt.DashCase ? e.style.removeProperty(t) : e.style[t] = "" } setProperty(e, t, n) { zl(t, "property"), e[t] = n } setValue(e, t) { e.nodeValue = t } listen(e, t, n) { return zl(t, "listener"), "string" == typeof e ? this.eventManager.addGlobalEventListener(e, t, Vl(n)) : this.eventManager.addEventListener(e, t, Vl(n)) } } const $l = (() => "@".charCodeAt(0))(); function zl(e, t) { if (e.charCodeAt(0) === $l) throw new Error(`Found the synthetic ${t} ${e}. Please include either "BrowserAnimationsModule" or "NoopAnimationsModule" in your application.`) } class Bl extends Fl { constructor(e, t, n, r) { super(e), this.component = n; const s = jl(r + "-" + n.id, n.styles, []); t.addStyles(s), this.contentAttr = "_ngcontent-%COMP%".replace(Ll, r + "-" + n.id), this.hostAttr = function (e) { return "_nghost-%COMP%".replace(Ll, e) }(r + "-" + n.id) } applyToHost(e) { super.setAttribute(e, this.hostAttr, "") } createElement(e, t) { const n = super.createElement(e, t); return super.setAttribute(n, this.contentAttr, ""), n } } class ql extends Fl { constructor(e, t, n, r) { super(e), this.sharedStylesHost = t, this.hostEl = n, this.component = r, this.shadowRoot = r.encapsulation === De.ShadowDom ? n.attachShadow({ mode: "open" }) : n.createShadowRoot(), this.sharedStylesHost.addHost(this.shadowRoot); const s = jl(r.id, r.styles, []); for (let i = 0; i < s.length; i++) { const e = document.createElement("style"); e.textContent = s[i], this.shadowRoot.appendChild(e) } } nodeOrShadowRoot(e) { return e === this.hostEl ? this.shadowRoot : e } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } appendChild(e, t) { return super.appendChild(this.nodeOrShadowRoot(e), t) } insertBefore(e, t, n) { return super.insertBefore(this.nodeOrShadowRoot(e), t, n) } removeChild(e, t) { return super.removeChild(this.nodeOrShadowRoot(e), t) } parentNode(e) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(e))) } } const Wl = (() => "undefined" != typeof Zone && Zone.__symbol__ || function (e) { return "__zone_symbol__" + e })(), Zl = Wl("addEventListener"), Ql = Wl("removeEventListener"), Gl = {}, Kl = "__zone_symbol__propagationStopped", Jl = (() => { const e = "undefined" != typeof Zone && Zone[Wl("BLACK_LISTED_EVENTS")]; if (e) { const t = {}; return e.forEach(e => { t[e] = e }), t } })(), Yl = function (e) { return !!Jl && Jl.hasOwnProperty(e) }, Xl = function (e) { const t = Gl[e.type]; if (!t) return; const n = this[t]; if (!n) return; const r = [e]; if (1 === n.length) { const e = n[0]; return e.zone !== Zone.current ? e.zone.run(e.handler, this, r) : e.handler.apply(this, r) } { const t = n.slice(); for (let n = 0; n < t.length && !0 !== e[Kl]; n++) { const e = t[n]; e.zone !== Zone.current ? e.zone.run(e.handler, this, r) : e.handler.apply(this, r) } } }; class eu extends Ol { constructor(e, t, n) { super(e), this.ngZone = t, n && function (e) { return "server" === e }(n) || this.patchEvent() } patchEvent() { if ("undefined" == typeof Event || !Event || !Event.prototype) return; if (Event.prototype.__zone_symbol__stopImmediatePropagation) return; const e = Event.prototype.__zone_symbol__stopImmediatePropagation = Event.prototype.stopImmediatePropagation; Event.prototype.stopImmediatePropagation = function () { this && (this[Kl] = !0), e && e.apply(this, arguments) } } supports(e) { return !0 } addEventListener(e, t, n) { let r = n; if (!e[Zl] || Ls.isInAngularZone() && !Yl(t)) e.addEventListener(t, r, !1); else { let n = Gl[t]; n || (n = Gl[t] = Wl("ANGULAR" + t + "FALSE")); let s = e[n]; const i = s && s.length > 0; s || (s = e[n] = []); const o = Yl(t) ? Zone.root : Zone.current; if (0 === s.length) s.push({ zone: o, handler: r }); else { let e = !1; for (let t = 0; t < s.length; t++)if (s[t].handler === r) { e = !0; break } e || s.push({ zone: o, handler: r }) } i || e[Zl](t, Xl, !1) } return () => this.removeEventListener(e, t, r) } removeEventListener(e, t, n) { let r = e[Ql]; if (!r) return e.removeEventListener.apply(e, [t, n, !1]); let s = Gl[t], i = s && e[s]; if (!i) return e.removeEventListener.apply(e, [t, n, !1]); let o = !1; for (let a = 0; a < i.length; a++)if (i[a].handler === n) { o = !0, i.splice(a, 1); break } o ? 0 === i.length && r.apply(e, [t, Xl, !1]) : e.removeEventListener.apply(e, [t, n, !1]) } } const tu = { pan: !0, panstart: !0, panmove: !0, panend: !0, pancancel: !0, panleft: !0, panright: !0, panup: !0, pandown: !0, pinch: !0, pinchstart: !0, pinchmove: !0, pinchend: !0, pinchcancel: !0, pinchin: !0, pinchout: !0, press: !0, pressup: !0, rotate: !0, rotatestart: !0, rotatemove: !0, rotateend: !0, rotatecancel: !0, swipe: !0, swipeleft: !0, swiperight: !0, swipeup: !0, swipedown: !0, tap: !0 }, nu = new _e("HammerGestureConfig"), ru = new _e("HammerLoader"); class su { constructor() { this.events = [], this.overrides = {} } buildHammer(e) { const t = new Hammer(e, this.options); t.get("pinch").set({ enable: !0 }), t.get("rotate").set({ enable: !0 }); for (const n in this.overrides) t.get(n).set(this.overrides[n]); return t } } class iu extends Ol { constructor(e, t, n, r) { super(e), this._config = t, this.console = n, this.loader = r } supports(e) { return !(!tu.hasOwnProperty(e.toLowerCase()) && !this.isCustomEvent(e) || !window.Hammer && !this.loader && (this.console.warn(`The "${e}" event cannot be bound because Hammer.JS is not ` + "loaded and no custom loader has been specified."), 1)) } addEventListener(e, t, n) { const r = this.manager.getZone(); if (t = t.toLowerCase(), !window.Hammer && this.loader) { let r = !1, s = () => { r = !0 }; return this.loader().then(() => { if (!window.Hammer) return this.console.warn("The custom HAMMER_LOADER completed, but Hammer.JS is not present."), void (s = () => { }); r || (s = this.addEventListener(e, t, n)) }).catch(() => { this.console.warn(`The "${t}" event cannot be bound because the custom ` + "Hammer.JS loader failed."), s = () => { } }), () => { s() } } return r.runOutsideAngular(() => { const s = this._config.buildHammer(e), i = function (e) { r.runGuarded((function () { n(e) })) }; return s.on(t, i), () => { s.off(t, i), "function" == typeof s.destroy && s.destroy() } }) } isCustomEvent(e) { return this._config.events.indexOf(e) > -1 } } const ou = ["alt", "control", "meta", "shift"], au = { alt: e => e.altKey, control: e => e.ctrlKey, meta: e => e.metaKey, shift: e => e.shiftKey }; class lu extends Ol { constructor(e) { super(e) } supports(e) { return null != lu.parseEventName(e) } addEventListener(e, t, n) { const r = lu.parseEventName(t), s = lu.eventCallback(r.fullKey, n, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => gl().onAndCancel(e, r.domEventName, s)) } static parseEventName(e) { const t = e.toLowerCase().split("."), n = t.shift(); if (0 === t.length || "keydown" !== n && "keyup" !== n) return null; const r = lu._normalizeKey(t.pop()); let s = ""; if (ou.forEach(e => { const n = t.indexOf(e); n > -1 && (t.splice(n, 1), s += e + ".") }), s += r, 0 != t.length || 0 === r.length) return null; const i = {}; return i.domEventName = n, i.fullKey = s, i } static getEventFullKey(e) { let t = "", n = gl().getEventKey(e); return n = n.toLowerCase(), " " === n ? n = "space" : "." === n && (n = "dot"), ou.forEach(r => { r != n && (0, au[r])(e) && (t += r + ".") }), t += n, t } static eventCallback(e, t, n) { return r => { lu.getEventFullKey(r) === e && n.runGuarded(() => t(r)) } } static _normalizeKey(e) { switch (e) { case "esc": return "escape"; default: return e } } } class uu { } class cu extends uu { constructor(e) { super(), this._doc = e } sanitize(e, t) { if (null == t) return null; switch (e) { case ct.NONE: return t; case ct.HTML: return t instanceof du ? t.changingThisBreaksApplicationSecurity : (this.checkNotSafeValue(t, "HTML"), function (e, t) { let n = null; try { lt = lt || new ze(e); let r = t ? String(t) : ""; n = lt.getInertBodyElement(r); let s = 5, i = r; do { if (0 === s) throw new Error("Failed to sanitize html because the input is unstable"); s--, r = i, i = n.innerHTML, n = lt.getInertBodyElement(r) } while (r !== i); const o = new st, a = o.sanitizeChildren(ut(n) || n); return $e() && o.sanitizedSomething && console.warn("WARNING: sanitizing HTML stripped some content, see http://g.co/ng/security#xss"), a } finally { if (n) { const e = ut(n) || n; for (; e.firstChild;)e.removeChild(e.firstChild) } } }(this._doc, String(t))); case ct.STYLE: return t instanceof pu ? t.changingThisBreaksApplicationSecurity : (this.checkNotSafeValue(t, "Style"), function (e) { if (!(e = String(e).trim())) return ""; const t = e.match(pt); return t && We(t[1]) === t[1] || e.match(dt) && function (e) { let t = !0, n = !0; for (let r = 0; r < e.length; r++) { const s = e.charAt(r); "'" === s && n ? t = !t : '"' === s && t && (n = !n) } return t && n }(e) ? e : ($e() && console.warn(`WARNING: sanitizing unsafe style value ${e} (see http://g.co/ng/security#xss).`), "unsafe") }(t)); case ct.SCRIPT: if (t instanceof fu) return t.changingThisBreaksApplicationSecurity; throw this.checkNotSafeValue(t, "Script"), new Error("unsafe value used in a script context"); case ct.URL: return t instanceof mu || t instanceof gu ? t.changingThisBreaksApplicationSecurity : (this.checkNotSafeValue(t, "URL"), We(String(t))); case ct.RESOURCE_URL: if (t instanceof mu) return t.changingThisBreaksApplicationSecurity; throw this.checkNotSafeValue(t, "ResourceURL"), new Error("unsafe value used in a resource URL context (see http://g.co/ng/security#xss)"); default: throw new Error(`Unexpected SecurityContext ${e} (see http://g.co/ng/security#xss)`) } } checkNotSafeValue(e, t) { if (e instanceof hu) throw new Error(`Required a safe ${t}, got a ${e.getTypeName()} ` + "(see http://g.co/ng/security#xss)") } bypassSecurityTrustHtml(e) { return new du(e) } bypassSecurityTrustStyle(e) { return new pu(e) } bypassSecurityTrustScript(e) { return new fu(e) } bypassSecurityTrustUrl(e) { return new gu(e) } bypassSecurityTrustResourceUrl(e) { return new mu(e) } } class hu { constructor(e) { this.changingThisBreaksApplicationSecurity = e } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity}` + " (see http://g.co/ng/security#xss)" } } class du extends hu { getTypeName() { return "HTML" } } class pu extends hu { getTypeName() { return "Style" } } class fu extends hu { getTypeName() { return "Script" } } class gu extends hu { getTypeName() { return "URL" } } class mu extends hu { getTypeName() { return "ResourceURL" } } const yu = Js(fi, "browser", [{ provide: ys, useValue: "browser" }, { provide: ms, useValue: function () { _l.makeCurrent(), kl.init() }, multi: !0 }, { provide: Qo, useClass: class extends Qo { constructor(e) { super(), this._doc = e, this._init() } _init() { this.location = gl().getLocation(), this._history = gl().getHistory() } getBaseHrefFromDOM() { return gl().getBaseHref(this._doc) } onPopState(e) { gl().getGlobalEventTarget(this._doc, "window").addEventListener("popstate", e, !1) } onHashChange(e) { gl().getGlobalEventTarget(this._doc, "window").addEventListener("hashchange", e, !1) } get href() { return this.location.href } get protocol() { return this.location.protocol } get hostname() { return this.location.hostname } get port() { return this.location.port } get pathname() { return this.location.pathname } get search() { return this.location.search } get hash() { return this.location.hash } set pathname(e) { this.location.pathname = e } pushState(e, t, n) { xl() ? this._history.pushState(e, t, n) : this.location.hash = n } replaceState(e, t, n) { xl() ? this._history.replaceState(e, t, n) : this.location.hash = n } forward() { this._history.forward() } back() { this._history.back() } getState() { return this._history.state } }, deps: [va] }, { provide: va, useFactory: function () { return document }, deps: [] }]); function vu() { return new Ve } class wu { constructor(e) { if (e) throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.") } static withServerTransition(e) { return { ngModule: wu, providers: [{ provide: gs, useValue: e.appId }, { provide: Sl, useExisting: gs }, Tl] } } } "undefined" != typeof window && window; class _u { constructor(e, t) { this.id = e, this.url = t } } class bu extends _u { constructor(e, t, n = "imperative", r = null) { super(e, t), this.navigationTrigger = n, this.restoredState = r } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class Cu extends _u { constructor(e, t, n) { super(e, t), this.urlAfterRedirects = n } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } class xu extends _u { constructor(e, t, n) { super(e, t), this.reason = n } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class Su extends _u { constructor(e, t, n) { super(e, t), this.error = n } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class Eu extends _u { constructor(e, t, n, r) { super(e, t), this.urlAfterRedirects = n, this.state = r } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class Tu extends _u { constructor(e, t, n, r) { super(e, t), this.urlAfterRedirects = n, this.state = r } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class ku extends _u { constructor(e, t, n, r, s) { super(e, t), this.urlAfterRedirects = n, this.state = r, this.shouldActivate = s } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class Ru extends _u { constructor(e, t, n, r) { super(e, t), this.urlAfterRedirects = n, this.state = r } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class Au extends _u { constructor(e, t, n, r) { super(e, t), this.urlAfterRedirects = n, this.state = r } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class Iu { constructor(e) { this.route = e } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class Nu { constructor(e) { this.route = e } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class Pu { constructor(e) { this.snapshot = e } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class Ou { constructor(e) { this.snapshot = e } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class Du { constructor(e) { this.snapshot = e } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class Uu { constructor(e) { this.snapshot = e } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class Mu { constructor(e, t, n) { this.routerEvent = e, this.position = t, this.anchor = n } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')` } } class Lu { } class ju { constructor(e) { this.params = e || {} } has(e) { return this.params.hasOwnProperty(e) } get(e) { if (this.has(e)) { const t = this.params[e]; return Array.isArray(t) ? t[0] : t } return null } getAll(e) { if (this.has(e)) { const t = this.params[e]; return Array.isArray(t) ? t : [t] } return [] } get keys() { return Object.keys(this.params) } } function Vu(e) { return new ju(e) } function Hu(e) { const t = Error("NavigationCancelingError: " + e); return t.ngNavigationCancelingError = !0, t } function Fu(e, t, n) { const r = n.path.split("/"); if (r.length > e.length) return null; if ("full" === n.pathMatch && (t.hasChildren() || r.length < e.length)) return null; const s = {}; for (let i = 0; i < r.length; i++) { const t = r[i], n = e[i]; if (t.startsWith(":")) s[t.substring(1)] = n; else if (t !== n.path) return null } return { consumed: e.slice(0, r.length), posParams: s } } class $u { constructor(e, t) { this.routes = e, this.module = t } } function zu(e, t = "") { for (let n = 0; n < e.length; n++) { const r = e[n]; Bu(r, qu(t, r)) } } function Bu(e, t) { if (!e) throw new Error(`\n      Invalid configuration of route '${t}': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    `); if (Array.isArray(e)) throw new Error(`Invalid configuration of route '${t}': Array cannot be specified`); if (!e.component && !e.children && !e.loadChildren && e.outlet && "primary" !== e.outlet) throw new Error(`Invalid configuration of route '${t}': a componentless route without children or loadChildren cannot have a named outlet set`); if (e.redirectTo && e.children) throw new Error(`Invalid configuration of route '${t}': redirectTo and children cannot be used together`); if (e.redirectTo && e.loadChildren) throw new Error(`Invalid configuration of route '${t}': redirectTo and loadChildren cannot be used together`); if (e.children && e.loadChildren) throw new Error(`Invalid configuration of route '${t}': children and loadChildren cannot be used together`); if (e.redirectTo && e.component) throw new Error(`Invalid configuration of route '${t}': redirectTo and component cannot be used together`); if (e.path && e.matcher) throw new Error(`Invalid configuration of route '${t}': path and matcher cannot be used together`); if (void 0 === e.redirectTo && !e.component && !e.children && !e.loadChildren) throw new Error(`Invalid configuration of route '${t}'. One of the following must be provided: component, redirectTo, children or loadChildren`); if (void 0 === e.path && void 0 === e.matcher) throw new Error(`Invalid configuration of route '${t}': routes must have either a path or a matcher specified`); if ("string" == typeof e.path && "/" === e.path.charAt(0)) throw new Error(`Invalid configuration of route '${t}': path cannot start with a slash`); if ("" === e.path && void 0 !== e.redirectTo && void 0 === e.pathMatch) throw new Error(`Invalid configuration of route '{path: "${t}", redirectTo: "${e.redirectTo}"}': please provide 'pathMatch'. The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`); if (void 0 !== e.pathMatch && "full" !== e.pathMatch && "prefix" !== e.pathMatch) throw new Error(`Invalid configuration of route '${t}': pathMatch can only be set to 'prefix' or 'full'`); e.children && zu(e.children, t) } function qu(e, t) { return t ? e || t.path ? e && !t.path ? `${e}/` : !e && t.path ? t.path : `${e}/${t.path}` : "" : e } function Wu(e) { const t = e.children && e.children.map(Wu), n = t ? Object.assign({}, e, { children: t }) : Object.assign({}, e); return !n.component && (t || n.loadChildren) && n.outlet && "primary" !== n.outlet && (n.component = Lu), n } function Zu(e, t) { const n = Object.keys(e), r = Object.keys(t); if (!n || !r || n.length != r.length) return !1; let s; for (let i = 0; i < n.length; i++)if (s = n[i], e[s] !== t[s]) return !1; return !0 } function Qu(e) { return Array.prototype.concat.apply([], e) } function Gu(e) { return e.length > 0 ? e[e.length - 1] : null } function Ku(e, t) { for (const n in e) e.hasOwnProperty(n) && t(e[n], n) } function Ju(e) { return Lt(e) ? e : Mt(e) ? F(Promise.resolve(e)) : ba(e) } function Yu(e, t, n) { return n ? function (e, t) { return Zu(e, t) }(e.queryParams, t.queryParams) && function e(t, n) { if (!nc(t.segments, n.segments)) return !1; if (t.numberOfChildren !== n.numberOfChildren) return !1; for (const r in n.children) { if (!t.children[r]) return !1; if (!e(t.children[r], n.children[r])) return !1 } return !0 }(e.root, t.root) : function (e, t) { return Object.keys(t).length <= Object.keys(e).length && Object.keys(t).every(n => t[n] === e[n]) }(e.queryParams, t.queryParams) && function e(t, n) { return function t(n, r, s) { if (n.segments.length > s.length) return !!nc(n.segments.slice(0, s.length), s) && !r.hasChildren(); if (n.segments.length === s.length) { if (!nc(n.segments, s)) return !1; for (const t in r.children) { if (!n.children[t]) return !1; if (!e(n.children[t], r.children[t])) return !1 } return !0 } { const e = s.slice(0, n.segments.length), i = s.slice(n.segments.length); return !!nc(n.segments, e) && !!n.children.primary && t(n.children.primary, r, i) } }(t, n, n.segments) }(e.root, t.root) } class Xu { constructor(e, t, n) { this.root = e, this.queryParams = t, this.fragment = n } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Vu(this.queryParams)), this._queryParamMap } toString() { return oc.serialize(this) } } class ec { constructor(e, t) { this.segments = e, this.children = t, this.parent = null, Ku(t, (e, t) => e.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return ac(this) } } class tc { constructor(e, t) { this.path = e, this.parameters = t } get parameterMap() { return this._parameterMap || (this._parameterMap = Vu(this.parameters)), this._parameterMap } toString() { return pc(this) } } function nc(e, t) { return e.length === t.length && e.every((e, n) => e.path === t[n].path) } function rc(e, t) { let n = []; return Ku(e.children, (e, r) => { "primary" === r && (n = n.concat(t(e, r))) }), Ku(e.children, (e, r) => { "primary" !== r && (n = n.concat(t(e, r))) }), n } class sc { } class ic { parse(e) { const t = new vc(e); return new Xu(t.parseRootSegment(), t.parseQueryParams(), t.parseFragment()) } serialize(e) { var t; return `${`/${function e(t, n) { if (!t.hasChildren()) return ac(t); if (n) { const n = t.children.primary ? e(t.children.primary, !1) : "", r = []; return Ku(t.children, (t, n) => { "primary" !== n && r.push(`${n}:${e(t, !1)}`) }), r.length > 0 ? `${n}(${r.join("//")})` : n } { const n = rc(t, (n, r) => "primary" === r ? [e(t.children.primary, !1)] : [`${r}:${e(n, !1)}`]); return `${ac(t)}/(${n.join("//")})` } }(e.root, !0)}`}${function (e) { const t = Object.keys(e).map(t => { const n = e[t]; return Array.isArray(n) ? n.map(e => `${uc(t)}=${uc(e)}`).join("&") : `${uc(t)}=${uc(n)}` }); return t.length ? `?${t.join("&")}` : "" }(e.queryParams)}${"string" == typeof e.fragment ? `#${t = e.fragment, encodeURI(t)}` : ""}` } } const oc = new ic; function ac(e) { return e.segments.map(e => pc(e)).join("/") } function lc(e) { return encodeURIComponent(e).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function uc(e) { return lc(e).replace(/%3B/gi, ";") } function cc(e) { return lc(e).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function hc(e) { return decodeURIComponent(e) } function dc(e) { return hc(e.replace(/\+/g, "%20")) } function pc(e) { return `${cc(e.path)}${t = e.parameters, Object.keys(t).map(e => `;${cc(e)}=${cc(t[e])}`).join("")}`; var t } const fc = /^[^\/()?;=#]+/; function gc(e) { const t = e.match(fc); return t ? t[0] : "" } const mc = /^[^=?&#]+/, yc = /^[^?&#]+/; class vc { constructor(e) { this.url = e, this.remaining = e } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new ec([], {}) : new ec([], this.parseChildren()) } parseQueryParams() { const e = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(e) } while (this.consumeOptional("&")); return e } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const e = []; for (this.peekStartsWith("(") || e.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), e.push(this.parseSegment()); let t = {}; this.peekStartsWith("/(") && (this.capture("/"), t = this.parseParens(!0)); let n = {}; return this.peekStartsWith("(") && (n = this.parseParens(!1)), (e.length > 0 || Object.keys(t).length > 0) && (n.primary = new ec(e, t)), n } parseSegment() { const e = gc(this.remaining); if ("" === e && this.peekStartsWith(";")) throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`); return this.capture(e), new tc(hc(e), this.parseMatrixParams()) } parseMatrixParams() { const e = {}; for (; this.consumeOptional(";");)this.parseParam(e); return e } parseParam(e) { const t = gc(this.remaining); if (!t) return; this.capture(t); let n = ""; if (this.consumeOptional("=")) { const e = gc(this.remaining); e && (n = e, this.capture(n)) } e[hc(t)] = hc(n) } parseQueryParam(e) { const t = function (e) { const t = e.match(mc); return t ? t[0] : "" }(this.remaining); if (!t) return; this.capture(t); let n = ""; if (this.consumeOptional("=")) { const e = function (e) { const t = e.match(yc); return t ? t[0] : "" }(this.remaining); e && (n = e, this.capture(n)) } const r = dc(t), s = dc(n); if (e.hasOwnProperty(r)) { let t = e[r]; Array.isArray(t) || (t = [t], e[r] = t), t.push(s) } else e[r] = s } parseParens(e) { const t = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const n = gc(this.remaining), r = this.remaining[n.length]; if ("/" !== r && ")" !== r && ";" !== r) throw new Error(`Cannot parse url '${this.url}'`); let s = void 0; n.indexOf(":") > -1 ? (s = n.substr(0, n.indexOf(":")), this.capture(s), this.capture(":")) : e && (s = "primary"); const i = this.parseChildren(); t[s] = 1 === Object.keys(i).length ? i.primary : new ec([], i), this.consumeOptional("//") } return t } peekStartsWith(e) { return this.remaining.startsWith(e) } consumeOptional(e) { return !!this.peekStartsWith(e) && (this.remaining = this.remaining.substring(e.length), !0) } capture(e) { if (!this.consumeOptional(e)) throw new Error(`Expected "${e}".`) } } class wc { constructor(e) { this._root = e } get root() { return this._root.value } parent(e) { const t = this.pathFromRoot(e); return t.length > 1 ? t[t.length - 2] : null } children(e) { const t = _c(e, this._root); return t ? t.children.map(e => e.value) : [] } firstChild(e) { const t = _c(e, this._root); return t && t.children.length > 0 ? t.children[0].value : null } siblings(e) { const t = bc(e, this._root); return t.length < 2 ? [] : t[t.length - 2].children.map(e => e.value).filter(t => t !== e) } pathFromRoot(e) { return bc(e, this._root).map(e => e.value) } } function _c(e, t) { if (e === t.value) return t; for (const n of t.children) { const t = _c(e, n); if (t) return t } return null } function bc(e, t) { if (e === t.value) return [t]; for (const n of t.children) { const r = bc(e, n); if (r.length) return r.unshift(t), r } return [] } class Cc { constructor(e, t) { this.value = e, this.children = t } toString() { return `TreeNode(${this.value})` } } function xc(e) { const t = {}; return e && e.children.forEach(e => t[e.value.outlet] = e), t } class Sc extends wc { constructor(e, t) { super(e), this.snapshot = t, Ic(this, e) } toString() { return this.snapshot.toString() } } function Ec(e, t) { const n = function (e, t) { const n = new Rc([], {}, {}, "", {}, "primary", t, null, e.root, -1, {}); return new Ac("", new Cc(n, [])) }(e, t), r = new Ca([new tc("", {})]), s = new Ca({}), i = new Ca({}), o = new Ca({}), a = new Ca(""), l = new Tc(r, s, o, a, i, "primary", t, n.root); return l.snapshot = n.root, new Sc(new Cc(l, []), n) } class Tc { constructor(e, t, n, r, s, i, o, a) { this.url = e, this.params = t, this.queryParams = n, this.fragment = r, this.data = s, this.outlet = i, this.component = o, this._futureSnapshot = a } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe(L(e => Vu(e)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe(L(e => Vu(e)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } } function kc(e, t = "emptyOnly") { const n = e.pathFromRoot; let r = 0; if ("always" !== t) for (r = n.length - 1; r >= 1;) { const e = n[r], t = n[r - 1]; if (e.routeConfig && "" === e.routeConfig.path) r--; else { if (t.component) break; r-- } } return function (e) { return e.reduce((e, t) => ({ params: Object.assign({}, e.params, t.params), data: Object.assign({}, e.data, t.data), resolve: Object.assign({}, e.resolve, t._resolvedData) }), { params: {}, data: {}, resolve: {} }) }(n.slice(r)) } class Rc { constructor(e, t, n, r, s, i, o, a, l, u, c) { this.url = e, this.params = t, this.queryParams = n, this.fragment = r, this.data = s, this.outlet = i, this.component = o, this.routeConfig = a, this._urlSegment = l, this._lastPathIndex = u, this._resolve = c } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = Vu(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Vu(this.queryParams)), this._queryParamMap } toString() { return `Route(url:'${this.url.map(e => e.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')` } } class Ac extends wc { constructor(e, t) { super(t), this.url = e, Ic(this, t) } toString() { return Nc(this._root) } } function Ic(e, t) { t.value._routerState = e, t.children.forEach(t => Ic(e, t)) } function Nc(e) { const t = e.children.length > 0 ? ` { ${e.children.map(Nc).join(", ")} } ` : ""; return `${e.value}${t}` } function Pc(e) { if (e.snapshot) { const t = e.snapshot, n = e._futureSnapshot; e.snapshot = n, Zu(t.queryParams, n.queryParams) || e.queryParams.next(n.queryParams), t.fragment !== n.fragment && e.fragment.next(n.fragment), Zu(t.params, n.params) || e.params.next(n.params), function (e, t) { if (e.length !== t.length) return !1; for (let n = 0; n < e.length; ++n)if (!Zu(e[n], t[n])) return !1; return !0 }(t.url, n.url) || e.url.next(n.url), Zu(t.data, n.data) || e.data.next(n.data) } else e.snapshot = e._futureSnapshot, e.data.next(e._futureSnapshot.data) } function Oc(e, t) { var n, r; return Zu(e.params, t.params) && nc(n = e.url, r = t.url) && n.every((e, t) => Zu(e.parameters, r[t].parameters)) && !(!e.parent != !t.parent) && (!e.parent || Oc(e.parent, t.parent)) } function Dc(e) { return "object" == typeof e && null != e && !e.outlets && !e.segmentPath } function Uc(e, t, n, r, s) { let i = {}; return r && Ku(r, (e, t) => { i[t] = Array.isArray(e) ? e.map(e => `${e}`) : `${e}` }), new Xu(n.root === e ? t : function e(t, n, r) { const s = {}; return Ku(t.children, (t, i) => { s[i] = t === n ? r : e(t, n, r) }), new ec(t.segments, s) }(n.root, e, t), i, s) } class Mc { constructor(e, t, n) { if (this.isAbsolute = e, this.numberOfDoubleDots = t, this.commands = n, e && n.length > 0 && Dc(n[0])) throw new Error("Root segment cannot have matrix parameters"); const r = n.find(e => "object" == typeof e && null != e && e.outlets); if (r && r !== Gu(n)) throw new Error("{outlets:{}} has to be the last command") } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class Lc { constructor(e, t, n) { this.segmentGroup = e, this.processChildren = t, this.index = n } } function jc(e) { return "object" == typeof e && null != e && e.outlets ? e.outlets.primary : `${e}` } function Vc(e, t, n) { if (e || (e = new ec([], {})), 0 === e.segments.length && e.hasChildren()) return Hc(e, t, n); const r = function (e, t, n) { let r = 0, s = t; const i = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; s < e.segments.length;) { if (r >= n.length) return i; const t = e.segments[s], o = jc(n[r]), a = r < n.length - 1 ? n[r + 1] : null; if (s > 0 && void 0 === o) break; if (o && a && "object" == typeof a && void 0 === a.outlets) { if (!Bc(o, a, t)) return i; r += 2 } else { if (!Bc(o, {}, t)) return i; r++ } s++ } return { match: !0, pathIndex: s, commandIndex: r } }(e, t, n), s = n.slice(r.commandIndex); if (r.match && r.pathIndex < e.segments.length) { const t = new ec(e.segments.slice(0, r.pathIndex), {}); return t.children.primary = new ec(e.segments.slice(r.pathIndex), e.children), Hc(t, 0, s) } return r.match && 0 === s.length ? new ec(e.segments, {}) : r.match && !e.hasChildren() ? Fc(e, t, n) : r.match ? Hc(e, 0, s) : Fc(e, t, n) } function Hc(e, t, n) { if (0 === n.length) return new ec(e.segments, {}); { const r = function (e) { return "object" != typeof e[0] ? { primary: e } : void 0 === e[0].outlets ? { primary: e } : e[0].outlets }(n), s = {}; return Ku(r, (n, r) => { null !== n && (s[r] = Vc(e.children[r], t, n)) }), Ku(e.children, (e, t) => { void 0 === r[t] && (s[t] = e) }), new ec(e.segments, s) } } function Fc(e, t, n) { const r = e.segments.slice(0, t); let s = 0; for (; s < n.length;) { if ("object" == typeof n[s] && void 0 !== n[s].outlets) { const e = $c(n[s].outlets); return new ec(r, e) } if (0 === s && Dc(n[0])) { r.push(new tc(e.segments[t].path, n[0])), s++; continue } const i = jc(n[s]), o = s < n.length - 1 ? n[s + 1] : null; i && o && Dc(o) ? (r.push(new tc(i, zc(o))), s += 2) : (r.push(new tc(i, {})), s++) } return new ec(r, {}) } function $c(e) { const t = {}; return Ku(e, (e, n) => { null !== e && (t[n] = Fc(new ec([], {}), 0, e)) }), t } function zc(e) { const t = {}; return Ku(e, (e, n) => t[n] = `${e}`), t } function Bc(e, t, n) { return e == n.path && Zu(t, n.parameters) } class qc { constructor(e, t, n, r) { this.routeReuseStrategy = e, this.futureState = t, this.currState = n, this.forwardEvent = r } activate(e) { const t = this.futureState._root, n = this.currState ? this.currState._root : null; this.deactivateChildRoutes(t, n, e), Pc(this.futureState.root), this.activateChildRoutes(t, n, e) } deactivateChildRoutes(e, t, n) { const r = xc(t); e.children.forEach(e => { const t = e.value.outlet; this.deactivateRoutes(e, r[t], n), delete r[t] }), Ku(r, (e, t) => { this.deactivateRouteAndItsChildren(e, n) }) } deactivateRoutes(e, t, n) { const r = e.value, s = t ? t.value : null; if (r === s) if (r.component) { const s = n.getContext(r.outlet); s && this.deactivateChildRoutes(e, t, s.children) } else this.deactivateChildRoutes(e, t, n); else s && this.deactivateRouteAndItsChildren(t, n) } deactivateRouteAndItsChildren(e, t) { this.routeReuseStrategy.shouldDetach(e.value.snapshot) ? this.detachAndStoreRouteSubtree(e, t) : this.deactivateRouteAndOutlet(e, t) } detachAndStoreRouteSubtree(e, t) { const n = t.getContext(e.value.outlet); if (n && n.outlet) { const t = n.outlet.detach(), r = n.children.onOutletDeactivated(); this.routeReuseStrategy.store(e.value.snapshot, { componentRef: t, route: e, contexts: r }) } } deactivateRouteAndOutlet(e, t) { const n = t.getContext(e.value.outlet); if (n) { const r = xc(e), s = e.value.component ? n.children : t; Ku(r, (e, t) => this.deactivateRouteAndItsChildren(e, s)), n.outlet && (n.outlet.deactivate(), n.children.onOutletDeactivated()) } } activateChildRoutes(e, t, n) { const r = xc(t); e.children.forEach(e => { this.activateRoutes(e, r[e.value.outlet], n), this.forwardEvent(new Uu(e.value.snapshot)) }), e.children.length && this.forwardEvent(new Ou(e.value.snapshot)) } activateRoutes(e, t, n) { const r = e.value, s = t ? t.value : null; if (Pc(r), r === s) if (r.component) { const s = n.getOrCreateContext(r.outlet); this.activateChildRoutes(e, t, s.children) } else this.activateChildRoutes(e, t, n); else if (r.component) { const t = n.getOrCreateContext(r.outlet); if (this.routeReuseStrategy.shouldAttach(r.snapshot)) { const e = this.routeReuseStrategy.retrieve(r.snapshot); this.routeReuseStrategy.store(r.snapshot, null), t.children.onOutletReAttached(e.contexts), t.attachRef = e.componentRef, t.route = e.route.value, t.outlet && t.outlet.attach(e.componentRef, e.route.value), Wc(e.route) } else { const n = function (e) { for (let t = e.parent; t; t = t.parent) { const e = t.routeConfig; if (e && e._loadedConfig) return e._loadedConfig; if (e && e.component) return null } return null }(r.snapshot), s = n ? n.module.componentFactoryResolver : null; t.attachRef = null, t.route = r, t.resolver = s, t.outlet && t.outlet.activateWith(r, s), this.activateChildRoutes(e, null, t.children) } } else this.activateChildRoutes(e, null, n) } } function Wc(e) { Pc(e.value), e.children.forEach(Wc) } function Zc(e) { return "function" == typeof e } function Qc(e) { return e instanceof Xu } class Gc { constructor(e) { this.segmentGroup = e || null } } class Kc { constructor(e) { this.urlTree = e } } function Jc(e) { return new _(t => t.error(new Gc(e))) } function Yc(e) { return new _(t => t.error(new Kc(e))) } function Xc(e) { return new _(t => t.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${e}'`))) } class eh { constructor(e, t, n, r, s) { this.configLoader = t, this.urlSerializer = n, this.urlTree = r, this.config = s, this.allowRedirects = !0, this.ngModule = e.get(Ie) } apply() { return this.expandSegmentGroup(this.ngModule, this.config, this.urlTree.root, "primary").pipe(L(e => this.createUrlTree(e, this.urlTree.queryParams, this.urlTree.fragment))).pipe(Wa(e => { if (e instanceof Kc) return this.allowRedirects = !1, this.match(e.urlTree); if (e instanceof Gc) throw this.noMatchError(e); throw e })) } match(e) { return this.expandSegmentGroup(this.ngModule, this.config, e.root, "primary").pipe(L(t => this.createUrlTree(t, e.queryParams, e.fragment))).pipe(Wa(e => { if (e instanceof Gc) throw this.noMatchError(e); throw e })) } noMatchError(e) { return new Error(`Cannot match any routes. URL Segment: '${e.segmentGroup}'`) } createUrlTree(e, t, n) { const r = e.segments.length > 0 ? new ec([], { primary: e }) : e; return new Xu(r, t, n) } expandSegmentGroup(e, t, n, r) { return 0 === n.segments.length && n.hasChildren() ? this.expandChildren(e, t, n).pipe(L(e => new ec([], e))) : this.expandSegment(e, n, t, n.segments, r, !0) } expandChildren(e, t, n) { return function (e, t) { if (0 === Object.keys(e).length) return ba({}); const n = [], r = [], s = {}; return Ku(e, (e, i) => { const o = t(i, e).pipe(L(e => s[i] = e)); "primary" === i ? n.push(o) : r.push(o) }), ba.apply(null, n.concat(r)).pipe(Ia(), qa(), L(() => s)) }(n.children, (n, r) => this.expandSegmentGroup(e, t, r, n)) } expandSegment(e, t, n, r, s, i) { return ba(...n).pipe(L(o => this.expandSegmentAgainstRoute(e, t, n, o, r, s, i).pipe(Wa(e => { if (e instanceof Gc) return ba(null); throw e }))), Ia(), Ya(e => !!e), Wa((e, n) => { if (e instanceof xa || "EmptyError" === e.name) { if (this.noLeftoversInUrl(t, r, s)) return ba(new ec([], {})); throw new Gc(t) } throw e })) } noLeftoversInUrl(e, t, n) { return 0 === t.length && !e.children[n] } expandSegmentAgainstRoute(e, t, n, r, s, i, o) { return sh(r) !== i ? Jc(t) : void 0 === r.redirectTo ? this.matchSegmentAgainstRoute(e, t, r, s) : o && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(e, t, n, r, s, i) : Jc(t) } expandSegmentAgainstRouteUsingRedirect(e, t, n, r, s, i) { return "**" === r.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(e, n, r, i) : this.expandRegularSegmentAgainstRouteUsingRedirect(e, t, n, r, s, i) } expandWildCardWithParamsAgainstRouteUsingRedirect(e, t, n, r) { const s = this.applyRedirectCommands([], n.redirectTo, {}); return n.redirectTo.startsWith("/") ? Yc(s) : this.lineralizeSegments(n, s).pipe($(n => { const s = new ec(n, {}); return this.expandSegment(e, s, t, n, r, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(e, t, n, r, s, i) { const { matched: o, consumedSegments: a, lastChild: l, positionalParamSegments: u } = th(t, r, s); if (!o) return Jc(t); const c = this.applyRedirectCommands(a, r.redirectTo, u); return r.redirectTo.startsWith("/") ? Yc(c) : this.lineralizeSegments(r, c).pipe($(r => this.expandSegment(e, t, n, r.concat(s.slice(l)), i, !1))) } matchSegmentAgainstRoute(e, t, n, r) { if ("**" === n.path) return n.loadChildren ? this.configLoader.load(e.injector, n).pipe(L(e => (n._loadedConfig = e, new ec(r, {})))) : ba(new ec(r, {})); const { matched: s, consumedSegments: i, lastChild: o } = th(t, n, r); if (!s) return Jc(t); const a = r.slice(o); return this.getChildConfig(e, n, r).pipe($(e => { const n = e.module, r = e.routes, { segmentGroup: s, slicedSegments: o } = function (e, t, n, r) { return n.length > 0 && function (e, t, n) { return n.some(n => rh(e, t, n) && "primary" !== sh(n)) }(e, n, r) ? { segmentGroup: nh(new ec(t, function (e, t) { const n = {}; n.primary = t; for (const r of e) "" === r.path && "primary" !== sh(r) && (n[sh(r)] = new ec([], {})); return n }(r, new ec(n, e.children)))), slicedSegments: [] } : 0 === n.length && function (e, t, n) { return n.some(n => rh(e, t, n)) }(e, n, r) ? { segmentGroup: nh(new ec(e.segments, function (e, t, n, r) { const s = {}; for (const i of n) rh(e, t, i) && !r[sh(i)] && (s[sh(i)] = new ec([], {})); return Object.assign({}, r, s) }(e, n, r, e.children))), slicedSegments: n } : { segmentGroup: e, slicedSegments: n } }(t, i, a, r); return 0 === o.length && s.hasChildren() ? this.expandChildren(n, r, s).pipe(L(e => new ec(i, e))) : 0 === r.length && 0 === o.length ? ba(new ec(i, {})) : this.expandSegment(n, s, r, o, "primary", !0).pipe(L(e => new ec(i.concat(e.segments), e.children))) })) } getChildConfig(e, t, n) { return t.children ? ba(new $u(t.children, e)) : t.loadChildren ? void 0 !== t._loadedConfig ? ba(t._loadedConfig) : function (e, t, n) { const r = t.canLoad; return r && 0 !== r.length ? F(r).pipe(L(r => { const s = e.get(r); let i; if (function (e) { return e && Zc(e.canLoad) }(s)) i = s.canLoad(t, n); else { if (!Zc(s)) throw new Error("Invalid CanLoad guard"); i = s(t, n) } return Ju(i) })).pipe(Ia(), (s = e => !0 === e, e => e.lift(new Xa(s, void 0, e)))) : ba(!0); var s }(e.injector, t, n).pipe($(n => n ? this.configLoader.load(e.injector, t).pipe(L(e => (t._loadedConfig = e, e))) : function (e) { return new _(t => t.error(Hu(`Cannot load children because the guard of the route "path: '${e.path}'" returned false`))) }(t))) : ba(new $u([], e)) } lineralizeSegments(e, t) { let n = [], r = t.root; for (; ;) { if (n = n.concat(r.segments), 0 === r.numberOfChildren) return ba(n); if (r.numberOfChildren > 1 || !r.children.primary) return Xc(e.redirectTo); r = r.children.primary } } applyRedirectCommands(e, t, n) { return this.applyRedirectCreatreUrlTree(t, this.urlSerializer.parse(t), e, n) } applyRedirectCreatreUrlTree(e, t, n, r) { const s = this.createSegmentGroup(e, t.root, n, r); return new Xu(s, this.createQueryParams(t.queryParams, this.urlTree.queryParams), t.fragment) } createQueryParams(e, t) { const n = {}; return Ku(e, (e, r) => { if ("string" == typeof e && e.startsWith(":")) { const s = e.substring(1); n[r] = t[s] } else n[r] = e }), n } createSegmentGroup(e, t, n, r) { const s = this.createSegments(e, t.segments, n, r); let i = {}; return Ku(t.children, (t, s) => { i[s] = this.createSegmentGroup(e, t, n, r) }), new ec(s, i) } createSegments(e, t, n, r) { return t.map(t => t.path.startsWith(":") ? this.findPosParam(e, t, r) : this.findOrReturn(t, n)) } findPosParam(e, t, n) { const r = n[t.path.substring(1)]; if (!r) throw new Error(`Cannot redirect to '${e}'. Cannot find '${t.path}'.`); return r } findOrReturn(e, t) { let n = 0; for (const r of t) { if (r.path === e.path) return t.splice(n), r; n++ } return e } } function th(e, t, n) { if ("" === t.path) return "full" === t.pathMatch && (e.hasChildren() || n.length > 0) ? { matched: !1, consumedSegments: [], lastChild: 0, positionalParamSegments: {} } : { matched: !0, consumedSegments: [], lastChild: 0, positionalParamSegments: {} }; const r = (t.matcher || Fu)(n, e, t); return r ? { matched: !0, consumedSegments: r.consumed, lastChild: r.consumed.length, positionalParamSegments: r.posParams } : { matched: !1, consumedSegments: [], lastChild: 0, positionalParamSegments: {} } } function nh(e) { if (1 === e.numberOfChildren && e.children.primary) { const t = e.children.primary; return new ec(e.segments.concat(t.segments), t.children) } return e } function rh(e, t, n) { return (!(e.hasChildren() || t.length > 0) || "full" !== n.pathMatch) && "" === n.path && void 0 !== n.redirectTo } function sh(e) { return e.outlet || "primary" } class ih { constructor(e) { this.path = e, this.route = this.path[this.path.length - 1] } } class oh { constructor(e, t) { this.component = e, this.route = t } } function ah(e, t, n) { const r = e._root; return function e(t, n, r, s, i = { canDeactivateChecks: [], canActivateChecks: [] }) { const o = xc(n); return t.children.forEach(t => { !function (t, n, r, s, i = { canDeactivateChecks: [], canActivateChecks: [] }) { const o = t.value, a = n ? n.value : null, l = r ? r.getContext(t.value.outlet) : null; if (a && o.routeConfig === a.routeConfig) { const u = function (e, t, n) { if ("function" == typeof n) return n(e, t); switch (n) { case "pathParamsChange": return !nc(e.url, t.url); case "pathParamsOrQueryParamsChange": return !nc(e.url, t.url) || !Zu(e.queryParams, t.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !Oc(e, t) || !Zu(e.queryParams, t.queryParams); case "paramsChange": default: return !Oc(e, t) } }(a, o, o.routeConfig.runGuardsAndResolvers); u ? i.canActivateChecks.push(new ih(s)) : (o.data = a.data, o._resolvedData = a._resolvedData), e(t, n, o.component ? l ? l.children : null : r, s, i), u && i.canDeactivateChecks.push(new oh(l && l.outlet && l.outlet.component || null, a)) } else a && uh(n, l, i), i.canActivateChecks.push(new ih(s)), e(t, null, o.component ? l ? l.children : null : r, s, i) }(t, o[t.value.outlet], r, s.concat([t.value]), i), delete o[t.value.outlet] }), Ku(o, (e, t) => uh(e, r.getContext(t), i)), i }(r, t ? t._root : null, n, [r.value]) } function lh(e, t, n) { const r = function (e) { if (!e) return null; for (let t = e.parent; t; t = t.parent) { const e = t.routeConfig; if (e && e._loadedConfig) return e._loadedConfig } return null }(t); return (r ? r.module.injector : n).get(e) } function uh(e, t, n) { const r = xc(e), s = e.value; Ku(r, (e, r) => { uh(e, s.component ? t ? t.children.getContext(r) : null : t, n) }), n.canDeactivateChecks.push(new oh(s.component && t && t.outlet && t.outlet.isActivated ? t.outlet.component : null, s)) } const ch = Symbol("INITIAL_VALUE"); function hh() { return tl(e => function (...e) { let t = null, n = null; return k(e[e.length - 1]) && (n = e.pop()), "function" == typeof e[e.length - 1] && (t = e.pop()), 1 === e.length && l(e[0]) && (e = e[0]), Z(e, n).lift(new Ea(t)) }(...e.map(e => e.pipe(Ga(1), function (...e) { const t = e[e.length - 1]; return k(t) ? (e.pop(), n => sl(e, n, t)) : t => sl(e, t) }(ch)))).pipe(il((e, t) => { let n = !1; return t.reduce((e, r, s) => { if (e !== ch) return e; if (r === ch && (n = !0), !n) { if (!1 === r) return r; if (s === t.length - 1 || Qc(r)) return r } return e }, e) }, ch), Na(e => e !== ch), L(e => Qc(e) ? e : !0 === e), Ga(1))) } function dh(e, t) { return null !== e && t && t(new Du(e)), ba(!0) } function ph(e, t) { return null !== e && t && t(new Pu(e)), ba(!0) } function fh(e, t, n) { const r = t.routeConfig ? t.routeConfig.canActivate : null; return r && 0 !== r.length ? ba(r.map(r => Aa(() => { const s = lh(r, t, n); let i; if (function (e) { return e && Zc(e.canActivate) }(s)) i = Ju(s.canActivate(t, e)); else { if (!Zc(s)) throw new Error("Invalid CanActivate guard"); i = Ju(s(t, e)) } return i.pipe(Ya()) }))).pipe(hh()) : ba(!0) } function gh(e, t, n) { const r = t[t.length - 1], s = t.slice(0, t.length - 1).reverse().map(e => function (e) { const t = e.routeConfig ? e.routeConfig.canActivateChild : null; return t && 0 !== t.length ? { node: e, guards: t } : null }(e)).filter(e => null !== e).map(t => Aa(() => ba(t.guards.map(s => { const i = lh(s, t.node, n); let o; if (function (e) { return e && Zc(e.canActivateChild) }(i)) o = Ju(i.canActivateChild(r, e)); else { if (!Zc(i)) throw new Error("Invalid CanActivateChild guard"); o = Ju(i(r, e)) } return o.pipe(Ya()) })).pipe(hh()))); return ba(s).pipe(hh()) } class mh { } class yh { constructor(e, t, n, r, s, i) { this.rootComponentType = e, this.config = t, this.urlTree = n, this.url = r, this.paramsInheritanceStrategy = s, this.relativeLinkResolution = i } recognize() { try { const e = _h(this.urlTree.root, [], [], this.config, this.relativeLinkResolution).segmentGroup, t = this.processSegmentGroup(this.config, e, "primary"), n = new Rc([], Object.freeze({}), Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, {}, "primary", this.rootComponentType, null, this.urlTree.root, -1, {}), r = new Cc(n, t), s = new Ac(this.url, r); return this.inheritParamsAndData(s._root), ba(s) } catch (e) { return new _(t => t.error(e)) } } inheritParamsAndData(e) { const t = e.value, n = kc(t, this.paramsInheritanceStrategy); t.params = Object.freeze(n.params), t.data = Object.freeze(n.data), e.children.forEach(e => this.inheritParamsAndData(e)) } processSegmentGroup(e, t, n) { return 0 === t.segments.length && t.hasChildren() ? this.processChildren(e, t) : this.processSegment(e, t, t.segments, n) } processChildren(e, t) { const n = rc(t, (t, n) => this.processSegmentGroup(e, t, n)); return function (e) { const t = {}; e.forEach(e => { const n = t[e.value.outlet]; if (n) { const t = n.url.map(e => e.toString()).join("/"), r = e.value.url.map(e => e.toString()).join("/"); throw new Error(`Two segments cannot have the same outlet name: '${t}' and '${r}'.`) } t[e.value.outlet] = e.value }) }(n), n.sort((e, t) => "primary" === e.value.outlet ? -1 : "primary" === t.value.outlet ? 1 : e.value.outlet.localeCompare(t.value.outlet)), n } processSegment(e, t, n, r) { for (const i of e) try { return this.processSegmentAgainstRoute(i, t, n, r) } catch (s) { if (!(s instanceof mh)) throw s } if (this.noLeftoversInUrl(t, n, r)) return []; throw new mh } noLeftoversInUrl(e, t, n) { return 0 === t.length && !e.children[n] } processSegmentAgainstRoute(e, t, n, r) { if (e.redirectTo) throw new mh; if ((e.outlet || "primary") !== r) throw new mh; let s, i = [], o = []; if ("**" === e.path) { const i = n.length > 0 ? Gu(n).parameters : {}; s = new Rc(n, i, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, xh(e), r, e.component, e, vh(t), wh(t) + n.length, Sh(e)) } else { const a = function (e, t, n) { if ("" === t.path) { if ("full" === t.pathMatch && (e.hasChildren() || n.length > 0)) throw new mh; return { consumedSegments: [], lastChild: 0, parameters: {} } } const r = (t.matcher || Fu)(n, e, t); if (!r) throw new mh; const s = {}; Ku(r.posParams, (e, t) => { s[t] = e.path }); const i = r.consumed.length > 0 ? Object.assign({}, s, r.consumed[r.consumed.length - 1].parameters) : s; return { consumedSegments: r.consumed, lastChild: r.consumed.length, parameters: i } }(t, e, n); i = a.consumedSegments, o = n.slice(a.lastChild), s = new Rc(i, a.parameters, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, xh(e), r, e.component, e, vh(t), wh(t) + i.length, Sh(e)) } const a = function (e) { return e.children ? e.children : e.loadChildren ? e._loadedConfig.routes : [] }(e), { segmentGroup: l, slicedSegments: u } = _h(t, i, o, a, this.relativeLinkResolution); if (0 === u.length && l.hasChildren()) { const e = this.processChildren(a, l); return [new Cc(s, e)] } if (0 === a.length && 0 === u.length) return [new Cc(s, [])]; const c = this.processSegment(a, l, u, "primary"); return [new Cc(s, c)] } } function vh(e) { let t = e; for (; t._sourceSegment;)t = t._sourceSegment; return t } function wh(e) { let t = e, n = t._segmentIndexShift ? t._segmentIndexShift : 0; for (; t._sourceSegment;)t = t._sourceSegment, n += t._segmentIndexShift ? t._segmentIndexShift : 0; return n - 1 } function _h(e, t, n, r, s) { if (n.length > 0 && function (e, t, n) { return n.some(n => bh(e, t, n) && "primary" !== Ch(n)) }(e, n, r)) { const s = new ec(t, function (e, t, n, r) { const s = {}; s.primary = r, r._sourceSegment = e, r._segmentIndexShift = t.length; for (const i of n) if ("" === i.path && "primary" !== Ch(i)) { const n = new ec([], {}); n._sourceSegment = e, n._segmentIndexShift = t.length, s[Ch(i)] = n } return s }(e, t, r, new ec(n, e.children))); return s._sourceSegment = e, s._segmentIndexShift = t.length, { segmentGroup: s, slicedSegments: [] } } if (0 === n.length && function (e, t, n) { return n.some(n => bh(e, t, n)) }(e, n, r)) { const i = new ec(e.segments, function (e, t, n, r, s, i) { const o = {}; for (const a of r) if (bh(e, n, a) && !s[Ch(a)]) { const n = new ec([], {}); n._sourceSegment = e, n._segmentIndexShift = "legacy" === i ? e.segments.length : t.length, o[Ch(a)] = n } return Object.assign({}, s, o) }(e, t, n, r, e.children, s)); return i._sourceSegment = e, i._segmentIndexShift = t.length, { segmentGroup: i, slicedSegments: n } } const i = new ec(e.segments, e.children); return i._sourceSegment = e, i._segmentIndexShift = t.length, { segmentGroup: i, slicedSegments: n } } function bh(e, t, n) { return (!(e.hasChildren() || t.length > 0) || "full" !== n.pathMatch) && "" === n.path && void 0 === n.redirectTo } function Ch(e) { return e.outlet || "primary" } function xh(e) { return e.data || {} } function Sh(e) { return e.resolve || {} } function Eh(e, t, n, r) { const s = lh(e, t, r); return Ju(s.resolve ? s.resolve(t, n) : s(t, n)) } function Th(e) { return function (t) { return t.pipe(tl(t => { const n = e(t); return n ? F(n).pipe(L(() => t)) : F([t]) })) } } class kh { } class Rh { shouldDetach(e) { return !1 } store(e, t) { } shouldAttach(e) { return !1 } retrieve(e) { return null } shouldReuseRoute(e, t) { return e.routeConfig === t.routeConfig } } const Ah = new _e("ROUTES"); class Ih { constructor(e, t, n, r) { this.loader = e, this.compiler = t, this.onLoadStartListener = n, this.onLoadEndListener = r } load(e, t) { return this.onLoadStartListener && this.onLoadStartListener(t), this.loadModuleFactory(t.loadChildren).pipe(L(n => { this.onLoadEndListener && this.onLoadEndListener(t); const r = n.create(e); return new $u(Qu(r.injector.get(Ah)).map(Wu), r) })) } loadModuleFactory(e) { return "string" == typeof e ? F(this.loader.load(e)) : Ju(e()).pipe($(e => e instanceof Ne ? ba(e) : F(this.compiler.compileModuleAsync(e)))) } } class Nh { } class Ph { shouldProcessUrl(e) { return !0 } extract(e) { return e } merge(e, t) { return e } } function Oh(e) { throw e } function Dh(e, t, n) { return t.parse("/") } function Uh(e, t) { return ba(null) } class Mh { constructor(e, t, n, r, s, i, o, a) { this.rootComponentType = e, this.urlSerializer = t, this.rootContexts = n, this.location = r, this.config = a, this.lastSuccessfulNavigation = null, this.currentNavigation = null, this.navigationId = 0, this.isNgZoneEnabled = !1, this.events = new E, this.errorHandler = Oh, this.malformedUriErrorHandler = Dh, this.navigated = !1, this.lastSuccessfulId = -1, this.hooks = { beforePreactivation: Uh, afterPreactivation: Uh }, this.urlHandlingStrategy = new Ph, this.routeReuseStrategy = new Rh, this.onSameUrlNavigation = "ignore", this.paramsInheritanceStrategy = "emptyOnly", this.urlUpdateStrategy = "deferred", this.relativeLinkResolution = "legacy", this.ngModule = s.get(Ie), this.console = s.get(ws); const l = s.get(Ls); this.isNgZoneEnabled = l instanceof Ls, this.resetConfig(a), this.currentUrlTree = new Xu(new ec([], {}), {}, null), this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.configLoader = new Ih(i, o, e => this.triggerEvent(new Iu(e)), e => this.triggerEvent(new Nu(e))), this.routerState = Ec(this.currentUrlTree, this.rootComponentType), this.transitions = new Ca({ id: 0, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree), urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree), rawUrl: this.currentUrlTree, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: "imperative", restoredState: null, currentSnapshot: this.routerState.snapshot, targetSnapshot: null, currentRouterState: this.routerState, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.navigations = this.setupNavigations(this.transitions), this.processNavigations() } setupNavigations(e) { const t = this.events; return e.pipe(Na(e => 0 !== e.id), L(e => Object.assign({}, e, { extractedUrl: this.urlHandlingStrategy.extract(e.rawUrl) })), tl(e => { let n = !1, r = !1; return ba(e).pipe(ul(e => { this.currentNavigation = { id: e.id, initialUrl: e.currentRawUrl, extractedUrl: e.extractedUrl, trigger: e.source, extras: e.extras, previousNavigation: this.lastSuccessfulNavigation ? Object.assign({}, this.lastSuccessfulNavigation, { previousNavigation: null }) : null } }), tl(e => { const n = !this.navigated || e.extractedUrl.toString() !== this.browserUrlTree.toString(); if (("reload" === this.onSameUrlNavigation || n) && this.urlHandlingStrategy.shouldProcessUrl(e.rawUrl)) return ba(e).pipe(tl(e => { const n = this.transitions.getValue(); return t.next(new bu(e.id, this.serializeUrl(e.extractedUrl), e.source, e.restoredState)), n !== this.transitions.getValue() ? ka : [e] }), tl(e => Promise.resolve(e)), (r = this.ngModule.injector, s = this.configLoader, i = this.urlSerializer, o = this.config, function (e) { return e.pipe(tl(e => function (e, t, n, r, s) { return new eh(e, t, n, r, s).apply() }(r, s, i, e.extractedUrl, o).pipe(L(t => Object.assign({}, e, { urlAfterRedirects: t }))))) }), ul(e => { this.currentNavigation = Object.assign({}, this.currentNavigation, { finalUrl: e.urlAfterRedirects }) }), function (e, t, n, r, s) { return function (i) { return i.pipe($(i => function (e, t, n, r, s = "emptyOnly", i = "legacy") { return new yh(e, t, n, r, s, i).recognize() }(e, t, i.urlAfterRedirects, n(i.urlAfterRedirects), r, s).pipe(L(e => Object.assign({}, i, { targetSnapshot: e }))))) } }(this.rootComponentType, this.config, e => this.serializeUrl(e), this.paramsInheritanceStrategy, this.relativeLinkResolution), ul(e => { "eager" === this.urlUpdateStrategy && (e.extras.skipLocationChange || this.setBrowserUrl(e.urlAfterRedirects, !!e.extras.replaceUrl, e.id, e.extras.state), this.browserUrlTree = e.urlAfterRedirects) }), ul(e => { const n = new Eu(e.id, this.serializeUrl(e.extractedUrl), this.serializeUrl(e.urlAfterRedirects), e.targetSnapshot); t.next(n) })); var r, s, i, o; if (n && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) { const { id: n, extractedUrl: r, source: s, restoredState: i, extras: o } = e, a = new bu(n, this.serializeUrl(r), s, i); t.next(a); const l = Ec(r, this.rootComponentType).snapshot; return ba(Object.assign({}, e, { targetSnapshot: l, urlAfterRedirects: r, extras: Object.assign({}, o, { skipLocationChange: !1, replaceUrl: !1 }) })) } return this.rawUrlTree = e.rawUrl, this.browserUrlTree = e.urlAfterRedirects, e.resolve(null), ka }), Th(e => { const { targetSnapshot: t, id: n, extractedUrl: r, rawUrl: s, extras: { skipLocationChange: i, replaceUrl: o } } = e; return this.hooks.beforePreactivation(t, { navigationId: n, appliedUrlTree: r, rawUrlTree: s, skipLocationChange: !!i, replaceUrl: !!o }) }), ul(e => { const t = new Tu(e.id, this.serializeUrl(e.extractedUrl), this.serializeUrl(e.urlAfterRedirects), e.targetSnapshot); this.triggerEvent(t) }), L(e => Object.assign({}, e, { guards: ah(e.targetSnapshot, e.currentSnapshot, this.rootContexts) })), function (e, t) { return function (n) { return n.pipe($(n => { const { targetSnapshot: r, currentSnapshot: s, guards: { canActivateChecks: i, canDeactivateChecks: o } } = n; return 0 === o.length && 0 === i.length ? ba(Object.assign({}, n, { guardsResult: !0 })) : function (e, t, n, r) { return F(e).pipe($(e => function (e, t, n, r, s) { const i = t && t.routeConfig ? t.routeConfig.canDeactivate : null; return i && 0 !== i.length ? ba(i.map(i => { const o = lh(i, t, s); let a; if (function (e) { return e && Zc(e.canDeactivate) }(o)) a = Ju(o.canDeactivate(e, t, n, r)); else { if (!Zc(o)) throw new Error("Invalid CanDeactivate guard"); a = Ju(o(e, t, n, r)) } return a.pipe(Ya()) })).pipe(hh()) : ba(!0) }(e.component, e.route, n, t, r)), Ya(e => !0 !== e, !0)) }(o, r, s, e).pipe($(n => n && "boolean" == typeof n ? function (e, t, n, r) { return F(t).pipe(ll(t => F([ph(t.route.parent, r), dh(t.route, r), gh(e, t.path, n), fh(e, t.route, n)]).pipe(Ia(), Ya(e => !0 !== e, !0))), Ya(e => !0 !== e, !0)) }(r, i, e, t) : ba(n)), L(e => Object.assign({}, n, { guardsResult: e }))) })) } }(this.ngModule.injector, e => this.triggerEvent(e)), ul(e => { if (Qc(e.guardsResult)) { const t = Hu(`Redirecting to "${this.serializeUrl(e.guardsResult)}"`); throw t.url = e.guardsResult, t } }), ul(e => { const t = new ku(e.id, this.serializeUrl(e.extractedUrl), this.serializeUrl(e.urlAfterRedirects), e.targetSnapshot, !!e.guardsResult); this.triggerEvent(t) }), Na(e => { if (!e.guardsResult) { this.resetUrlToCurrentUrlTree(); const n = new xu(e.id, this.serializeUrl(e.extractedUrl), ""); return t.next(n), e.resolve(!1), !1 } return !0 }), Th(e => { if (e.guards.canActivateChecks.length) return ba(e).pipe(ul(e => { const t = new Ru(e.id, this.serializeUrl(e.extractedUrl), this.serializeUrl(e.urlAfterRedirects), e.targetSnapshot); this.triggerEvent(t) }), (t = this.paramsInheritanceStrategy, n = this.ngModule.injector, function (e) { return e.pipe($(e => { const { targetSnapshot: r, guards: { canActivateChecks: s } } = e; return s.length ? F(s).pipe(ll(e => function (e, t, n, r) { return function (e, t, n, r) { const s = Object.keys(e); if (0 === s.length) return ba({}); if (1 === s.length) { const i = s[0]; return Eh(e[i], t, n, r).pipe(L(e => ({ [i]: e }))) } const i = {}; return F(s).pipe($(s => Eh(e[s], t, n, r).pipe(L(e => (i[s] = e, e))))).pipe(qa(), L(() => i)) }(e._resolve, e, t, r).pipe(L(t => (e._resolvedData = t, e.data = Object.assign({}, e.data, kc(e, n).resolve), null))) }(e.route, r, t, n)), function (e, t) { return arguments.length >= 2 ? function (n) { return v(il(e, t), Ua(1), $a(t))(n) } : function (t) { return v(il((t, n, r) => e(t, n, r + 1)), Ua(1))(t) } }((e, t) => e), L(t => e)) : ba(e) })) }), ul(e => { const t = new Au(e.id, this.serializeUrl(e.extractedUrl), this.serializeUrl(e.urlAfterRedirects), e.targetSnapshot); this.triggerEvent(t) })); var t, n }), Th(e => { const { targetSnapshot: t, id: n, extractedUrl: r, rawUrl: s, extras: { skipLocationChange: i, replaceUrl: o } } = e; return this.hooks.afterPreactivation(t, { navigationId: n, appliedUrlTree: r, rawUrlTree: s, skipLocationChange: !!i, replaceUrl: !!o }) }), L(e => { const t = function (e, t, n) { const r = function e(t, n, r) { if (r && t.shouldReuseRoute(n.value, r.value.snapshot)) { const s = r.value; s._futureSnapshot = n.value; const i = function (t, n, r) { return n.children.map(n => { for (const s of r.children) if (t.shouldReuseRoute(s.value.snapshot, n.value)) return e(t, n, s); return e(t, n) }) }(t, n, r); return new Cc(s, i) } { const r = t.retrieve(n.value); if (r) { const e = r.route; return function e(t, n) { if (t.value.routeConfig !== n.value.routeConfig) throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route"); if (t.children.length !== n.children.length) throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children"); n.value._futureSnapshot = t.value; for (let r = 0; r < t.children.length; ++r)e(t.children[r], n.children[r]) }(n, e), e } { const r = new Tc(new Ca((s = n.value).url), new Ca(s.params), new Ca(s.queryParams), new Ca(s.fragment), new Ca(s.data), s.outlet, s.component, s), i = n.children.map(n => e(t, n)); return new Cc(r, i) } } var s }(e, t._root, n ? n._root : void 0); return new Sc(r, t) }(this.routeReuseStrategy, e.targetSnapshot, e.currentRouterState); return Object.assign({}, e, { targetRouterState: t }) }), ul(e => { this.currentUrlTree = e.urlAfterRedirects, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, e.rawUrl), this.routerState = e.targetRouterState, "deferred" === this.urlUpdateStrategy && (e.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, !!e.extras.replaceUrl, e.id, e.extras.state), this.browserUrlTree = e.urlAfterRedirects) }), (i = this.rootContexts, o = this.routeReuseStrategy, a = e => this.triggerEvent(e), L(e => (new qc(o, e.targetRouterState, e.currentRouterState, a).activate(i), e))), ul({ next() { n = !0 }, complete() { n = !0 } }), (s = () => { if (!n && !r) { this.resetUrlToCurrentUrlTree(); const n = new xu(e.id, this.serializeUrl(e.extractedUrl), `Navigation ID ${e.id} is not equal to the current navigation id ${this.navigationId}`); t.next(n), e.resolve(!1) } this.currentNavigation = null }, e => e.lift(new dl(s))), Wa(n => { if (r = !0, (s = n) && s.ngNavigationCancelingError) { const r = Qc(n.url); r || (this.navigated = !0, this.resetStateAndUrl(e.currentRouterState, e.currentUrlTree, e.rawUrl)); const s = new xu(e.id, this.serializeUrl(e.extractedUrl), n.message); t.next(s), e.resolve(!1), r && this.navigateByUrl(n.url) } else { this.resetStateAndUrl(e.currentRouterState, e.currentUrlTree, e.rawUrl); const r = new Su(e.id, this.serializeUrl(e.extractedUrl), n); t.next(r); try { e.resolve(this.errorHandler(n)) } catch (i) { e.reject(i) } } var s; return ka })); var s, i, o, a })) } resetRootComponentType(e) { this.rootComponentType = e, this.routerState.root.component = this.rootComponentType } getTransition() { const e = this.transitions.value; return e.urlAfterRedirects = this.browserUrlTree, e } setTransition(e) { this.transitions.next(Object.assign({}, this.getTransition(), e)) } initialNavigation() { this.setUpLocationChangeListener(), 0 === this.navigationId && this.navigateByUrl(this.location.path(!0), { replaceUrl: !0 }) } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(e => { let t = this.parseUrl(e.url); const n = "popstate" === e.type ? "popstate" : "hashchange", r = e.state && e.state.navigationId ? e.state : null; setTimeout(() => { this.scheduleNavigation(t, n, r, { replaceUrl: !0 }) }, 0) })) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.currentNavigation } triggerEvent(e) { this.events.next(e) } resetConfig(e) { zu(e), this.config = e.map(Wu), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = null) } createUrlTree(e, t = {}) { const { relativeTo: n, queryParams: r, fragment: s, preserveQueryParams: i, queryParamsHandling: o, preserveFragment: a } = t; $e() && i && console && console.warn && console.warn("preserveQueryParams is deprecated, use queryParamsHandling instead."); const l = n || this.routerState.root, u = a ? this.currentUrlTree.fragment : s; let c = null; if (o) switch (o) { case "merge": c = Object.assign({}, this.currentUrlTree.queryParams, r); break; case "preserve": c = this.currentUrlTree.queryParams; break; default: c = r || null } else c = i ? this.currentUrlTree.queryParams : r || null; return null !== c && (c = this.removeEmptyProps(c)), function (e, t, n, r, s) { if (0 === n.length) return Uc(t.root, t.root, t, r, s); const i = function (e) { if ("string" == typeof e[0] && 1 === e.length && "/" === e[0]) return new Mc(!0, 0, e); let t = 0, n = !1; const r = e.reduce((e, r, s) => { if ("object" == typeof r && null != r) { if (r.outlets) { const t = {}; return Ku(r.outlets, (e, n) => { t[n] = "string" == typeof e ? e.split("/") : e }), [...e, { outlets: t }] } if (r.segmentPath) return [...e, r.segmentPath] } return "string" != typeof r ? [...e, r] : 0 === s ? (r.split("/").forEach((r, s) => { 0 == s && "." === r || (0 == s && "" === r ? n = !0 : ".." === r ? t++ : "" != r && e.push(r)) }), e) : [...e, r] }, []); return new Mc(n, t, r) }(n); if (i.toRoot()) return Uc(t.root, new ec([], {}), t, r, s); const o = function (e, t, n) { if (e.isAbsolute) return new Lc(t.root, !0, 0); if (-1 === n.snapshot._lastPathIndex) return new Lc(n.snapshot._urlSegment, !0, 0); const r = Dc(e.commands[0]) ? 0 : 1; return function (e, t, n) { let r = e, s = t, i = n; for (; i > s;) { if (i -= s, r = r.parent, !r) throw new Error("Invalid number of '../'"); s = r.segments.length } return new Lc(r, !1, s - i) }(n.snapshot._urlSegment, n.snapshot._lastPathIndex + r, e.numberOfDoubleDots) }(i, t, e), a = o.processChildren ? Hc(o.segmentGroup, o.index, i.commands) : Vc(o.segmentGroup, o.index, i.commands); return Uc(o.segmentGroup, a, t, r, s) }(l, this.currentUrlTree, e, c, u) } navigateByUrl(e, t = { skipLocationChange: !1 }) { $e() && this.isNgZoneEnabled && !Ls.isInAngularZone() && this.console.warn("Navigation triggered outside Angular zone, did you forget to call 'ngZone.run()'?"); const n = Qc(e) ? e : this.parseUrl(e), r = this.urlHandlingStrategy.merge(n, this.rawUrlTree); return this.scheduleNavigation(r, "imperative", null, t) } navigate(e, t = { skipLocationChange: !1 }) { return function (e) { for (let t = 0; t < e.length; t++) { const n = e[t]; if (null == n) throw new Error(`The requested path contains ${n} segment at index ${t}`) } }(e), this.navigateByUrl(this.createUrlTree(e, t), t) } serializeUrl(e) { return this.urlSerializer.serialize(e) } parseUrl(e) { let t; try { t = this.urlSerializer.parse(e) } catch (n) { t = this.malformedUriErrorHandler(n, this.urlSerializer, e) } return t } isActive(e, t) { if (Qc(e)) return Yu(this.currentUrlTree, e, t); const n = this.parseUrl(e); return Yu(this.currentUrlTree, n, t) } removeEmptyProps(e) { return Object.keys(e).reduce((t, n) => { const r = e[n]; return null != r && (t[n] = r), t }, {}) } processNavigations() { this.navigations.subscribe(e => { this.navigated = !0, this.lastSuccessfulId = e.id, this.events.next(new Cu(e.id, this.serializeUrl(e.extractedUrl), this.serializeUrl(this.currentUrlTree))), this.lastSuccessfulNavigation = this.currentNavigation, this.currentNavigation = null, e.resolve(!0) }, e => { this.console.warn("Unhandled Navigation Error: ") }) } scheduleNavigation(e, t, n, r) { const s = this.getTransition(); if (s && "imperative" !== t && "imperative" === s.source && s.rawUrl.toString() === e.toString()) return Promise.resolve(!0); if (s && "hashchange" == t && "popstate" === s.source && s.rawUrl.toString() === e.toString()) return Promise.resolve(!0); if (s && "popstate" == t && "hashchange" === s.source && s.rawUrl.toString() === e.toString()) return Promise.resolve(!0); let i = null, o = null; const a = new Promise((e, t) => { i = e, o = t }), l = ++this.navigationId; return this.setTransition({ id: l, source: t, restoredState: n, currentUrlTree: this.currentUrlTree, currentRawUrl: this.rawUrlTree, rawUrl: e, extras: r, resolve: i, reject: o, promise: a, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), a.catch(e => Promise.reject(e)) } setBrowserUrl(e, t, n, r) { const s = this.urlSerializer.serialize(e); r = r || {}, this.location.isCurrentPathEqualTo(s) || t ? this.location.replaceState(s, "", Object.assign({}, r, { navigationId: n })) : this.location.go(s, "", Object.assign({}, r, { navigationId: n })) } resetStateAndUrl(e, t, n) { this.routerState = e, this.currentUrlTree = t, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, n), this.resetUrlToCurrentUrlTree() } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", { navigationId: this.lastSuccessfulId }) } } class Lh { constructor(e, t, n, r, s) { this.router = e, this.route = t, this.commands = [], null == n && r.setAttribute(s.nativeElement, "tabindex", "0") } set routerLink(e) { this.commands = null != e ? Array.isArray(e) ? e : [e] : [] } set preserveQueryParams(e) { $e() && console && console.warn && console.warn("preserveQueryParams is deprecated!, use queryParamsHandling instead."), this.preserve = e } onClick() { const e = { skipLocationChange: Vh(this.skipLocationChange), replaceUrl: Vh(this.replaceUrl) }; return this.router.navigateByUrl(this.urlTree, e), !0 } get urlTree() { return this.router.createUrlTree(this.commands, { relativeTo: this.route, queryParams: this.queryParams, fragment: this.fragment, preserveQueryParams: Vh(this.preserve), queryParamsHandling: this.queryParamsHandling, preserveFragment: Vh(this.preserveFragment) }) } } class jh { constructor(e, t, n) { this.router = e, this.route = t, this.locationStrategy = n, this.commands = [], this.subscription = e.events.subscribe(e => { e instanceof Cu && this.updateTargetUrlAndHref() }) } set routerLink(e) { this.commands = null != e ? Array.isArray(e) ? e : [e] : [] } set preserveQueryParams(e) { $e() && console && console.warn && console.warn("preserveQueryParams is deprecated, use queryParamsHandling instead."), this.preserve = e } ngOnChanges(e) { this.updateTargetUrlAndHref() } ngOnDestroy() { this.subscription.unsubscribe() } onClick(e, t, n, r) { if (0 !== e || t || n || r) return !0; if ("string" == typeof this.target && "_self" != this.target) return !0; const s = { skipLocationChange: Vh(this.skipLocationChange), replaceUrl: Vh(this.replaceUrl), state: this.state }; return this.router.navigateByUrl(this.urlTree, s), !1 } updateTargetUrlAndHref() { this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree)) } get urlTree() { return this.router.createUrlTree(this.commands, { relativeTo: this.route, queryParams: this.queryParams, fragment: this.fragment, preserveQueryParams: Vh(this.preserve), queryParamsHandling: this.queryParamsHandling, preserveFragment: Vh(this.preserveFragment) }) } } function Vh(e) { return "" === e || !!e } class Hh { constructor(e, t, n, r, s) { this.router = e, this.element = t, this.renderer = n, this.link = r, this.linkWithHref = s, this.classes = [], this.isActive = !1, this.routerLinkActiveOptions = { exact: !1 }, this.subscription = e.events.subscribe(e => { e instanceof Cu && this.update() }) } ngAfterContentInit() { this.links.changes.subscribe(e => this.update()), this.linksWithHrefs.changes.subscribe(e => this.update()), this.update() } set routerLinkActive(e) { const t = Array.isArray(e) ? e : e.split(" "); this.classes = t.filter(e => !!e) } ngOnChanges(e) { this.update() } ngOnDestroy() { this.subscription.unsubscribe() } update() { this.links && this.linksWithHrefs && this.router.navigated && Promise.resolve().then(() => { const e = this.hasActiveLinks(); this.isActive !== e && (this.isActive = e, this.classes.forEach(t => { e ? this.renderer.addClass(this.element.nativeElement, t) : this.renderer.removeClass(this.element.nativeElement, t) })) }) } isLinkActive(e) { return t => e.isActive(t.urlTree, this.routerLinkActiveOptions.exact) } hasActiveLinks() { const e = this.isLinkActive(this.router); return this.link && e(this.link) || this.linkWithHref && e(this.linkWithHref) || this.links.some(e) || this.linksWithHrefs.some(e) } } class Fh { constructor() { this.outlet = null, this.route = null, this.resolver = null, this.children = new $h, this.attachRef = null } } class $h { constructor() { this.contexts = new Map } onChildOutletCreated(e, t) { const n = this.getOrCreateContext(e); n.outlet = t, this.contexts.set(e, n) } onChildOutletDestroyed(e) { const t = this.getContext(e); t && (t.outlet = null) } onOutletDeactivated() { const e = this.contexts; return this.contexts = new Map, e } onOutletReAttached(e) { this.contexts = e } getOrCreateContext(e) { let t = this.getContext(e); return t || (t = new Fh, this.contexts.set(e, t)), t } getContext(e) { return this.contexts.get(e) || null } } class zh { constructor(e, t, n, r, s) { this.parentContexts = e, this.location = t, this.resolver = n, this.changeDetector = s, this.activated = null, this._activatedRoute = null, this.activateEvents = new cs, this.deactivateEvents = new cs, this.name = r || "primary", e.onChildOutletCreated(this.name, this) } ngOnDestroy() { this.parentContexts.onChildOutletDestroyed(this.name) } ngOnInit() { if (!this.activated) { const e = this.parentContexts.getContext(this.name); e && e.route && (e.attachRef ? this.attach(e.attachRef, e.route) : this.activateWith(e.route, e.resolver || null)) } } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new Error("Outlet is not activated"); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new Error("Outlet is not activated"); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new Error("Outlet is not activated"); this.location.detach(); const e = this.activated; return this.activated = null, this._activatedRoute = null, e } attach(e, t) { this.activated = e, this._activatedRoute = t, this.location.insert(e.hostView) } deactivate() { if (this.activated) { const e = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(e) } } activateWith(e, t) { if (this.isActivated) throw new Error("Cannot activate an already activated outlet"); this._activatedRoute = e; const n = (t = t || this.resolver).resolveComponentFactory(e._futureSnapshot.routeConfig.component), r = this.parentContexts.getOrCreateContext(this.name).children, s = new Bh(e, r, this.location.injector); this.activated = this.location.createComponent(n, this.location.length, s), this.changeDetector.markForCheck(), this.activateEvents.emit(this.activated.instance) } } class Bh { constructor(e, t, n) { this.route = e, this.childContexts = t, this.parent = n } get(e, t) { return e === Tc ? this.route : e === $h ? this.childContexts : this.parent.get(e, t) } } class qh { } class Wh { preload(e, t) { return t().pipe(Wa(() => ba(null))) } } class Zh { preload(e, t) { return ba(null) } } class Qh { constructor(e, t, n, r, s) { this.router = e, this.injector = r, this.preloadingStrategy = s, this.loader = new Ih(t, n, t => e.triggerEvent(new Iu(t)), t => e.triggerEvent(new Nu(t))) } setUpPreloading() { this.subscription = this.router.events.pipe(Na(e => e instanceof Cu), ll(() => this.preload())).subscribe(() => { }) } preload() { const e = this.injector.get(Ie); return this.processRoutes(e, this.router.config) } ngOnDestroy() { this.subscription.unsubscribe() } processRoutes(e, t) { const n = []; for (const r of t) if (r.loadChildren && !r.canLoad && r._loadedConfig) { const e = r._loadedConfig; n.push(this.processRoutes(e.module, e.routes)) } else r.loadChildren && !r.canLoad ? n.push(this.preloadConfig(e, r)) : r.children && n.push(this.processRoutes(e, r.children)); return F(n).pipe(W(), L(e => { })) } preloadConfig(e, t) { return this.preloadingStrategy.preload(t, () => this.loader.load(e.injector, t).pipe($(e => (t._loadedConfig = e, this.processRoutes(e.module, e.routes))))) } } class Gh { constructor(e, t, n = {}) { this.router = e, this.viewportScroller = t, this.options = n, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, n.scrollPositionRestoration = n.scrollPositionRestoration || "disabled", n.anchorScrolling = n.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.router.events.subscribe(e => { e instanceof bu ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = e.navigationTrigger, this.restoredId = e.restoredState ? e.restoredState.navigationId : 0) : e instanceof Cu && (this.lastId = e.id, this.scheduleScrollEvent(e, this.router.parseUrl(e.urlAfterRedirects).fragment)) }) } consumeScrollEvents() { return this.router.events.subscribe(e => { e instanceof Mu && (e.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(e.position) : e.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(e.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(e, t) { this.router.triggerEvent(new Mu(e, "popstate" === this.lastSource ? this.store[this.restoredId] : null, t)) } ngOnDestroy() { this.routerEventsSubscription && this.routerEventsSubscription.unsubscribe(), this.scrollEventsSubscription && this.scrollEventsSubscription.unsubscribe() } } const Kh = new _e("ROUTER_CONFIGURATION"), Jh = new _e("ROUTER_FORROOT_GUARD"), Yh = [Yo, { provide: sc, useClass: ic }, { provide: Mh, useFactory: id, deps: [ti, sc, $h, Yo, _t, ri, Ts, Ah, Kh, [Nh, new re], [kh, new re]] }, $h, { provide: Tc, useFactory: od, deps: [Mh] }, { provide: ri, useClass: oi }, Qh, Zh, Wh, { provide: Kh, useValue: { enableTracing: !1 } }]; function Xh() { return new Ks("Router", Mh) } class ed { constructor(e, t) { } static forRoot(e, t) { return { ngModule: ed, providers: [Yh, sd(e), { provide: Jh, useFactory: rd, deps: [[Mh, new re, new ie]] }, { provide: Kh, useValue: t || {} }, { provide: Ko, useFactory: nd, deps: [Qo, [new ne(Jo), new re], Kh] }, { provide: Gh, useFactory: td, deps: [Mh, wa, Kh] }, { provide: qh, useExisting: t && t.preloadingStrategy ? t.preloadingStrategy : Zh }, { provide: Ks, multi: !0, useFactory: Xh }, [ad, { provide: ps, multi: !0, useFactory: ld, deps: [ad] }, { provide: cd, useFactory: ud, deps: [ad] }, { provide: vs, multi: !0, useExisting: cd }]] } } static forChild(e) { return { ngModule: ed, providers: [sd(e)] } } } function td(e, t, n) { return n.scrollOffset && t.setOffset(n.scrollOffset), new Gh(e, t, n) } function nd(e, t, n = {}) { return n.useHash ? new ea(e, t) : new ta(e, t) } function rd(e) { if (e) throw new Error("RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead."); return "guarded" } function sd(e) { return [{ provide: Rt, multi: !0, useValue: e }, { provide: Ah, multi: !0, useValue: e }] } function id(e, t, n, r, s, i, o, a, l = {}, u, c) { const h = new Mh(null, t, n, r, s, i, o, Qu(a)); if (u && (h.urlHandlingStrategy = u), c && (h.routeReuseStrategy = c), l.errorHandler && (h.errorHandler = l.errorHandler), l.malformedUriErrorHandler && (h.malformedUriErrorHandler = l.malformedUriErrorHandler), l.enableTracing) { const e = gl(); h.events.subscribe(t => { e.logGroup(`Router Event: ${t.constructor.name}`), e.log(t.toString()), e.log(t), e.logGroupEnd() }) } return l.onSameUrlNavigation && (h.onSameUrlNavigation = l.onSameUrlNavigation), l.paramsInheritanceStrategy && (h.paramsInheritanceStrategy = l.paramsInheritanceStrategy), l.urlUpdateStrategy && (h.urlUpdateStrategy = l.urlUpdateStrategy), l.relativeLinkResolution && (h.relativeLinkResolution = l.relativeLinkResolution), h } function od(e) { return e.routerState.root } class ad { constructor(e) { this.injector = e, this.initNavigation = !1, this.resultOfPreactivationDone = new E } appInitializer() { return this.injector.get(Go, Promise.resolve(null)).then(() => { let e = null; const t = new Promise(t => e = t), n = this.injector.get(Mh), r = this.injector.get(Kh); if (this.isLegacyDisabled(r) || this.isLegacyEnabled(r)) e(!0); else if ("disabled" === r.initialNavigation) n.setUpLocationChangeListener(), e(!0); else { if ("enabled" !== r.initialNavigation) throw new Error(`Invalid initialNavigation options: '${r.initialNavigation}'`); n.hooks.afterPreactivation = () => this.initNavigation ? ba(null) : (this.initNavigation = !0, e(!0), this.resultOfPreactivationDone), n.initialNavigation() } return t }) } bootstrapListener(e) { const t = this.injector.get(Kh), n = this.injector.get(Qh), r = this.injector.get(Gh), s = this.injector.get(Mh), i = this.injector.get(ti); e === i.components[0] && (this.isLegacyEnabled(t) ? s.initialNavigation() : this.isLegacyDisabled(t) && s.setUpLocationChangeListener(), n.setUpPreloading(), r.init(), s.resetRootComponentType(i.componentTypes[0]), this.resultOfPreactivationDone.next(null), this.resultOfPreactivationDone.complete()) } isLegacyEnabled(e) { return "legacy_enabled" === e.initialNavigation || !0 === e.initialNavigation || void 0 === e.initialNavigation } isLegacyDisabled(e) { return "legacy_disabled" === e.initialNavigation || !1 === e.initialNavigation } } function ld(e) { return e.appInitializer.bind(e) } function ud(e) { return e.bootstrapListener.bind(e) } const cd = new _e("Router Initializer"); var hd = Mn({ encapsulation: 2, styles: [], data: {} }); function dd(e) { return ji(0, [(e()(), bi(0, 16777216, null, null, 1, "router-outlet", [], null, null, null, null, null)), Br(1, 212992, null, 0, zh, [$h, _n, zt, [8, null], mt], null, null)], (function (e, t) { e(t, 1, 0) }), null) } function pd(e) { return ji(0, [(e()(), bi(0, 0, null, null, 1, "ng-component", [], null, null, null, dd, hd)), Br(1, 49152, null, 0, Lu, [], null, null)], null, null) } var fd = _r("ng-component", Lu, pd, {}, {}, []); class gd { } var md = Mn({ encapsulation: 2, styles: [], data: {} }); function yd(e) { return ji(0, [(e()(), bi(0, 0, null, null, 1, "h1", [], null, null, null, null, null)), (e()(), Ui(-1, null, ["Hello, world!"])), (e()(), bi(2, 0, null, null, 1, "p", [], null, null, null, null, null)), (e()(), Ui(-1, null, ["Welcome to your new single-page application, built with:"])), (e()(), bi(4, 0, null, null, 18, "ul", [], null, null, null, null, null)), (e()(), bi(5, 0, null, null, 6, "li", [], null, null, null, null, null)), (e()(), bi(6, 0, null, null, 1, "a", [["href", "https://get.asp.net/"]], null, null, null, null, null)), (e()(), Ui(-1, null, ["ASP.NET Core"])), (e()(), Ui(-1, null, [" and "])), (e()(), bi(9, 0, null, null, 1, "a", [["href", "https://msdn.microsoft.com/en-us/library/67ef8sbd.aspx"]], null, null, null, null, null)), (e()(), Ui(-1, null, ["C#"])), (e()(), Ui(-1, null, [" for cross-platform server-side code"])), (e()(), bi(12, 0, null, null, 6, "li", [], null, null, null, null, null)), (e()(), bi(13, 0, null, null, 1, "a", [["href", "https://angular.io/"]], null, null, null, null, null)), (e()(), Ui(-1, null, ["Angular"])), (e()(), Ui(-1, null, [" and "])), (e()(), bi(16, 0, null, null, 1, "a", [["href", "http://www.typescriptlang.org/"]], null, null, null, null, null)), (e()(), Ui(-1, null, ["TypeScript"])), (e()(), Ui(-1, null, [" for client-side code"])), (e()(), bi(19, 0, null, null, 3, "li", [], null, null, null, null, null)), (e()(), bi(20, 0, null, null, 1, "a", [["href", "http://getbootstrap.com/"]], null, null, null, null, null)), (e()(), Ui(-1, null, ["Bootstrap"])), (e()(), Ui(-1, null, [" for layout and styling"])), (e()(), bi(23, 0, null, null, 1, "p", [], null, null, null, null, null)), (e()(), Ui(-1, null, ["To help you get started, we've also set up:"])), (e()(), bi(25, 0, null, null, 27, "ul", [], null, null, null, null, null)), (e()(), bi(26, 0, null, null, 9, "li", [], null, null, null, null, null)), (e()(), bi(27, 0, null, null, 1, "strong", [], null, null, null, null, null)), (e()(), Ui(-1, null, ["Client-side navigation"])), (e()(), Ui(-1, null, [". For example, click "])), (e()(), bi(30, 0, null, null, 1, "em", [], null, null, null, null, null)), (e()(), Ui(-1, null, ["Counter"])), (e()(), Ui(-1, null, [" then "])), (e()(), bi(33, 0, null, null, 1, "em", [], null, null, null, null, null)), (e()(), Ui(-1, null, ["Back"])), (e()(), Ui(-1, null, [" to return here."])), (e()(), bi(36, 0, null, null, 6, "li", [], null, null, null, null, null)), (e()(), bi(37, 0, null, null, 1, "strong", [], null, null, null, null, null)), (e()(), Ui(-1, null, ["Angular CLI integration"])), (e()(), Ui(-1, null, [". In development mode, there's no need to run "])), (e()(), bi(40, 0, null, null, 1, "code", [], null, null, null, null, null)), (e()(), Ui(-1, null, ["ng serve"])), (e()(), Ui(-1, null, [". It runs in the background automatically, so your client-side resources are dynamically built on demand and the page refreshes when you modify any file."])), (e()(), bi(43, 0, null, null, 9, "li", [], null, null, null, null, null)), (e()(), bi(44, 0, null, null, 1, "strong", [], null, null, null, null, null)), (e()(), Ui(-1, null, ["Efficient production builds"])), (e()(), Ui(-1, null, [". In production mode, development-time features are disabled, and your "])), (e()(), bi(47, 0, null, null, 1, "code", [], null, null, null, null, null)), (e()(), Ui(-1, null, ["dotnet publish"])), (e()(), Ui(-1, null, [" configuration automatically invokes "])), (e()(), bi(50, 0, null, null, 1, "code", [], null, null, null, null, null)), (e()(), Ui(-1, null, ["ng build"])), (e()(), Ui(-1, null, [" to produce minified, ahead-of-time compiled JavaScript files."])), (e()(), bi(53, 0, null, null, 13, "p", [], null, null, null, null, null)), (e()(), Ui(-1, null, ["The "])), (e()(), bi(55, 0, null, null, 1, "code", [], null, null, null, null, null)), (e()(), Ui(-1, null, ["ClientApp"])), (e()(), Ui(-1, null, [" subdirectory is a standard Angular CLI application. If you open a command prompt in that directory, you can run any "])), (e()(), bi(58, 0, null, null, 1, "code", [], null, null, null, null, null)), (e()(), Ui(-1, null, ["ng"])), (e()(), Ui(-1, null, [" command (e.g., "])), (e()(), bi(61, 0, null, null, 1, "code", [], null, null, null, null, null)), (e()(), Ui(-1, null, ["ng test"])), (e()(), Ui(-1, null, ["), or use "])), (e()(), bi(64, 0, null, null, 1, "code", [], null, null, null, null, null)), (e()(), Ui(-1, null, ["npm"])), (e()(), Ui(-1, null, [" to install extra packages into it."]))], null, null) } function vd(e) { return ji(0, [(e()(), bi(0, 0, null, null, 1, "app-home", [], null, null, null, yd, md)), Br(1, 49152, null, 0, gd, [], null, null)], null, null) } var wd = _r("app-home", gd, vd, {}, {}, []); class _d { constructor() { this.currentCount = 0 } incrementCounter() { this.currentCount++ } } var bd = Mn({ encapsulation: 2, styles: [], data: {} }); function Cd(e) { return ji(0, [(e()(), bi(0, 0, null, null, 1, "h1", [], null, null, null, null, null)), (e()(), Ui(-1, null, ["Counter"])), (e()(), bi(2, 0, null, null, 1, "p", [], null, null, null, null, null)), (e()(), Ui(-1, null, ["This is a simple example of an Angular component."])), (e()(), bi(4, 0, null, null, 3, "p", [["aria-live", "polite"]], null, null, null, null, null)), (e()(), Ui(-1, null, ["Current count: "])), (e()(), bi(6, 0, null, null, 1, "strong", [], null, null, null, null, null)), (e()(), Ui(7, null, ["", ""])), (e()(), bi(8, 0, null, null, 1, "button", [["class", "btn btn-primary"]], null, [[null, "click"]], (function (e, t, n) { var r = !0; return "click" === t && (r = !1 !== e.component.incrementCounter() && r), r }), null, null)), (e()(), Ui(-1, null, ["Increment"]))], null, (function (e, t) { e(t, 7, 0, t.component.currentCount) })) } function xd(e) { return ji(0, [(e()(), bi(0, 0, null, null, 1, "app-counter-component", [], null, null, null, Cd, bd)), Br(1, 49152, null, 0, _d, [], null, null)], null, null) } var Sd = _r("app-counter-component", _d, xd, {}, {}, []); class Ed { constructor(e, t) { e.get(t + "weatherforecast").subscribe(e => { this.forecasts = e }, e => console.error(e)) } } class Td { } class kd { } class Rd { constructor(e) { this.normalizedNames = new Map, this.lazyUpdate = null, e ? this.lazyInit = "string" == typeof e ? () => { this.headers = new Map, e.split("\n").forEach(e => { const t = e.indexOf(":"); if (t > 0) { const n = e.slice(0, t), r = n.toLowerCase(), s = e.slice(t + 1).trim(); this.maybeSetNormalizedName(n, r), this.headers.has(r) ? this.headers.get(r).push(s) : this.headers.set(r, [s]) } }) } : () => { this.headers = new Map, Object.keys(e).forEach(t => { let n = e[t]; const r = t.toLowerCase(); "string" == typeof n && (n = [n]), n.length > 0 && (this.headers.set(r, n), this.maybeSetNormalizedName(t, r)) }) } : this.headers = new Map } has(e) { return this.init(), this.headers.has(e.toLowerCase()) } get(e) { this.init(); const t = this.headers.get(e.toLowerCase()); return t && t.length > 0 ? t[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(e) { return this.init(), this.headers.get(e.toLowerCase()) || null } append(e, t) { return this.clone({ name: e, value: t, op: "a" }) } set(e, t) { return this.clone({ name: e, value: t, op: "s" }) } delete(e, t) { return this.clone({ name: e, value: t, op: "d" }) } maybeSetNormalizedName(e, t) { this.normalizedNames.has(t) || this.normalizedNames.set(t, e) } init() { this.lazyInit && (this.lazyInit instanceof Rd ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(e => this.applyUpdate(e)), this.lazyUpdate = null)) } copyFrom(e) { e.init(), Array.from(e.headers.keys()).forEach(t => { this.headers.set(t, e.headers.get(t)), this.normalizedNames.set(t, e.normalizedNames.get(t)) }) } clone(e) { const t = new Rd; return t.lazyInit = this.lazyInit && this.lazyInit instanceof Rd ? this.lazyInit : this, t.lazyUpdate = (this.lazyUpdate || []).concat([e]), t } applyUpdate(e) { const t = e.name.toLowerCase(); switch (e.op) { case "a": case "s": let n = e.value; if ("string" == typeof n && (n = [n]), 0 === n.length) return; this.maybeSetNormalizedName(e.name, t); const r = ("a" === e.op ? this.headers.get(t) : void 0) || []; r.push(...n), this.headers.set(t, r); break; case "d": const s = e.value; if (s) { let e = this.headers.get(t); if (!e) return; e = e.filter(e => -1 === s.indexOf(e)), 0 === e.length ? (this.headers.delete(t), this.normalizedNames.delete(t)) : this.headers.set(t, e) } else this.headers.delete(t), this.normalizedNames.delete(t) } } forEach(e) { this.init(), Array.from(this.normalizedNames.keys()).forEach(t => e(this.normalizedNames.get(t), this.headers.get(t))) } } class Ad { encodeKey(e) { return Id(e) } encodeValue(e) { return Id(e) } decodeKey(e) { return decodeURIComponent(e) } decodeValue(e) { return decodeURIComponent(e) } } function Id(e) { return encodeURIComponent(e).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/gi, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%2B/gi, "+").replace(/%3D/gi, "=").replace(/%3F/gi, "?").replace(/%2F/gi, "/") } class Nd { constructor(e = {}) { if (this.updates = null, this.cloneFrom = null, this.encoder = e.encoder || new Ad, e.fromString) { if (e.fromObject) throw new Error("Cannot specify both fromString and fromObject."); this.map = function (e, t) { const n = new Map; return e.length > 0 && e.split("&").forEach(e => { const r = e.indexOf("="), [s, i] = -1 == r ? [t.decodeKey(e), ""] : [t.decodeKey(e.slice(0, r)), t.decodeValue(e.slice(r + 1))], o = n.get(s) || []; o.push(i), n.set(s, o) }), n }(e.fromString, this.encoder) } else e.fromObject ? (this.map = new Map, Object.keys(e.fromObject).forEach(t => { const n = e.fromObject[t]; this.map.set(t, Array.isArray(n) ? n : [n]) })) : this.map = null } has(e) { return this.init(), this.map.has(e) } get(e) { this.init(); const t = this.map.get(e); return t ? t[0] : null } getAll(e) { return this.init(), this.map.get(e) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(e, t) { return this.clone({ param: e, value: t, op: "a" }) } set(e, t) { return this.clone({ param: e, value: t, op: "s" }) } delete(e, t) { return this.clone({ param: e, value: t, op: "d" }) } toString() { return this.init(), this.keys().map(e => { const t = this.encoder.encodeKey(e); return this.map.get(e).map(e => t + "=" + this.encoder.encodeValue(e)).join("&") }).join("&") } clone(e) { const t = new Nd({ encoder: this.encoder }); return t.cloneFrom = this.cloneFrom || this, t.updates = (this.updates || []).concat([e]), t } init() { null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(e => this.map.set(e, this.cloneFrom.map.get(e))), this.updates.forEach(e => { switch (e.op) { case "a": case "s": const t = ("a" === e.op ? this.map.get(e.param) : void 0) || []; t.push(e.value), this.map.set(e.param, t); break; case "d": if (void 0 === e.value) { this.map.delete(e.param); break } { let t = this.map.get(e.param) || []; const n = t.indexOf(e.value); -1 !== n && t.splice(n, 1), t.length > 0 ? this.map.set(e.param, t) : this.map.delete(e.param) } } }), this.cloneFrom = this.updates = null) } } function Pd(e) { return "undefined" != typeof ArrayBuffer && e instanceof ArrayBuffer } function Od(e) { return "undefined" != typeof Blob && e instanceof Blob } function Dd(e) { return "undefined" != typeof FormData && e instanceof FormData } class Ud { constructor(e, t, n, r) { let s; if (this.url = t, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = e.toUpperCase(), function (e) { switch (e) { case "DELETE": case "GET": case "HEAD": case "OPTIONS": case "JSONP": return !1; default: return !0 } }(this.method) || r ? (this.body = void 0 !== n ? n : null, s = r) : s = n, s && (this.reportProgress = !!s.reportProgress, this.withCredentials = !!s.withCredentials, s.responseType && (this.responseType = s.responseType), s.headers && (this.headers = s.headers), s.params && (this.params = s.params)), this.headers || (this.headers = new Rd), this.params) { const e = this.params.toString(); if (0 === e.length) this.urlWithParams = t; else { const n = t.indexOf("?"); this.urlWithParams = t + (-1 === n ? "?" : n < t.length - 1 ? "&" : "") + e } } else this.params = new Nd, this.urlWithParams = t } serializeBody() { return null === this.body ? null : Pd(this.body) || Od(this.body) || Dd(this.body) || "string" == typeof this.body ? this.body : this.body instanceof Nd ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return null === this.body ? null : Dd(this.body) ? null : Od(this.body) ? this.body.type || null : Pd(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof Nd ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || Array.isArray(this.body) ? "application/json" : null } clone(e = {}) { const t = e.method || this.method, n = e.url || this.url, r = e.responseType || this.responseType, s = void 0 !== e.body ? e.body : this.body, i = void 0 !== e.withCredentials ? e.withCredentials : this.withCredentials, o = void 0 !== e.reportProgress ? e.reportProgress : this.reportProgress; let a = e.headers || this.headers, l = e.params || this.params; return void 0 !== e.setHeaders && (a = Object.keys(e.setHeaders).reduce((t, n) => t.set(n, e.setHeaders[n]), a)), e.setParams && (l = Object.keys(e.setParams).reduce((t, n) => t.set(n, e.setParams[n]), l)), new Ud(t, n, s, { params: l, headers: a, reportProgress: o, responseType: r, withCredentials: i }) } } const Md = function () { var e = { Sent: 0, UploadProgress: 1, ResponseHeader: 2, DownloadProgress: 3, Response: 4, User: 5 }; return e[e.Sent] = "Sent", e[e.UploadProgress] = "UploadProgress", e[e.ResponseHeader] = "ResponseHeader", e[e.DownloadProgress] = "DownloadProgress", e[e.Response] = "Response", e[e.User] = "User", e }(); class Ld { constructor(e, t = 200, n = "OK") { this.headers = e.headers || new Rd, this.status = void 0 !== e.status ? e.status : t, this.statusText = e.statusText || n, this.url = e.url || null, this.ok = this.status >= 200 && this.status < 300 } } class jd extends Ld { constructor(e = {}) { super(e), this.type = Md.ResponseHeader } clone(e = {}) { return new jd({ headers: e.headers || this.headers, status: void 0 !== e.status ? e.status : this.status, statusText: e.statusText || this.statusText, url: e.url || this.url || void 0 }) } } class Vd extends Ld { constructor(e = {}) { super(e), this.type = Md.Response, this.body = void 0 !== e.body ? e.body : null } clone(e = {}) { return new Vd({ body: void 0 !== e.body ? e.body : this.body, headers: e.headers || this.headers, status: void 0 !== e.status ? e.status : this.status, statusText: e.statusText || this.statusText, url: e.url || this.url || void 0 }) } } class Hd extends Ld { constructor(e) { super(e, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.message = this.status >= 200 && this.status < 300 ? `Http failure during parsing for ${e.url || "(unknown url)"}` : `Http failure response for ${e.url || "(unknown url)"}: ${e.status} ${e.statusText}`, this.error = e.error || null } } function Fd(e, t) { return { body: t, headers: e.headers, observe: e.observe, params: e.params, reportProgress: e.reportProgress, responseType: e.responseType, withCredentials: e.withCredentials } } class $d { constructor(e) { this.handler = e } request(e, t, n = {}) { let r; if (e instanceof Ud) r = e; else { let s = void 0; s = n.headers instanceof Rd ? n.headers : new Rd(n.headers); let i = void 0; n.params && (i = n.params instanceof Nd ? n.params : new Nd({ fromObject: n.params })), r = new Ud(e, t, void 0 !== n.body ? n.body : null, { headers: s, params: i, reportProgress: n.reportProgress, responseType: n.responseType || "json", withCredentials: n.withCredentials }) } const s = ba(r).pipe(ll(e => this.handler.handle(e))); if (e instanceof Ud || "events" === n.observe) return s; const i = s.pipe(Na(e => e instanceof Vd)); switch (n.observe || "body") { case "body": switch (r.responseType) { case "arraybuffer": return i.pipe(L(e => { if (null !== e.body && !(e.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer."); return e.body })); case "blob": return i.pipe(L(e => { if (null !== e.body && !(e.body instanceof Blob)) throw new Error("Response is not a Blob."); return e.body })); case "text": return i.pipe(L(e => { if (null !== e.body && "string" != typeof e.body) throw new Error("Response is not a string."); return e.body })); case "json": default: return i.pipe(L(e => e.body)) }case "response": return i; default: throw new Error(`Unreachable: unhandled observe type ${n.observe}}`) } } delete(e, t = {}) { return this.request("DELETE", e, t) } get(e, t = {}) { return this.request("GET", e, t) } head(e, t = {}) { return this.request("HEAD", e, t) } jsonp(e, t) { return this.request("JSONP", e, { params: (new Nd).append(t, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(e, t = {}) { return this.request("OPTIONS", e, t) } patch(e, t, n = {}) { return this.request("PATCH", e, Fd(n, t)) } post(e, t, n = {}) { return this.request("POST", e, Fd(n, t)) } put(e, t, n = {}) { return this.request("PUT", e, Fd(n, t)) } } class zd { constructor(e, t) { this.next = e, this.interceptor = t } handle(e) { return this.interceptor.intercept(e, this.next) } } const Bd = new _e("HTTP_INTERCEPTORS"); class qd { intercept(e, t) { return t.handle(e) } } const Wd = /^\)\]\}',?\n/; class Zd { } class Qd { constructor() { } build() { return new XMLHttpRequest } } class Gd { constructor(e) { this.xhrFactory = e } handle(e) { if ("JSONP" === e.method) throw new Error("Attempted to construct Jsonp request without JsonpClientModule installed."); return new _(t => { const n = this.xhrFactory.build(); if (n.open(e.method, e.urlWithParams), e.withCredentials && (n.withCredentials = !0), e.headers.forEach((e, t) => n.setRequestHeader(e, t.join(","))), e.headers.has("Accept") || n.setRequestHeader("Accept", "application/json, text/plain, */*"), !e.headers.has("Content-Type")) { const t = e.detectContentTypeHeader(); null !== t && n.setRequestHeader("Content-Type", t) } if (e.responseType) { const t = e.responseType.toLowerCase(); n.responseType = "json" !== t ? t : "text" } const r = e.serializeBody(); let s = null; const i = () => { if (null !== s) return s; const t = 1223 === n.status ? 204 : n.status, r = n.statusText || "OK", i = new Rd(n.getAllResponseHeaders()), o = function (e) { return "responseURL" in e && e.responseURL ? e.responseURL : /^X-Request-URL:/m.test(e.getAllResponseHeaders()) ? e.getResponseHeader("X-Request-URL") : null }(n) || e.url; return s = new jd({ headers: i, status: t, statusText: r, url: o }), s }, o = () => { let { headers: r, status: s, statusText: o, url: a } = i(), l = null; 204 !== s && (l = void 0 === n.response ? n.responseText : n.response), 0 === s && (s = l ? 200 : 0); let u = s >= 200 && s < 300; if ("json" === e.responseType && "string" == typeof l) { const e = l; l = l.replace(Wd, ""); try { l = "" !== l ? JSON.parse(l) : null } catch (c) { l = e, u && (u = !1, l = { error: c, text: l }) } } u ? (t.next(new Vd({ body: l, headers: r, status: s, statusText: o, url: a || void 0 })), t.complete()) : t.error(new Hd({ error: l, headers: r, status: s, statusText: o, url: a || void 0 })) }, a = e => { const { url: r } = i(), s = new Hd({ error: e, status: n.status || 0, statusText: n.statusText || "Unknown Error", url: r || void 0 }); t.error(s) }; let l = !1; const u = r => { l || (t.next(i()), l = !0); let s = { type: Md.DownloadProgress, loaded: r.loaded }; r.lengthComputable && (s.total = r.total), "text" === e.responseType && n.responseText && (s.partialText = n.responseText), t.next(s) }, c = e => { let n = { type: Md.UploadProgress, loaded: e.loaded }; e.lengthComputable && (n.total = e.total), t.next(n) }; return n.addEventListener("load", o), n.addEventListener("error", a), e.reportProgress && (n.addEventListener("progress", u), null !== r && n.upload && n.upload.addEventListener("progress", c)), n.send(r), t.next({ type: Md.Sent }), () => { n.removeEventListener("error", a), n.removeEventListener("load", o), e.reportProgress && (n.removeEventListener("progress", u), null !== r && n.upload && n.upload.removeEventListener("progress", c)), n.abort() } }) } } const Kd = new _e("XSRF_COOKIE_NAME"), Jd = new _e("XSRF_HEADER_NAME"); class Yd { } class Xd { constructor(e, t, n) { this.doc = e, this.platform = t, this.cookieName = n, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0 } getToken() { if ("server" === this.platform) return null; const e = this.doc.cookie || ""; return e !== this.lastCookieString && (this.parseCount++, this.lastToken = oa(e, this.cookieName), this.lastCookieString = e), this.lastToken } } class ep { constructor(e, t) { this.tokenService = e, this.headerName = t } intercept(e, t) { const n = e.url.toLowerCase(); if ("GET" === e.method || "HEAD" === e.method || n.startsWith("http://") || n.startsWith("https://")) return t.handle(e); const r = this.tokenService.getToken(); return null === r || e.headers.has(this.headerName) || (e = e.clone({ headers: e.headers.set(this.headerName, r) })), t.handle(e) } } class tp { constructor(e, t) { this.backend = e, this.injector = t, this.chain = null } handle(e) { if (null === this.chain) { const e = this.injector.get(Bd, []); this.chain = e.reduceRight((e, t) => new zd(e, t), this.backend) } return this.chain.handle(e) } } class np { static disable() { return { ngModule: np, providers: [{ provide: ep, useClass: qd }] } } static withOptions(e = {}) { return { ngModule: np, providers: [e.cookieName ? { provide: Kd, useValue: e.cookieName } : [], e.headerName ? { provide: Jd, useValue: e.headerName } : []] } } } class rp { } var sp = Mn({ encapsulation: 2, styles: [], data: {} }); function ip(e) { return ji(0, [(e()(), bi(0, 0, null, null, 2, "p", [], null, null, null, null, null)), (e()(), bi(1, 0, null, null, 1, "em", [], null, null, null, null, null)), (e()(), Ui(-1, null, ["Loading..."]))], null, null) } function op(e) { return ji(0, [(e()(), bi(0, 0, null, null, 8, "tr", [], null, null, null, null, null)), (e()(), bi(1, 0, null, null, 1, "td", [], null, null, null, null, null)), (e()(), Ui(2, null, ["", ""])), (e()(), bi(3, 0, null, null, 1, "td", [], null, null, null, null, null)), (e()(), Ui(4, null, ["", ""])), (e()(), bi(5, 0, null, null, 1, "td", [], null, null, null, null, null)), (e()(), Ui(6, null, ["", ""])), (e()(), bi(7, 0, null, null, 1, "td", [], null, null, null, null, null)), (e()(), Ui(8, null, ["", ""]))], null, (function (e, t) { e(t, 2, 0, t.context.$implicit.date), e(t, 4, 0, t.context.$implicit.temperatureC), e(t, 6, 0, t.context.$implicit.temperatureF), e(t, 8, 0, t.context.$implicit.summary) })) } function ap(e) { return ji(0, [(e()(), bi(0, 0, null, null, 13, "table", [["aria-labelledby", "tableLabel"], ["class", "table table-striped"]], null, null, null, null, null)), (e()(), bi(1, 0, null, null, 9, "thead", [], null, null, null, null, null)), (e()(), bi(2, 0, null, null, 8, "tr", [], null, null, null, null, null)), (e()(), bi(3, 0, null, null, 1, "th", [], null, null, null, null, null)), (e()(), Ui(-1, null, ["Date"])), (e()(), bi(5, 0, null, null, 1, "th", [], null, null, null, null, null)), (e()(), Ui(-1, null, ["Temp. (C)"])), (e()(), bi(7, 0, null, null, 1, "th", [], null, null, null, null, null)), (e()(), Ui(-1, null, ["Temp. (F)"])), (e()(), bi(9, 0, null, null, 1, "th", [], null, null, null, null, null)), (e()(), Ui(-1, null, ["Summary"])), (e()(), bi(11, 0, null, null, 2, "tbody", [], null, null, null, null, null)), (e()(), _i(16777216, null, null, 1, null, op)), Br(13, 278528, null, 0, da, [_n, vn, pn], { ngForOf: [0, "ngForOf"] }, null)], (function (e, t) { e(t, 13, 0, t.component.forecasts) }), null) } function lp(e) { return ji(0, [(e()(), bi(0, 0, null, null, 1, "h1", [["id", "tableLabel"]], null, null, null, null, null)), (e()(), Ui(-1, null, ["Weather forecast"])), (e()(), bi(2, 0, null, null, 1, "p", [], null, null, null, null, null)), (e()(), Ui(-1, null, ["This component demonstrates fetching data from the server."])), (e()(), _i(16777216, null, null, 1, null, ip)), Br(5, 16384, null, 0, fa, [_n, vn], { ngIf: [0, "ngIf"] }, null), (e()(), _i(16777216, null, null, 1, null, ap)), Br(7, 16384, null, 0, fa, [_n, vn], { ngIf: [0, "ngIf"] }, null)], (function (e, t) { var n = t.component; e(t, 5, 0, !n.forecasts), e(t, 7, 0, n.forecasts) }), null) } function up(e) { return ji(0, [(e()(), bi(0, 0, null, null, 1, "app-fetch-data", [], null, null, null, lp, sp)), Br(1, 49152, null, 0, Ed, [$d, "BASE_URL"], null, null)], null, null) } var cp = _r("app-fetch-data", Ed, up, {}, {}, []); class hp { constructor() { this.isExpanded = !1 } collapse() { this.isExpanded = !1 } toggle() { this.isExpanded = !this.isExpanded } } var dp = Mn({ encapsulation: 0, styles: [["a.navbar-brand[_ngcontent-%COMP%]{white-space:normal;text-align:center;word-break:break-all}html[_ngcontent-%COMP%]{font-size:14px}@media (min-width:768px){html[_ngcontent-%COMP%]{font-size:16px}}.box-shadow[_ngcontent-%COMP%]{box-shadow:0 .25rem .75rem rgba(0,0,0,.05)}"]], data: {} }); function pp(e) { return ji(0, [(e()(), bi(0, 0, null, null, 41, "header", [], null, null, null, null, null)), (e()(), bi(1, 0, null, null, 40, "nav", [["class", "navbar navbar-expand-sm navbar-toggleable-sm navbar-light bg-white border-bottom box-shadow mb-3"]], null, null, null, null, null)), (e()(), bi(2, 0, null, null, 39, "div", [["class", "container"]], null, null, null, null, null)), (e()(), bi(3, 0, null, null, 3, "a", [["class", "navbar-brand"]], [[1, "target", 0], [8, "href", 4]], [[null, "click"]], (function (e, t, n) { var r = !0; return "click" === t && (r = !1 !== Nr(e, 4).onClick(n.button, n.ctrlKey, n.metaKey, n.shiftKey) && r), r }), null, null)), Br(4, 671744, null, 0, jh, [Mh, Tc, Ko], { routerLink: [0, "routerLink"] }, null), Pi(5, 1), (e()(), Ui(-1, null, ["AuditLogDemo"])),(e()(),bi(7,0,null,null,1,"button",[["aria-label","Toggle navigation"],["class","navbar-toggler"],["data-target",".navbar-collapse"],["data-toggle","collapse"],["type","button"]],[[1,"aria-expanded",0]],[[null,"click"]],(function(e,t,n){var r=!0;return"click"===t&&(r=!1!==e.component.toggle()&&r),r}),null,null)),(e()(),bi(8,0,null,null,0,"span",[["class","navbar-toggler-icon"]],null,null,null,null,null)),(e()(),bi(9,0,null,null,32,"div",[["class","navbar-collapse collapse d-sm-inline-flex flex-sm-row-reverse"]],null,null,null,null,null)),(t=aa,n=la,r=[pn,fn,Zt,Yt],qr(-1,512,null,0,t,n,r)),Br(11,278528,null,0,ca,[aa],{klass:[0,"klass"],ngClass:[1,"ngClass"]},null),Oi(12,{show:0}),(e()(),bi(13,0,null,null,28,"ul",[["class","navbar-nav flex-grow"]],null,null,null,null,null)),(e()(),bi(14,0,null,null,9,"li",[["class","nav-item"]],null,null,null,null,null)),Br(15,1720320,null,2,Hh,[Mh,Zt,Yt,[2,Lh],[2,jh]],{routerLinkActiveOptions:[0,"routerLinkActiveOptions"],routerLinkActive:[1,"routerLinkActive"]},null),Ti(603979776,1,{links:1}),Ti(603979776,2,{linksWithHrefs:1}),Oi(18,{exact:0}),Pi(19,1),(e()(),bi(20,0,null,null,3,"a",[["class","nav-link text-dark"]],[[1,"target",0],[8,"href",4]],[[null,"click"]],(function(e,t,n){var r=!0;return"click"===t&&(r=!1!==Nr(e,21).onClick(n.button,n.ctrlKey,n.metaKey,n.shiftKey)&&r),r}),null,null)),Br(21,671744,[[2,4]],0,jh,[Mh,Tc,Ko],{routerLink:[0,"routerLink"]},null),Pi(22,1),(e()(),Ui(-1,null,["Home"])),(e()(),bi(24,0,null,null,8,"li",[["class","nav-item"]],null,null,null,null,null)),Br(25,1720320,null,2,Hh,[Mh,Zt,Yt,[2,Lh],[2,jh]],{routerLinkActive:[0,"routerLinkActive"]},null),Ti(603979776,3,{links:1}),Ti(603979776,4,{linksWithHrefs:1}),Pi(28,1),(e()(),bi(29,0,null,null,3,"a",[["class","nav-link text-dark"]],[[1,"target",0],[8,"href",4]],[[null,"click"]],(function(e,t,n){var r=!0;return"click"===t&&(r=!1!==Nr(e,30).onClick(n.button,n.ctrlKey,n.metaKey,n.shiftKey)&&r),r}),null,null)),Br(30,671744,[[4,4]],0,jh,[Mh,Tc,Ko],{routerLink:[0,"routerLink"]},null),Pi(31,1),(e()(),Ui(-1,null,["Counter"])),(e()(),bi(33,0,null,null,8,"li",[["class","nav-item"]],null,null,null,null,null)),Br(34,1720320,null,2,Hh,[Mh,Zt,Yt,[2,Lh],[2,jh]],{routerLinkActive:[0,"routerLinkActive"]},null),Ti(603979776,5,{links:1}),Ti(603979776,6,{linksWithHrefs:1}),Pi(37,1),(e()(),bi(38,0,null,null,3,"a",[["class","nav-link text-dark"]],[[1,"target",0],[8,"href",4]],[[null,"click"]],(function(e,t,n){var r=!0;return"click"===t&&(r=!1!==Nr(e,39).onClick(n.button,n.ctrlKey,n.metaKey,n.shiftKey)&&r),r}),null,null)),Br(39,671744,[[6,4]],0,jh,[Mh,Tc,Ko],{routerLink:[0,"routerLink"]},null),Pi(40,1),(e()(),Ui(-1,null,["Fetch data"]))],(function(e,t){var n=t.component,r=e(t,5,0,"/");e(t,4,0,r);var s=e(t,12,0,n.isExpanded);e(t,11,0,"navbar-collapse collapse d-sm-inline-flex flex-sm-row-reverse",s);var i=e(t,18,0,!0),o=e(t,19,0,"link-active");e(t,15,0,i,o);var a=e(t,22,0,"/");e(t,21,0,a);var l=e(t,28,0,"link-active");e(t,25,0,l);var u=e(t,31,0,"/counter");e(t,30,0,u);var c=e(t,37,0,"link-active");e(t,34,0,c);var h=e(t,40,0,"/fetch-data");e(t,39,0,h)}),(function(e,t){var n=t.component;e(t,3,0,Nr(t,4).target,Nr(t,4).href),e(t,7,0,n.isExpanded),e(t,20,0,Nr(t,21).target,Nr(t,21).href),e(t,29,0,Nr(t,30).target,Nr(t,30).href),e(t,38,0,Nr(t,39).target,Nr(t,39).href)}));var t,n,r}var fp=Mn({encapsulation:2,styles:[],data:{}});function gp(e){return ji(0,[(e()(),bi(0,0,null,null,5,"body",[],null,null,null,null,null)),(e()(),bi(1,0,null,null,1,"app-nav-menu",[],null,null,null,pp,dp)),Br(2,49152,null,0,hp,[],null,null),(e()(),bi(3,0,null,null,2,"div",[["class","container"]],null,null,null,null,null)),(e()(),bi(4,16777216,null,null,1,"router-outlet",[],null,null,null,null,null)),Br(5,212992,null,0,zh,[$h,_n,zt,[8,null],mt],null,null)],(function(e,t){e(t,5,0)}),null)}function mp(e){return ji(0,[(e()(),bi(0,0,null,null,1,"app-root",[],null,null,null,gp,fp)),Br(1,49152,null,0,Zo,[],null,null)],null,null)}var yp=_r("app-root",Zo,mp,{},{},[]);class vp{constructor(){this._accessors=[]}add(e,t){this._accessors.push([e,t])}remove(e){for(let t=this._accessors.length-1;t>=0;--t)if(this._accessors[t][1]===e)return void this._accessors.splice(t,1)}select(e){this._accessors.forEach(t=>{this._isSameGroup(t,e)&&t[1]!==e&&t[1].fireUncheck(e.value)})}_isSameGroup(e,t){return!!e[0].control&&e[0]._parent===t._control._parent&&e[1].name===t.name}}const wp=new _e("NgFormSelectorWarning");class _p{}class bp{static withConfig(e){return{ngModule:bp,providers:[{provide:wp,useValue:e.warnOnDeprecatedNgFormSelector}]}}}var Cp=Bo(Wo,[Zo],(function(e){return function(e){const t={},n=[];let r=!1;for(let s=0;s<e.length;s++){const i=e[s];i.token===vt&&!0===i.value&&(r=!0),1073741824&i.flags&&n.push(i.token),i.index=s,t[Un(i.token)]=i}return{factory:null,providersByKey:t,providers:e,modules:n,isRoot:r}}([pr(512,zt,Bt,[[8,[fd,wd,Sd,cp,yp]],[3,zt],Ie]),pr(5120,_s,yi,[[3,_s]]),pr(4608,sa,ia,[_s,[2,ra]]),pr(5120,is,vi,[Ls]),pr(5120,pn,gi,[]),pr(5120,fn,mi,[]),pr(4608,uu,cu,[va]),pr(6144,ht,null,[uu]),pr(4608,nu,su,[]),pr(5120,Nl,(function(e,t,n,r,s,i,o,a){return[new eu(e,t,n),new lu(r),new iu(s,i,o,a)]}),[va,Ls,ys,va,va,nu,ws,[2,ru]]),pr(4608,Pl,Pl,[Nl,Ls]),pr(135680,Ul,Ul,[va]),pr(4608,Hl,Hl,[Pl,Ul,gs]),pr(6144,Kt,null,[Hl]),pr(6144,Dl,null,[Ul]),pr(4608,Bs,Bs,[Ls]),pr(4608,Yd,Xd,[va,ys,Kd]),pr(4608,ep,ep,[Yd,Jd]),pr(5120,Bd,(function(e){return[e]}),[ep]),pr(4608,Qd,Qd,[]),pr(6144,Zd,null,[Qd]),pr(4608,Gd,Gd,[Zd]),pr(6144,kd,null,[Gd]),pr(4608,Td,tp,[kd,_t]),pr(4608,$d,$d,[Td]),pr(4608,vp,vp,[]),pr(5120,Tc,od,[Mh]),pr(4608,Zh,Zh,[]),pr(6144,qh,null,[Zh]),pr(135680,Qh,Qh,[Mh,ri,Ts,_t,qh]),pr(4608,Wh,Wh,[]),pr(5120,Gh,td,[Mh,wa,Kh]),pr(5120,cd,ud,[ad]),pr(5120,vs,(function(e){return[e]}),[cd]),pr(1073742336,ya,ya,[]),pr(1024,Ve,vu,[]),pr(1024,Ks,(function(){return[Xh()]}),[]),pr(256,gs,"ng-cli-universal",[]),pr(2048,Sl,null,[gs]),pr(512,ad,ad,[_t]),pr(1024,ps,(function(e,t,n,r,s){return[(i=e,Rl("probe",Il),Rl("coreTokens",Object.assign({},Al,(i||[]).reduce((e,t)=>(e[t.name]=t.token,e),{}))),()=>Il),El(t,n,r),ld(s)];var i}),[[2,Ks],Sl,va,_t,ad]),pr(512,fs,fs,[[2,ps]]),pr(131584,ti,ti,[Ls,ws,_t,Ve,zt,fs]),pr(1073742336,wi,wi,[ti]),pr(1073742336,wu,wu,[[3,wu]]),pr(1073742336,np,np,[]),pr(1073742336,rp,rp,[]),pr(1073742336,_p,_p,[]),pr(1073742336,bp,bp,[]),pr(1024,Jh,rd,[[3,Mh]]),pr(512,sc,ic,[]),pr(512,$h,$h,[]),pr(256,Kh,{},[]),pr(1024,Ko,nd,[Qo,[2,Jo],Kh]),pr(512,Yo,Yo,[Ko,Qo]),pr(512,Ts,Ts,[]),pr(512,ri,oi,[Ts,[2,si]]),pr(1024,Ah,(function(){return[[{path:"",component:gd,pathMatch:"full"},{path:"counter",component:_d},{path:"fetch-data",component:Ed}]]}),[]),pr(1024,Mh,id,[ti,sc,$h,Yo,_t,ri,Ts,Ah,Kh,[2,Nh],[2,kh]]),pr(1073742336,ed,ed,[[2,Jh],[2,Mh]]),pr(1073742336,Wo,Wo,[]),pr(256,vt,!0,[]),pr(256,Kd,"XSRF-TOKEN",[]),pr(256,Jd,"X-XSRF-TOKEN",[])])}));function xp(){return document.getElementsByTagName("base")[0].href}n.d(t,"getBaseUrl",(function(){return xp}));const Sp=[{provide:"BASE_URL",useFactory:xp,deps:[]}];(function(){if(Fe)throw new Error("Cannot enable prod mode after platform setup.");He=!1})(),yu(Sp).bootstrapModuleFactory(Cp).catch(e=>console.log(e))}},[[0,0]]]);